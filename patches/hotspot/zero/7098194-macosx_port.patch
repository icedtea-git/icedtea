diff -Nru openjdk.orig/hotspot/agent/src/os/bsd/MacosxDebuggerLocal.m openjdk/hotspot/agent/src/os/bsd/MacosxDebuggerLocal.m
--- openjdk.orig/hotspot/agent/src/os/bsd/MacosxDebuggerLocal.m	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/agent/src/os/bsd/MacosxDebuggerLocal.m	2012-07-25 15:27:37.275648905 +0100
@@ -0,0 +1,406 @@
+/*
+ * Copyright (c) 2002, 2007, 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include <objc/objc-runtime.h>
+#import <Foundation/Foundation.h>
+#import <JavaNativeFoundation/JavaNativeFoundation.h>
+
+#include <JavaVM/jni.h>
+
+#import <mach/mach.h>
+#import <mach/mach_types.h>
+#import <sys/sysctl.h>
+#import <stdlib.h>
+
+jboolean debug = JNI_FALSE;
+
+static jfieldID symbolicatorID = 0; // set in _init0
+static jfieldID taskID = 0; // set in _init0
+
+static void putSymbolicator(JNIEnv *env, jobject this_obj, id symbolicator) {
+  (*env)->SetLongField(env, this_obj, symbolicatorID, (jlong)(intptr_t)symbolicator);
+}
+
+static id getSymbolicator(JNIEnv *env, jobject this_obj) {
+  jlong ptr = (*env)->GetLongField(env, this_obj, symbolicatorID);
+  return (id)(intptr_t)ptr;
+}
+
+static void putTask(JNIEnv *env, jobject this_obj, task_t task) {
+  (*env)->SetLongField(env, this_obj, taskID, (jlong)task);
+}
+
+static task_t getTask(JNIEnv *env, jobject this_obj) {
+  jlong ptr = (*env)->GetLongField(env, this_obj, taskID);
+  return (task_t)ptr;
+}
+
+#define CHECK_EXCEPTION_(value) if ((*env)->ExceptionOccurred(env)) { return value; }
+#define CHECK_EXCEPTION if ((*env)->ExceptionOccurred(env)) { return;}
+#define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throw_new_debugger_exception(env, str); return value; }
+#define THROW_NEW_DEBUGGER_EXCEPTION(str) { throw_new_debugger_exception(env, str); return;}
+
+static void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
+  (*env)->ThrowNew(env, (*env)->FindClass(env, "sun/jvm/hotspot/debugger/DebuggerException"), errMsg);
+}
+
+#if defined(__i386__)
+    #define hsdb_thread_state_t     x86_thread_state32_t
+    #define hsdb_float_state_t      x86_float_state32_t
+    #define HSDB_THREAD_STATE       x86_THREAD_STATE32
+    #define HSDB_FLOAT_STATE        x86_FLOAT_STATE32
+    #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT
+    #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE32_COUNT
+#elif defined(__x86_64__)
+    #define hsdb_thread_state_t     x86_thread_state64_t
+    #define hsdb_float_state_t      x86_float_state64_t
+    #define HSDB_THREAD_STATE       x86_THREAD_STATE64
+    #define HSDB_FLOAT_STATE        x86_FLOAT_STATE64
+    #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
+    #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE64_COUNT
+#else
+    #error "Unsupported architecture"
+#endif
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    init0
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_init0(JNIEnv *env, jclass cls) {
+  symbolicatorID = (*env)->GetFieldID(env, cls, "symbolicator", "J");
+  taskID = (*env)->GetFieldID(env, cls, "task", "J");
+  CHECK_EXCEPTION;
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    lookupByName0
+ * Signature: (Ljava/lang/String;Ljava/lang/String;)J
+ */
+JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByName0(JNIEnv *env, jobject this_obj, jstring objectName, jstring symbolName) {
+  jlong address = 0;
+
+JNF_COCOA_ENTER(env);
+  NSString *symbolNameString = JNFJavaToNSString(env, symbolName);
+
+  if (debug) {
+    printf("lookupInProcess called for %s\n", [symbolNameString UTF8String]);
+  }
+
+  id symbolicator = getSymbolicator(env, this_obj);
+  if (symbolicator != nil) {
+    uint64_t (*dynamicCall)(id, SEL, NSString *) = (uint64_t (*)(id, SEL, NSString *))&objc_msgSend;
+    address = (jlong) dynamicCall(symbolicator, @selector(addressForSymbol:), symbolNameString);
+  }
+
+  if (debug) {
+    printf("address of symbol %s = %llx\n", [symbolNameString UTF8String], address);
+  }
+JNF_COCOA_EXIT(env);
+
+  return address;
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    readBytesFromProcess0
+ * Signature: (JJ)Lsun/jvm/hotspot/debugger/ReadResult;
+ */
+JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_readBytesFromProcess0(JNIEnv *env, jobject this_obj, jlong addr, jlong numBytes) {
+  if (debug) printf("readBytesFromProcess called. addr = %llx numBytes = %lld\n", addr, numBytes);
+
+  // must allocate storage instead of using former parameter buf
+  jboolean isCopy;
+  jbyteArray array;
+  jbyte *bufPtr;
+
+  array = (*env)->NewByteArray(env, numBytes);
+  CHECK_EXCEPTION_(0);
+
+  unsigned long alignedAddress;
+  unsigned long alignedLength;
+  kern_return_t result;
+  vm_offset_t *pages;
+  int *mapped;
+  long pageCount;
+  uint byteCount;
+  int i;
+  unsigned long remaining;
+
+  alignedAddress = trunc_page(addr);
+  if (addr != alignedAddress) {
+    alignedLength += addr - alignedAddress;
+  }
+  alignedLength = round_page(numBytes);
+  pageCount = alignedLength/vm_page_size;
+
+  // Allocate storage for pages and flags.
+  pages = malloc(pageCount * sizeof(vm_offset_t));
+  mapped = calloc(pageCount, sizeof(int));
+
+  task_t gTask = getTask(env, this_obj);
+  // Try to read each of the pages.
+  for (i = 0; i < pageCount; i++) {
+    result = vm_read(gTask, alignedAddress + i*vm_page_size, vm_page_size, 
+		     &pages[i], &byteCount);
+    mapped[i] = (result == KERN_SUCCESS); 
+    // assume all failures are unmapped pages
+  }
+
+  if (debug) fprintf(stderr, "%ld pages\n", pageCount);
+	
+  remaining = numBytes;
+	
+  for (i = 0; i < pageCount; i++) {
+    unsigned long len = vm_page_size;
+    unsigned long start = 0;
+
+    if (i == 0) {
+      start = addr - alignedAddress;
+      len = vm_page_size - start;
+    }
+
+    if (i == (pageCount - 1)) {
+      len = remaining;
+    }
+
+    if (mapped[i]) {
+      if (debug) fprintf(stderr, "page %d mapped (len %ld start %ld)\n", i, len, start);
+      (*env)->SetByteArrayRegion(env, array, 0, len, ((jbyte *) pages[i] + start));
+      vm_deallocate(mach_task_self(), pages[i], vm_page_size);
+    }
+
+    remaining -= len;
+  }
+
+  free (pages);
+  free (mapped);
+  return array;
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_macosx_MacOSXDebuggerLocal
+ * Method:    getThreadIntegerRegisterSet0
+ * Signature: (I)[J
+ */
+JNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0(JNIEnv *env, jobject this_obj, jint lwp_id) {
+  if (debug)
+    printf("getThreadRegisterSet0 called\n");
+
+  kern_return_t result;
+  thread_t tid;
+  mach_msg_type_number_t count = HSDB_THREAD_STATE_COUNT;
+  hsdb_thread_state_t state;
+  unsigned int *r;
+  int i;
+  jlongArray registerArray;
+  jlong *primitiveArray;
+
+  tid = lwp_id;
+
+  result = thread_get_state(tid, HSDB_THREAD_STATE, (thread_state_t)&state, &count);
+
+  if (result != KERN_SUCCESS) {
+    if (debug)
+      printf("getregs: thread_get_state(%d) failed (%d)\n", tid, result);
+    return NULL;
+  }
+
+  // 40 32-bit registers on ppc, 16 on x86. 
+  // Output order is the same as the order in the ppc_thread_state/i386_thread_state struct.
+#if defined(__i386__)
+	r = (unsigned int *)&state;
+	registerArray = (*env)->NewLongArray(env, 8);
+	primitiveArray = (*env)->GetLongArrayElements(env, registerArray, NULL);
+	primitiveArray[0] = r[0];  // eax
+	primitiveArray[1] = r[2];  // ecx
+	primitiveArray[2] = r[3];  // edx
+	primitiveArray[3] = r[1];  // ebx
+	primitiveArray[4] = r[7];  // esp
+	primitiveArray[5] = r[6];  // ebp
+	primitiveArray[6] = r[5];  // esi
+	primitiveArray[7] = r[4];  // edi
+	(*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);
+#elif defined(__x86_64__)
+	/* From AMD64ThreadContext.java
+	   public static final int R15 = 0;
+	   public static final int R14 = 1;
+	   public static final int R13 = 2;
+	   public static final int R12 = 3;
+	   public static final int R11 = 4;
+	   public static final int R10 = 5;
+	   public static final int R9  = 6;
+	   public static final int R8  = 7;
+	   public static final int RDI = 8;
+	   public static final int RSI = 9;
+	   public static final int RBP = 10;
+	   public static final int RBX = 11;
+	   public static final int RDX = 12;
+	   public static final int RCX = 13;
+	   public static final int RAX = 14;
+	   public static final int TRAPNO = 15;
+	   public static final int ERR = 16;
+	   public static final int RIP = 17;
+	   public static final int CS = 18;
+	   public static final int RFL = 19;
+	   public static final int RSP = 20;
+	   public static final int SS = 21;
+	   public static final int FS = 22;
+	   public static final int GS = 23;
+	   public static final int ES = 24;
+	   public static final int DS = 25;
+	   public static final int FSBASE = 26;
+	   public static final int GSBASE = 27;
+	 */
+	// 64 bit
+	if (debug) printf("Getting threads for a 64-bit process\n");
+	registerArray = (*env)->NewLongArray(env, 28);
+	primitiveArray = (*env)->GetLongArrayElements(env, registerArray, NULL);
+
+	primitiveArray[0] = state.__r15;
+	primitiveArray[1] = state.__r14;
+	primitiveArray[2] = state.__r13;
+	primitiveArray[3] = state.__r12;
+	primitiveArray[4] = state.__r11;
+	primitiveArray[5] = state.__r10;
+	primitiveArray[6] = state.__r9;
+	primitiveArray[7] = state.__r8;
+	primitiveArray[8] = state.__rdi;
+	primitiveArray[9] = state.__rsi;
+	primitiveArray[10] = state.__rbp;
+	primitiveArray[11] = state.__rbx;
+	primitiveArray[12] = state.__rdx;
+	primitiveArray[13] = state.__rcx;
+	primitiveArray[14] = state.__rax;
+	primitiveArray[15] = 0;             // trapno ?
+	primitiveArray[16] = 0;             // err ?
+	primitiveArray[17] = state.__rip;
+	primitiveArray[18] = state.__cs;
+	primitiveArray[19] = state.__rflags;
+	primitiveArray[20] = state.__rsp;
+	primitiveArray[21] = 0;            // We don't have SS
+	primitiveArray[22] = state.__fs;
+	primitiveArray[23] = state.__gs;
+	primitiveArray[24] = 0;
+	primitiveArray[25] = 0;
+	primitiveArray[26] = 0;
+	primitiveArray[27] = 0;
+
+	if (debug) printf("set registers\n");
+
+	(*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);
+#else
+#error Unsupported architecture
+#endif
+
+  return registerArray;
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_macosx_MacOSXDebuggerLocal
+ * Method:    translateTID0
+ * Signature: (I)I
+ */
+JNIEXPORT jint JNICALL
+Java_sun_jvm_hotspot_debugger_macosx_MacOSXDebuggerLocal_translateTID0(JNIEnv *env, jobject this_obj, jint tid) {
+  if (debug)
+    printf("translateTID0 called on tid = 0x%x\n", (int)tid);
+
+  kern_return_t result;
+  thread_t foreign_tid, usable_tid;
+  mach_msg_type_name_t type;
+    
+  foreign_tid = tid;
+    
+  task_t gTask = getTask(env, this_obj);
+  result = mach_port_extract_right(gTask, foreign_tid, 
+				   MACH_MSG_TYPE_COPY_SEND, 
+				   &usable_tid, &type);
+  if (result != KERN_SUCCESS)
+    return -1;
+    
+  if (debug)
+    printf("translateTID0: 0x%x -> 0x%x\n", foreign_tid, usable_tid);
+    
+  return (jint) usable_tid;
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    attach0
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__I(JNIEnv *env, jobject this_obj, jint jpid) {
+JNF_COCOA_ENTER(env);
+  if (getenv("JAVA_SAPROC_DEBUG") != NULL)
+    debug = JNI_TRUE;
+  else
+    debug = JNI_FALSE;
+  if (debug) printf("attach0 called for jpid=%d\n", (int)jpid);
+
+  kern_return_t result;
+  task_t gTask = 0;
+  result = task_for_pid(mach_task_self(), jpid, &gTask);
+  if (result != KERN_SUCCESS) {
+    fprintf(stderr, "attach: task_for_pid(%d) failed (%d)\n", (int)jpid, result);
+    THROW_NEW_DEBUGGER_EXCEPTION("Can't attach to the process");
+  }
+  putTask(env, this_obj, gTask);
+
+  id symbolicator = nil;
+  id jrsSymbolicator = objc_lookUpClass("JRSSymbolicator");
+  if (jrsSymbolicator != nil) {
+    id (*dynamicCall)(id, SEL, pid_t) = (id (*)(id, SEL, pid_t))&objc_msgSend;
+    symbolicator = dynamicCall(jrsSymbolicator, @selector(symbolicatorForPid:), (pid_t)jpid);
+  }
+  if (symbolicator != nil) {
+    CFRetain(symbolicator); // pin symbolicator while in java heap
+  }
+
+  putSymbolicator(env, this_obj, symbolicator);
+  if (symbolicator == nil) {
+    THROW_NEW_DEBUGGER_EXCEPTION("Can't attach symbolicator to the process");
+  }
+
+JNF_COCOA_EXIT(env);
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    detach0
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_detach0(JNIEnv *env, jobject this_obj) {
+JNF_COCOA_ENTER(env);
+  if (debug) printf("detach0 called\n");
+
+  task_t gTask = getTask(env, this_obj);
+  mach_port_deallocate(mach_task_self(), gTask);
+  id symbolicator = getSymbolicator(env, this_obj);
+  if (symbolicator != nil) {
+    CFRelease(symbolicator);
+  }
+JNF_COCOA_EXIT(env);
+}
diff -Nru openjdk.orig/hotspot/agent/src/os/bsd/Makefile openjdk/hotspot/agent/src/os/bsd/Makefile
--- openjdk.orig/hotspot/agent/src/os/bsd/Makefile	2012-07-25 15:14:34.402184943 +0100
+++ openjdk/hotspot/agent/src/os/bsd/Makefile	2012-07-25 15:27:37.275648905 +0100
@@ -32,7 +32,6 @@
 	libproc_impl.c  \
 	ps_proc.c       \
 	ps_core.c       \
-	hsearch_r.c     \
 	BsdDebuggerLocal.c
 
 INCLUDES = -I${JAVA_HOME}/include -I${JAVA_HOME}/include/$(shell uname -s | tr "[:upper:]" "[:lower:]")
diff -Nru openjdk.orig/hotspot/agent/src/os/bsd/symtab.c openjdk/hotspot/agent/src/os/bsd/symtab.c
--- openjdk.orig/hotspot/agent/src/os/bsd/symtab.c	2012-07-25 15:14:34.406185013 +0100
+++ openjdk/hotspot/agent/src/os/bsd/symtab.c	2012-07-25 15:27:37.275648905 +0100
@@ -116,7 +116,7 @@
 
     if (shdr->sh_type == symsection) {
       ELF_SYM  *syms;
-      int j, n, rslt;
+      int j, n;
       size_t size;
 
       // FIXME: there could be multiple data buffers associated with the
@@ -138,6 +138,8 @@
       // manipulate the hash table.
       symtab->hash_table = dbopen(NULL, O_CREAT | O_RDWR, 0600, DB_HASH, NULL);
       // guarantee(symtab->hash_table, "unexpected failure: dbopen");
+      if (symtab->hash_table == NULL)
+        goto bad;
 
       // shdr->sh_link points to the section that contains the actual strings
       // for symbol names. the st_name field in ELF_SYM is just the
@@ -145,11 +147,15 @@
       // strings will not be destroyed by elf_end.
       size = scn_cache[shdr->sh_link].c_shdr->sh_size;
       symtab->strs = malloc(size);
+      if (symtab->strs == NULL)
+        goto bad;
       memcpy(symtab->strs, scn_cache[shdr->sh_link].c_data, size);
 
       // allocate memory for storing symbol offset and size;
       symtab->num_symbols = n;
       symtab->symbols = calloc(n , sizeof(*symtab->symbols));
+      if (symtab->symbols == NULL)
+        goto bad;
 
       // copy symbols info our symtab and enter them info the hash table
       for (j = 0; j < n; j++, syms++) {
@@ -175,6 +181,11 @@
       }
     }
   }
+  goto quit;
+
+bad:
+  destroy_symtab(symtab);
+  symtab = NULL;
 
 quit:
   if (shbuf) free(shbuf);
@@ -195,7 +206,7 @@
   if (symtab->strs) free(symtab->strs);
   if (symtab->symbols) free(symtab->symbols);
   if (symtab->hash_table) {
-    symtab->hash_table->close(symtab->hash_table);
+    (*symtab->hash_table->close)(symtab->hash_table);
   }
   free(symtab);
 }
@@ -219,7 +230,6 @@
     return rslt;
   }
 
-quit:
   return 0;
 }
 
@@ -228,12 +238,12 @@
   int n = 0;
   if (!symtab) return NULL;
   for (; n < symtab->num_symbols; n++) {
-     struct elf_symbol* sym = &(symtab->symbols[n]);
-     if (sym->name != NULL &&
-         offset >= sym->offset && offset < sym->offset + sym->size) {
-        if (poffset) *poffset = (offset - sym->offset);
-        return sym->name;
-     }
+    struct elf_symbol* sym = &(symtab->symbols[n]);
+    if (sym->name != NULL &&
+      offset >= sym->offset && offset < sym->offset + sym->size) {
+      if (poffset) *poffset = (offset - sym->offset);
+      return sym->name;
+    }
   }
   return NULL;
 }
diff -Nru openjdk.orig/hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdDebuggerLocal.java openjdk/hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdDebuggerLocal.java
--- openjdk.orig/hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdDebuggerLocal.java	2012-07-25 15:14:34.414185152 +0100
+++ openjdk/hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdDebuggerLocal.java	2012-07-25 15:27:37.275648905 +0100
@@ -52,6 +52,8 @@
     private boolean useGCC32ABI;
     private boolean attached;
     private long    p_ps_prochandle; // native debugger handle
+    private long    symbolicator; // macosx symbolicator handle
+    private long    task; // macosx task handle
     private boolean isCore;
 
     // CDebugger support
diff -Nru openjdk.orig/hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java openjdk/hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java
--- openjdk.orig/hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java	2012-07-25 15:14:34.426185359 +0100
+++ openjdk/hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java	2012-07-25 15:27:37.275648905 +0100
@@ -43,7 +43,7 @@
       return "bsd";
     } else if (os.equals("OpenBSD")) {
       return "bsd";
-    } else if (os.equals("Darwin")) {
+    } else if (os.equals("Darwin") || os.startsWith("Mac OS X")) {
       return "bsd";
     } else if (os.startsWith("Windows")) {
       return "win32";
diff -Nru openjdk.orig/hotspot/.hgignore openjdk/hotspot/.hgignore
--- openjdk.orig/hotspot/.hgignore	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/.hgignore	2012-07-25 15:27:37.247648426 +0100
@@ -6,3 +6,4 @@
 ^src/share/tools/IdealGraphVisualizer/build/
 ^src/share/tools/IdealGraphVisualizer/dist/
 ^.hgtip
+.DS_Store
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/adlc.make openjdk/hotspot/make/bsd/makefiles/adlc.make
--- openjdk.orig/hotspot/make/bsd/makefiles/adlc.make	2012-07-25 15:14:34.430185427 +0100
+++ openjdk/hotspot/make/bsd/makefiles/adlc.make	2012-07-25 15:27:37.275648905 +0100
@@ -61,7 +61,9 @@
 
 # CFLAGS_WARN holds compiler options to suppress/enable warnings.
 # Compiler warnings are treated as errors
-CFLAGS_WARN = -Werror
+ifneq ($(COMPILER_WARNINGS_FATAL),false)
+  CFLAGS_WARN = -Werror
+endif
 CFLAGS += $(CFLAGS_WARN)
 
 OBJECTNAMES = \
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/buildtree.make openjdk/hotspot/make/bsd/makefiles/buildtree.make
--- openjdk.orig/hotspot/make/bsd/makefiles/buildtree.make	2012-07-25 15:14:34.434185497 +0100
+++ openjdk/hotspot/make/bsd/makefiles/buildtree.make	2012-07-25 15:27:37.275648905 +0100
@@ -114,10 +114,12 @@
 # Get things from the platform file.
 COMPILER	= $(shell sed -n 's/^compiler[ 	]*=[ 	]*//p' $(PLATFORM_FILE))
 
+# dtracefiles is used on BSD versions that implement Dtrace (like MacOS X)
 SIMPLE_DIRS	= \
 	$(PLATFORM_DIR)/generated/dependencies \
 	$(PLATFORM_DIR)/generated/adfiles \
-	$(PLATFORM_DIR)/generated/jvmtifiles
+	$(PLATFORM_DIR)/generated/jvmtifiles \
+	$(PLATFORM_DIR)/generated/dtracefiles
 
 TARGETS      = debug fastdebug jvmg optimized product profiled
 SUBMAKE_DIRS = $(addprefix $(PLATFORM_DIR)/,$(TARGETS))
@@ -125,7 +127,9 @@
 # For dependencies and recursive makes.
 BUILDTREE_MAKE	= $(GAMMADIR)/make/$(OS_FAMILY)/makefiles/buildtree.make
 
-BUILDTREE_TARGETS = Makefile flags.make flags_vm.make vm.make adlc.make jvmti.make sa.make \
+# dtrace.make is used on BSD versions that implement Dtrace (like MacOS X)
+BUILDTREE_TARGETS = Makefile flags.make flags_vm.make vm.make adlc.make \
+	jvmti.make sa.make dtrace.make \
         env.sh env.csh jdkpath.sh .dbxrc test_gamma
 
 BUILDTREE_VARS	= GAMMADIR=$(GAMMADIR) OS_FAMILY=$(OS_FAMILY) \
@@ -155,6 +159,13 @@
   endif
 endif
 
+# MACOSX FIXME: we should be able to run test_gamma (see MACOSX_PORT-214)
+ifdef ALWAYS_PASS_TEST_GAMMA
+  TEST_GAMMA_STATUS= echo 'exit 0';
+else
+  TEST_GAMMA_STATUS=
+endif
+
 BUILDTREE_VARS += HOTSPOT_RELEASE_VERSION=$(HS_BUILD_VER) HOTSPOT_BUILD_VERSION=  JRE_RELEASE_VERSION=$(JRE_RELEASE_VERSION)
 
 BUILDTREE	= \
@@ -314,6 +325,16 @@
 	echo "include \$$(GAMMADIR)/make/$(OS_FAMILY)/makefiles/$(@F)"; \
 	) > $@
 
+dtrace.make: $(BUILDTREE_MAKE)
+	@echo Creating $@ ...
+	$(QUIETLY) ( \
+	$(BUILDTREE_COMMENT); \
+	echo; \
+	echo include flags.make; \
+	echo; \
+	echo "include \$$(GAMMADIR)/make/$(OS_FAMILY)/makefiles/$(@F)"; \
+	) > $@
+
 env.sh: $(BUILDTREE_MAKE)
 	@echo Creating $@ ...
 	$(QUIETLY) ( \
@@ -390,7 +411,6 @@
 	echo '#!/bin/sh'; \
 	$(BUILDTREE_COMMENT); \
 	echo '. ./env.sh'; \
-	echo "exit 0;"; \
 	echo "if [ \"$(CROSS_COMPILE_ARCH)\" != \"\" ]; then { $(CROSS_COMPILING_MSG); exit 0; }; fi"; \
 	echo "if [ -z \$$JAVA_HOME ]; then { $(NO_JAVA_HOME_MSG); exit 0; }; fi"; \
 	echo "if ! \$${JAVA_HOME}/bin/java $(JAVA_FLAG) -fullversion 2>&1 > /dev/null"; \
@@ -401,6 +421,7 @@
 	echo "\$${JAVA_HOME}/bin/javac -d . $(GAMMADIR)/make/test/Queens.java"; \
 	echo '[ -f gamma_g ] && { gamma=gamma_g; }'; \
 	echo './$${gamma:-gamma} $(TESTFLAGS) Queens < /dev/null'; \
+	$(TEST_GAMMA_STATUS) \
 	) > $@
 	$(QUIETLY) chmod +x $@
 
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/defs.make openjdk/hotspot/make/bsd/makefiles/defs.make
--- openjdk.orig/hotspot/make/bsd/makefiles/defs.make	2012-07-25 15:14:34.438185567 +0100
+++ openjdk/hotspot/make/bsd/makefiles/defs.make	2012-07-25 15:27:37.275648905 +0100
@@ -162,9 +162,19 @@
                         $(EXPORT_LIB_DIR)/sa-jdi.jar
 ADD_SA_BINARIES/sparc = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
                         $(EXPORT_LIB_DIR)/sa-jdi.jar
+ADD_SA_BINARIES/universal = $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX) \
+                            $(EXPORT_LIB_DIR)/sa-jdi.jar
 ADD_SA_BINARIES/ppc   =
 ADD_SA_BINARIES/ia64  =
 ADD_SA_BINARIES/arm   =
 ADD_SA_BINARIES/zero  =
 
 EXPORT_LIST += $(ADD_SA_BINARIES/$(HS_ARCH))
+
+UNIVERSAL_LIPO_LIST += $(EXPORT_JRE_LIB_DIR)/libjsig.$(LIBRARY_SUFFIX)
+UNIVERSAL_LIPO_LIST += $(EXPORT_JRE_LIB_DIR)/libsaproc.$(LIBRARY_SUFFIX)
+UNIVERSAL_LIPO_LIST += $(EXPORT_JRE_LIB_DIR)/server/libjvm.$(LIBRARY_SUFFIX)
+
+UNIVERSAL_COPY_LIST += $(EXPORT_JRE_LIB_DIR)/server/Xusage.txt
+UNIVERSAL_COPY_LIST += $(EXPORT_JRE_LIB_DIR)/client/Xusage.txt
+UNIVERSAL_COPY_LIST += $(EXPORT_JRE_LIB_DIR)/client/libjvm.$(LIBRARY_SUFFIX)
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/dtrace.make openjdk/hotspot/make/bsd/makefiles/dtrace.make
--- openjdk.orig/hotspot/make/bsd/makefiles/dtrace.make	2012-07-25 15:14:34.438185567 +0100
+++ openjdk/hotspot/make/bsd/makefiles/dtrace.make	2012-07-25 15:27:37.275648905 +0100
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,6 +22,282 @@
 #  
 #
 
-# Bsd does not build jvm_db
-LIBJVM_DB =
+# Rules to build jvm_db/dtrace, used by vm.make
 
+# We build libjvm_dtrace/libjvm_db/dtrace for COMPILER1 and COMPILER2
+# but not for CORE or KERNEL configurations.
+
+ifneq ("${TYPE}", "CORE")
+ifneq ("${TYPE}", "KERNEL")
+
+ifeq ($(OS_VENDOR), Darwin)
+# we build dtrace for macosx using USDT2 probes
+
+DtraceOutDir = $(GENERATED)/dtracefiles
+
+# Bsd does not build libjvm_db, does not compile on macosx
+# disabled in build: rule in vm.make
+JVM_DB = libjvm_db
+#LIBJVM_DB = libjvm_db.dylib
+LIBJVM_DB = libjvm$(G_SUFFIX)_db.dylib
+
+JVM_DTRACE = jvm_dtrace
+#LIBJVM_DTRACE = libjvm_dtrace.dylib
+LIBJVM_DTRACE = libjvm$(G_SUFFIX)_dtrace.dylib
+
+JVMOFFS = JvmOffsets
+JVMOFFS.o = $(JVMOFFS).o
+GENOFFS = generate$(JVMOFFS)
+
+DTRACE_SRCDIR = $(GAMMADIR)/src/os/$(Platform_os_family)/dtrace
+DTRACE = dtrace
+DTRACE.o = $(DTRACE).o
+
+# to remove '-g' option which causes link problems
+# also '-z nodefs' is used as workaround
+GENOFFS_CFLAGS = $(shell echo $(CFLAGS) | sed -e 's/ -g / /g' -e 's/ -g0 / /g';)
+
+ifdef LP64
+DTRACE_OPTS = -D_LP64
+endif
+
+# making libjvm_db
+
+# Use mapfile with libjvm_db.so
+LIBJVM_DB_MAPFILE = # no mapfile for usdt2 # $(MAKEFILES_DIR)/mapfile-vers-jvm_db
+#LFLAGS_JVM_DB += $(MAPFLAG:FILENAME=$(LIBJVM_DB_MAPFILE))
+
+# Use mapfile with libjvm_dtrace.so
+LIBJVM_DTRACE_MAPFILE = # no mapfile for usdt2 # $(MAKEFILES_DIR)/mapfile-vers-jvm_dtrace
+#LFLAGS_JVM_DTRACE += $(MAPFLAG:FILENAME=$(LIBJVM_DTRACE_MAPFILE))
+
+LFLAGS_JVM_DB += $(PICFLAG) # -D_REENTRANT
+LFLAGS_JVM_DTRACE += $(PICFLAG) # -D_REENTRANT
+
+ISA = $(subst i386,i486,$(BUILDARCH))
+
+# Making 64/libjvm_db.so: 64-bit version of libjvm_db.so which handles 32-bit libjvm.so
+ifneq ("${ISA}","${BUILDARCH}")
+
+XLIBJVM_DB = 64/$(LIBJVM_DB)
+XLIBJVM_DB_G = 64/$(LIBJVM_DB_G)
+XLIBJVM_DTRACE = 64/$(LIBJVM_DTRACE)
+XLIBJVM_DTRACE_G = 64/$(LIBJVM_DTRACE_G)
+XARCH = $(subst sparcv9,v9,$(shell echo $(ISA)))
+
+$(XLIBJVM_DB): $(DTRACE_SRCDIR)/$(JVM_DB).c $(JVMOFFS).h $(LIBJVM_DB_MAPFILE)
+	@echo Making $@
+	$(QUIETLY) mkdir -p 64/ ; \
+	$(CC) $(SYMFLAG) -xarch=$(XARCH) -D$(TYPE) -I. -I$(GENERATED) \
+		$(SHARED_FLAG) $(LFLAGS_JVM_DB) -o $@ $(DTRACE_SRCDIR)/$(JVM_DB).c #-lc
+#	[ -f $(XLIBJVM_DB_G) ] || { ln -s $(LIBJVM_DB) $(XLIBJVM_DB_G); }
+
+$(XLIBJVM_DTRACE): $(DTRACE_SRCDIR)/$(JVM_DTRACE).c $(DTRACE_SRCDIR)/$(JVM_DTRACE).h $(LIBJVM_DTRACE_MAPFILE)
+	@echo Making $@
+	$(QUIETLY) mkdir -p 64/ ; \
+	$(CC) $(SYMFLAG) -xarch=$(XARCH) -D$(TYPE) -I. \
+		$(SHARED_FLAG) $(LFLAGS_JVM_DTRACE) -o $@ $(DTRACE_SRCDIR)/$(JVM_DTRACE).c #-lc -lthread -ldoor
+#	[ -f $(XLIBJVM_DTRACE_G) ] || { ln -s $(LIBJVM_DTRACE) $(XLIBJVM_DTRACE_G); }
+
+endif # ifneq ("${ISA}","${BUILDARCH}")
+
+LFLAGS_GENOFFS += -L.
+
+lib$(GENOFFS).dylib: $(DTRACE_SRCDIR)/$(GENOFFS).cpp $(DTRACE_SRCDIR)/$(GENOFFS).h \
+                  $(LIBJVM.o)
+	$(QUIETLY) $(CCC) $(CPPFLAGS) $(GENOFFS_CFLAGS) $(SHARED_FLAG) $(PICFLAG) \
+		 $(LFLAGS_GENOFFS) -o $@ $(DTRACE_SRCDIR)/$(GENOFFS).cpp -ljvm
+
+$(GENOFFS): $(DTRACE_SRCDIR)/$(GENOFFS)Main.c lib$(GENOFFS).dylib
+	$(QUIETLY) $(LINK.CC) -o $@ $(DTRACE_SRCDIR)/$(GENOFFS)Main.c \
+		./lib$(GENOFFS).dylib
+
+# $@.tmp is created first to avoid an empty $(JVMOFFS).h if an error occurs.
+$(JVMOFFS).h: $(GENOFFS)
+	$(QUIETLY) DYLD_LIBRARY_PATH=. ./$(GENOFFS) -header > $@.tmp; touch $@; \
+	if [ `diff $@.tmp $@ > /dev/null 2>&1; echo $$?` -ne 0 ] ; \
+	then rm -f $@; mv $@.tmp $@; \
+	else rm -f $@.tmp; \
+	fi
+
+$(JVMOFFS)Index.h: $(GENOFFS)
+	$(QUIETLY) DYLD_LIBRARY_PATH=. ./$(GENOFFS) -index > $@.tmp; touch $@; \
+	if [ `diff $@.tmp $@ > /dev/null 2>&1; echo $$?` -ne 0 ] ; \
+	then rm -f $@; mv $@.tmp $@; \
+	else rm -f $@.tmp; \
+	fi
+
+$(JVMOFFS).cpp: $(GENOFFS) $(JVMOFFS).h $(JVMOFFS)Index.h
+	$(QUIETLY) DYLD_LIBRARY_PATH=. ./$(GENOFFS) -table > $@.tmp; touch $@; \
+	if [ `diff $@.tmp $@ > /dev/null 2>&1; echo $$?` -ne 0 ] ; \
+	then rm -f $@; mv $@.tmp $@; \
+	else rm -f $@.tmp; \
+	fi
+
+$(JVMOFFS.o): $(JVMOFFS).h $(JVMOFFS).cpp 
+	$(QUIETLY) $(CCC) -c -I. -o $@ $(ARCHFLAG) -D$(TYPE) $(JVMOFFS).cpp
+
+$(LIBJVM_DB): $(DTRACE_SRCDIR)/$(JVM_DB).c $(JVMOFFS.o) $(XLIBJVM_DB) $(LIBJVM_DB_MAPFILE)
+	@echo Making $@
+	$(QUIETLY) $(CC) $(SYMFLAG) $(ARCHFLAG) -D$(TYPE) -I. -I$(GENERATED) \
+		$(SHARED_FLAG) $(LFLAGS_JVM_DB) -o $@ $(DTRACE_SRCDIR)/$(JVM_DB).c -Wall # -lc
+#	[ -f $(LIBJVM_DB_G) ] || { ln -s $@ $(LIBJVM_DB_G); }
+
+$(LIBJVM_DTRACE): $(DTRACE_SRCDIR)/$(JVM_DTRACE).c $(XLIBJVM_DTRACE) $(DTRACE_SRCDIR)/$(JVM_DTRACE).h $(LIBJVM_DTRACE_MAPFILE)
+	@echo Making $@
+	$(QUIETLY) $(CC) $(SYMFLAG) $(ARCHFLAG) -D$(TYPE) -I.  \
+		$(SHARED_FLAG) $(LFLAGS_JVM_DTRACE) -o $@ $(DTRACE_SRCDIR)/$(JVM_DTRACE).c #-lc -lthread -ldoor
+#	[ -f $(LIBJVM_DTRACE_G) ] || { ln -s $@ $(LIBJVM_DTRACE_G); }
+
+#$(DTRACE).d: $(DTRACE_SRCDIR)/hotspot.d $(DTRACE_SRCDIR)/hotspot_jni.d \
+#             $(DTRACE_SRCDIR)/hs_private.d $(DTRACE_SRCDIR)/jhelper.d
+#	$(QUIETLY) cat $^ > $@
+
+$(DtraceOutDir):
+	mkdir $(DtraceOutDir)
+
+$(DtraceOutDir)/hotspot.h: $(DTRACE_SRCDIR)/hotspot.d | $(DtraceOutDir)
+	$(QUIETLY) $(DTRACE_PROG) $(DTRACE_OPTS) -C -I. -h -o $@ -s $(DTRACE_SRCDIR)/hotspot.d
+
+$(DtraceOutDir)/hotspot_jni.h: $(DTRACE_SRCDIR)/hotspot_jni.d | $(DtraceOutDir)
+	$(QUIETLY) $(DTRACE_PROG) $(DTRACE_OPTS) -C -I. -h -o $@ -s $(DTRACE_SRCDIR)/hotspot_jni.d
+
+$(DtraceOutDir)/hs_private.h: $(DTRACE_SRCDIR)/hs_private.d | $(DtraceOutDir)
+	$(QUIETLY) $(DTRACE_PROG) $(DTRACE_OPTS) -C -I. -h -o $@ -s $(DTRACE_SRCDIR)/hs_private.d
+
+$(DtraceOutDir)/jhelper.h: $(DTRACE_SRCDIR)/jhelper.d $(JVMOFFS).o | $(DtraceOutDir)
+	$(QUIETLY) $(DTRACE_PROG) $(DTRACE_OPTS) -C -I. -h -o $@ -s $(DTRACE_SRCDIR)/jhelper.d
+
+# jhelper currently disabled
+dtrace_gen_headers: $(DtraceOutDir)/hotspot.h $(DtraceOutDir)/hotspot_jni.h $(DtraceOutDir)/hs_private.h 
+
+DTraced_Files = ciEnv.o \
+                classLoadingService.o \
+                compileBroker.o \
+                hashtable.o \
+                instanceKlass.o \
+                java.o \
+                jni.o \
+                jvm.o \
+                memoryManager.o \
+                nmethod.o \
+                objectMonitor.o \
+                runtimeService.o \
+                sharedRuntime.o \
+                synchronizer.o \
+                thread.o \
+                unsafe.o \
+                vmThread.o \
+                vmCMSOperations.o \
+                vmPSOperations.o \
+                vmGCOperations.o \
+
+# Dtrace is available, so we build $(DTRACE.o)  
+#$(DTRACE.o): $(DTRACE).d $(JVMOFFS).h $(JVMOFFS)Index.h $(DTraced_Files)
+#	@echo Compiling $(DTRACE).d
+
+#	$(QUIETLY) $(DTRACE_PROG) $(DTRACE_OPTS) -C -I. -G -xlazyload -o $@ -s $(DTRACE).d \
+#     $(DTraced_Files) ||\
+#  STATUS=$$?;\
+#	if [ x"$$STATUS" = x"1" -a \
+#       x`uname -r` = x"5.10" -a \
+#       x`uname -p` = x"sparc" ]; then\
+#    echo "*****************************************************************";\
+#    echo "* If you are building server compiler, and the error message is ";\
+#    echo "* \"incorrect ELF machine type...\", you have run into solaris bug ";\
+#    echo "* 6213962, \"dtrace -G doesn't work on sparcv8+ object files\".";\
+#    echo "* Either patch/upgrade your system (>= S10u1_15), or set the ";\
+#    echo "* environment variable HOTSPOT_DISABLE_DTRACE_PROBES to disable ";\
+#    echo "* dtrace probes for this build.";\
+#    echo "*****************************************************************";\
+#  fi;\
+#  exit $$STATUS
+  # Since some DTraced_Files are in LIBJVM.o and they are touched by this
+  # command, and libgenerateJvmOffsets.so depends on LIBJVM.o, 'make' will
+  # think it needs to rebuild libgenerateJvmOffsets.so and thus JvmOffsets*
+  # files, but it doesn't, so we touch the necessary files to prevent later
+  # recompilation. Note: we only touch the necessary files if they already
+  # exist in order to close a race where an empty file can be created
+  # before the real build rule is executed.
+  # But, we can't touch the *.h files:  This rule depends
+  # on them, and that would cause an infinite cycle of rebuilding.
+  # Neither the *.h or *.ccp files need to be touched, since they have
+  # rules which do not update them when the generator file has not
+  # changed their contents.
+#	$(QUIETLY) if [ -f lib$(GENOFFS).so ]; then touch lib$(GENOFFS).so; fi
+#	$(QUIETLY) if [ -f $(GENOFFS) ]; then touch $(GENOFFS); fi
+#	$(QUIETLY) if [ -f $(JVMOFFS.o) ]; then touch $(JVMOFFS.o); fi
+
+.PHONY: dtraceCheck
+
+#SYSTEM_DTRACE_H = /usr/include/dtrace.h
+SYSTEM_DTRACE_PROG = /usr/sbin/dtrace
+#PATCH_DTRACE_PROG = /opt/SUNWdtrd/sbin/dtrace
+systemDtraceFound := $(wildcard ${SYSTEM_DTRACE_PROG})
+#patchDtraceFound := $(wildcard ${PATCH_DTRACE_PROG})
+#systemDtraceHdrFound := $(wildcard $(SYSTEM_DTRACE_H))
+
+#ifneq ("$(systemDtraceHdrFound)", "") 
+#CFLAGS += -DHAVE_DTRACE_H
+#endif
+
+#ifneq ("$(patchDtraceFound)", "")
+#DTRACE_PROG=$(PATCH_DTRACE_PROG)
+#DTRACE_INCL=-I/opt/SUNWdtrd/include
+#else
+ifneq ("$(systemDtraceFound)", "")
+DTRACE_PROG=$(SYSTEM_DTRACE_PROG)
+else
+
+endif # ifneq ("$(systemDtraceFound)", "")
+#endif # ifneq ("$(patchDtraceFound)", "")
+
+ifneq ("${DTRACE_PROG}", "")
+ifeq ("${HOTSPOT_DISABLE_DTRACE_PROBES}", "")
+
+DTRACE_OBJS = $(DTRACE.o) #$(JVMOFFS.o)
+CFLAGS += -DDTRACE_ENABLED #$(DTRACE_INCL)
+#clangCFLAGS += -DDTRACE_ENABLED -fno-optimize-sibling-calls
+#MAPFILE_DTRACE_OPT = $(MAPFILE_DTRACE)
+
+
+dtraceCheck:
+
+dtrace_stuff: dtrace_gen_headers
+	$(QUIETLY) echo "dtrace headers generated"
+
+
+else # manually disabled
+
+dtraceCheck:
+	$(QUIETLY) echo "**NOTICE** Dtrace support disabled via environment variable"
+
+dtrace_stuff:
+
+endif # ifeq ("${HOTSPOT_DISABLE_DTRACE_PROBES}", "")
+
+else # No dtrace program found
+
+dtraceCheck:
+	$(QUIETLY) echo "**NOTICE** Dtrace support disabled: not supported by system"
+
+dtrace_stuff:
+
+endif # ifneq ("${dtraceFound}", "")
+
+endif # ifeq ($(OS_VENDOR), Darwin)
+
+
+else # KERNEL build
+
+dtraceCheck:
+	$(QUIETLY) echo "**NOTICE** Dtrace support disabled for KERNEL builds"
+
+endif # ifneq ("${TYPE}", "KERNEL")
+
+else # CORE build
+
+dtraceCheck:
+	$(QUIETLY) echo "**NOTICE** Dtrace support disabled for CORE builds"
+
+endif # ifneq ("${TYPE}", "CORE")
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/gcc.make openjdk/hotspot/make/bsd/makefiles/gcc.make
--- openjdk.orig/hotspot/make/bsd/makefiles/gcc.make	2012-07-25 15:14:34.442185636 +0100
+++ openjdk/hotspot/make/bsd/makefiles/gcc.make	2012-07-25 15:27:37.275648905 +0100
@@ -30,17 +30,49 @@
 # When cross-compiling the ALT_COMPILER_PATH points
 # to the cross-compilation toolset
 ifdef CROSS_COMPILE_ARCH
-CXX = $(ALT_COMPILER_PATH)/g++
-CPP = $(ALT_COMPILER_PATH)/g++
-CC  = $(ALT_COMPILER_PATH)/gcc
-HOSTCPP = g++
-HOSTCC  = gcc
-else
-CXX ?= g++
-CPP = $(CXX)
-CC  ?= gcc
-HOSTCPP = $(CPP)
-HOSTCC  = $(CPP)
+ CPP = $(ALT_COMPILER_PATH)/g++
+ CC  = $(ALT_COMPILER_PATH)/gcc
+ HOSTCPP = g++
+ HOSTCC  = gcc
+else ifneq ($(OS_VENDOR), Darwin)
+ CXX = g++
+ CPP = $(CXX)
+ CC  = gcc
+ HOSTCPP = $(CPP)
+ HOSTCC  = $(CC)
+endif
+
+# i486 hotspot requires -mstackrealign on Darwin.
+# llvm-gcc supports this in Xcode 3.2.6 and 4.0.
+# gcc-4.0 supports this on earlier versions.
+# Prefer llvm-gcc where available.
+ifeq ($(OS_VENDOR), Darwin)
+  ifeq ($(origin CXX), default)
+   CXX = llvm-g++
+  endif
+  ifeq ($(origin CC), default)
+   CC  = llvm-gcc
+  endif
+  CPP  = $(CXX)
+
+  ifeq ($(ARCH), i486)
+  LLVM_SUPPORTS_STACKREALIGN := $(shell \
+   [ "0"`llvm-gcc -v 2>&1 | grep LLVM | sed -E "s/.*LLVM build ([0-9]+).*/\1/"` -gt "2333" ] \
+   && echo true || echo false)
+
+  ifeq ($(LLVM_SUPPORTS_STACKREALIGN), true)
+    CXX32 ?= llvm-g++
+    CC32  ?= llvm-gcc
+  else
+    CXX32 ?= g++-4.0
+    CC32  ?= gcc-4.0
+  endif
+  CPP = $(CXX32)
+  CC  = $(CC32)
+  endif
+
+  HOSTCPP = $(CPP)
+  HOSTCC  = $(CC)
 endif
 
 AS   = $(CC) -c -x assembler-with-cpp
@@ -130,7 +162,9 @@
 endif
 
 # Compiler warnings are treated as errors
-WARNINGS_ARE_ERRORS = -Werror
+ifneq ($(COMPILER_WARNINGS_FATAL),false)
+  WARNINGS_ARE_ERRORS = -Werror
+endif
 
 # Except for a few acceptable ones
 # Since GCC 4.3, -Wconversion has changed its meanings to warn these implicit
@@ -152,7 +186,13 @@
 
 
 # The flags to use for an Optimized g++ build
-OPT_CFLAGS += -O3
+ifeq ($(OS_VENDOR), Darwin)
+  # use -Os by default, unless -O3 can be proved to be worth the cost, as per policy
+  # <http://wikis.sun.com/display/OpenJDK/Mac+OS+X+Port+Compilers>
+  OPT_CFLAGS += -Os
+else
+  OPT_CFLAGS += -O3
+endif
 
 # Hotspot uses very unstrict aliasing turn this optimization off
 OPT_CFLAGS += -fno-strict-aliasing
@@ -212,7 +252,7 @@
   SONAMEFLAG =
 
   # Build shared library
-  SHARED_FLAG = -dynamiclib $(VM_PICFLAG)
+  SHARED_FLAG = -Wl,-install_name,@rpath/$(@F) -dynamiclib -compatibility_version 1.0.0 -current_version 1.0.0 $(VM_PICFLAG)
 
   # Keep symbols even they are not used
   #AOUT_FLAGS += -Xlinker -export-dynamic
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/sa.make openjdk/hotspot/make/bsd/makefiles/sa.make
--- openjdk.orig/hotspot/make/bsd/makefiles/sa.make	2012-07-25 15:14:34.446185705 +0100
+++ openjdk/hotspot/make/bsd/makefiles/sa.make	2012-07-25 15:27:37.275648905 +0100
@@ -38,18 +38,16 @@
 GENERATED = $(TOPDIR)/../generated
 
 # tools.jar is needed by the JDI - SA binding
-SA_CLASSPATH = $(BOOT_JAVA_HOME)/lib/tools.jar
+ifeq ($(SA_APPLE_BOOT_JAVA),true)
+  SA_CLASSPATH = $(BOOT_JAVA_HOME)/bundle/Classes/classes.jar
+else
+  SA_CLASSPATH = $(BOOT_JAVA_HOME)/lib/tools.jar
+endif
 
 # TODO: if it's a modules image, check if SA module is installed.
 MODULELIB_PATH= $(BOOT_JAVA_HOME)/lib/modules
 
-# gnumake 3.78.1 does not accept the *s that
-# are in AGENT_FILES1 and AGENT_FILES2, so use the shell to expand them
-AGENT_FILES1 := $(shell /bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES1))
-AGENT_FILES2 := $(shell /bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES2))
-
-AGENT_FILES1_LIST := $(GENERATED)/agent1.classes.list
-AGENT_FILES2_LIST := $(GENERATED)/agent2.classes.list
+AGENT_FILES_LIST := $(GENERATED)/agent.classes.list
 
 SA_CLASSDIR = $(GENERATED)/saclasses
 
@@ -68,7 +66,7 @@
 	   $(MAKE) -f sa.make $(GENERATED)/sa-jdi.jar; \
 	fi
 
-$(GENERATED)/sa-jdi.jar: $(AGENT_FILES1) $(AGENT_FILES2)
+$(GENERATED)/sa-jdi.jar: $(AGENT_FILES)
 	$(QUIETLY) echo "Making $@"
 	$(QUIETLY) if [ "$(BOOT_JAVA_HOME)" = "" ]; then \
 	  echo "ALT_BOOTDIR, BOOTDIR or JAVA_HOME needs to be defined to build SA"; \
@@ -82,7 +80,6 @@
 	$(QUIETLY) if [ ! -d $(SA_CLASSDIR) ] ; then \
 	  mkdir -p $(SA_CLASSDIR);        \
 	fi
-	
 # Note: When indented, make tries to execute the '$(shell' comment.
 # In some environments, cmd processors have limited line length.
 # To prevent the javac invocation in the next block from using
@@ -93,13 +90,12 @@
 # the initialization of the lists is also done in the same phase
 # using '$(shell rm ...' instead of using the more traditional
 # 'rm ...' rule.
-	$(shell rm -rf $(AGENT_FILES1_LIST) $(AGENT_FILES2_LIST))
-	$(foreach file,$(AGENT_FILES1),$(shell echo $(file) >> $(AGENT_FILES1_LIST)))
-	$(foreach file,$(AGENT_FILES2),$(shell echo $(file) >> $(AGENT_FILES2_LIST)))
-	
-	$(QUIETLY) $(REMOTE) $(COMPILE.JAVAC) -classpath $(SA_CLASSPATH) -sourcepath $(AGENT_SRC_DIR) -d $(SA_CLASSDIR) @$(AGENT_FILES1_LIST)
-	$(QUIETLY) $(REMOTE) $(COMPILE.JAVAC) -classpath $(SA_CLASSPATH) -sourcepath $(AGENT_SRC_DIR) -d $(SA_CLASSDIR) @$(AGENT_FILES2_LIST)
-	
+	$(shell rm -rf $(AGENT_FILES_LIST))
+# gnumake 3.78.1 does not accept the *'s that
+# are in AGENT_FILES, so use the shell to expand them.
+# Be extra carefull to not produce too long command lines in the shell!
+	$(foreach file,$(AGENT_FILES),$(shell ls -1 $(file) >> $(AGENT_FILES_LIST)))
+	$(QUIETLY) $(REMOTE) $(COMPILE.JAVAC) -classpath $(SA_CLASSPATH) -sourcepath $(AGENT_SRC_DIR) -d $(SA_CLASSDIR) @$(AGENT_FILES_LIST)
 	$(QUIETLY) $(REMOTE) $(COMPILE.RMIC)  -classpath $(SA_CLASSDIR) -d $(SA_CLASSDIR) sun.jvm.hotspot.debugger.remote.RemoteDebuggerServer
 	$(QUIETLY) echo "$(SA_BUILD_VERSION_PROP)" > $(SA_PROPERTIES)
 	$(QUIETLY) rm -f $(SA_CLASSDIR)/sun/jvm/hotspot/utilities/soql/sa.js
@@ -118,4 +114,4 @@
 clean:
 	rm -rf $(SA_CLASSDIR)
 	rm -rf $(GENERATED)/sa-jdi.jar
-	rm -rf $(AGENT_FILES1_LIST) $(AGENT_FILES2_LIST)
+	rm -rf $(AGENT_FILES_LIST)
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/saproc.make openjdk/hotspot/make/bsd/makefiles/saproc.make
--- openjdk.orig/hotspot/make/bsd/makefiles/saproc.make	2012-07-25 15:14:34.446185705 +0100
+++ openjdk/hotspot/make/bsd/makefiles/saproc.make	2012-07-25 15:27:37.275648905 +0100
@@ -40,20 +40,29 @@
 
 SASRCDIR = $(AGENT_DIR)/src/os/$(Platform_os_family)
 
-# disable building saproc until hsearch_r license issues are resolved
-#ifeq ($(OS_VENDOR), FreeBSD)
-#SASRCFILES = $(SASRCDIR)/salibelf.c                   \
-#             $(SASRCDIR)/symtab.c                     \
-#             $(SASRCDIR)/libproc_impl.c               \
-#             $(SASRCDIR)/ps_proc.c                    \
-#             $(SASRCDIR)/ps_core.c                    \
-#             $(SASRCDIR)/hsearch_r.c                  \
-#             $(SASRCDIR)/BsdDebuggerLocal.c
-#SALIBS = -lutil -lthread_db
-#else
-SASRCFILES = $(SASRCDIR)/StubDebuggerLocal.c
-SALIBS = 
-#endif
+NON_STUB_SASRCFILES = $(SASRCDIR)/salibelf.c          \
+                      $(SASRCDIR)/symtab.c            \
+                      $(SASRCDIR)/libproc_impl.c      \
+                      $(SASRCDIR)/ps_proc.c           \
+                      $(SASRCDIR)/ps_core.c           \
+                      $(SASRCDIR)/BsdDebuggerLocal.c
+
+ifeq ($(OS_VENDOR), FreeBSD)
+  SASRCFILES = $(NON_STUB_SASRCFILES)
+  SALIBS = -lutil -lthread_db
+  SAARCH = $(ARCHFLAG)
+else
+  ifeq ($(OS_VENDOR), Darwin)
+    SASRCFILES = $(SASRCDIR)/MacosxDebuggerLocal.m
+    SALIBS = -g -framework Foundation -F/System/Library/Frameworks/JavaVM.framework/Frameworks -framework JavaNativeFoundation -framework Security -framework CoreFoundation
+    #objc compiler blows up on -march=i586, perhaps it should not be included in the macosx intel 32-bit C++ compiles?
+    SAARCH = $(subst -march=i586,,$(ARCHFLAG))
+  else
+    SASRCFILES = $(SASRCDIR)/StubDebuggerLocal.c
+    SALIBS = 
+    SAARCH = $(ARCHFLAG)
+  endif
+endif
 
 SAMAPFILE = $(SASRCDIR)/mapfile
 
@@ -79,6 +88,15 @@
 endif
 SA_LFLAGS += $(LDFLAGS_HASH_STYLE)
 
+ifeq ($(OS_VENDOR), Darwin)
+  BOOT_JAVA_INCLUDES = -I$(BOOT_JAVA_HOME)/include \
+    -I$(BOOT_JAVA_HOME)/include/$(shell uname -s | tr "[:upper:]" "[:lower:]") \
+    -I/System/Library/Frameworks/JavaVM.framework/Headers
+else
+  BOOT_JAVA_INCLUDES = -I$(BOOT_JAVA_HOME)/include \
+    -I$(BOOT_JAVA_HOME)/include/$(shell uname -s | tr "[:upper:]" "[:lower:]")
+endif
+
 $(LIBSAPROC): $(SASRCFILES) $(SAMAPFILE)
 	$(QUIETLY) if [ "$(BOOT_JAVA_HOME)" = "" ]; then \
 	  echo "ALT_BOOTDIR, BOOTDIR or JAVA_HOME needs to be defined to build SA"; \
@@ -86,11 +104,10 @@
 	fi
 	@echo Making SA debugger back-end...
 	$(QUIETLY) $(CC) -D$(BUILDARCH) -D_GNU_SOURCE                   \
-                   $(SYMFLAG) $(ARCHFLAG) $(SHARED_FLAG) $(PICFLAG)     \
+                   $(SYMFLAG) $(SAARCH) $(SHARED_FLAG) $(PICFLAG)     \
 	           -I$(SASRCDIR)                                        \
 	           -I$(GENERATED)                                       \
-	           -I$(BOOT_JAVA_HOME)/include                          \
-	           -I$(BOOT_JAVA_HOME)/include/$(shell uname -s | tr "[:upper:]" "[:lower:]") \
+	           $(BOOT_JAVA_INCLUDES)                                \
 	           $(SASRCFILES)                                        \
 	           $(SA_LFLAGS)                                         \
 	           $(SA_DEBUG_CFLAGS)                                   \
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/top.make openjdk/hotspot/make/bsd/makefiles/top.make
--- openjdk.orig/hotspot/make/bsd/makefiles/top.make	2012-07-25 15:14:34.454185843 +0100
+++ openjdk/hotspot/make/bsd/makefiles/top.make	2012-07-25 15:27:37.279648973 +0100
@@ -82,7 +82,7 @@
 	@echo All done.
 
 # This is an explicit dependency for the sake of parallel makes.
-vm_build_preliminaries:  checks $(Cached_plat) $(AD_Files_If_Required) jvmti_stuff sa_stuff
+vm_build_preliminaries:  checks $(Cached_plat) $(AD_Files_If_Required) jvmti_stuff sa_stuff dtrace_stuff
 	@# We need a null action here, so implicit rules don't get consulted.
 
 $(Cached_plat): $(Plat_File)
@@ -96,6 +96,15 @@
 jvmti_stuff: $(Cached_plat) $(adjust-mflags)
 	@$(MAKE) -f jvmti.make $(MFLAGS-adjusted)
 
+ifeq ($(OS_VENDOR), Darwin)
+# generate dtrace header files
+dtrace_stuff: $(Cached_plat) $(adjust-mflags)
+	@$(MAKE) -f dtrace.make dtrace_stuff $(MFLAGS-adjusted) GENERATED=$(GENERATED)
+else
+dtrace_stuff:
+	@# We need a null action here, so implicit rules don't get consulted.
+endif
+
 # generate SA jar files and native header
 sa_stuff:
 	@$(MAKE) -f sa.make $(MFLAGS-adjusted)
diff -Nru openjdk.orig/hotspot/make/bsd/makefiles/vm.make openjdk/hotspot/make/bsd/makefiles/vm.make
--- openjdk.orig/hotspot/make/bsd/makefiles/vm.make	2012-07-25 15:14:34.454185843 +0100
+++ openjdk/hotspot/make/bsd/makefiles/vm.make	2012-07-25 15:27:37.279648973 +0100
@@ -108,6 +108,7 @@
 
 # Don't set excutable bit on stack segment
 # the same could be done by separate execstack command
+# Darwin is non-executable-stack by default
 ifneq ($(OS_VENDOR), Darwin)
 LFLAGS += -Xlinker -z -Xlinker noexecstack
 endif
@@ -322,7 +323,16 @@
 
 #----------------------------------------------------------------------
 
+ifeq ($(OS_VENDOR), Darwin)
+$(LIBJVM).dSYM: $(LIBJVM)
+	dsymutil $(LIBJVM)
+
+# no launcher or libjvm_db for macosx
+build: $(LIBJVM) $(LIBJSIG) $(BUILDLIBSAPROC) dtraceCheck $(LIBJVM).dSYM
+	echo "Doing vm.make build:"
+else
 build: $(LIBJVM) $(LAUNCHER) $(LIBJSIG) $(LIBJVM_DB) $(BUILDLIBSAPROC)
+endif
 
 install: install_jvm install_jsig install_saproc
 
diff -Nru openjdk.orig/hotspot/make/defs.make openjdk/hotspot/make/defs.make
--- openjdk.orig/hotspot/make/defs.make	2012-07-25 15:14:34.458185911 +0100
+++ openjdk/hotspot/make/defs.make	2012-07-25 15:27:37.279648973 +0100
@@ -281,6 +281,13 @@
 EXPORT_JRE_LIB_DIR = $(EXPORT_JRE_DIR)/lib
 EXPORT_JRE_LIB_ARCH_DIR = $(EXPORT_JRE_LIB_DIR)/$(LIBARCH)
 
+# non-universal macosx builds need to appear universal
+ifeq ($(OS_VENDOR), Darwin)
+  ifneq ($(MACOSX_UNIVERSAL), true)
+    EXPORT_JRE_LIB_ARCH_DIR = $(EXPORT_JRE_LIB_DIR)
+  endif
+endif
+
 # Common export list of files
 EXPORT_LIST += $(EXPORT_INCLUDE_DIR)/jvmti.h
 EXPORT_LIST += $(EXPORT_INCLUDE_DIR)/jvmticmlr.h
diff -Nru openjdk.orig/hotspot/make/Makefile openjdk/hotspot/make/Makefile
--- openjdk.orig/hotspot/make/Makefile	2012-07-25 15:14:34.462185981 +0100
+++ openjdk/hotspot/make/Makefile	2012-07-25 15:27:37.275648905 +0100
@@ -471,6 +471,36 @@
 	   ($(CD) $(JDK_IMAGE_DIR)/debug && $(TAR) -xf -) ; \
 	fi
 
+# macosx universal builds
+
+ifeq ($(MACOSX_UNIVERSAL), true)
+$(UNIVERSAL_LIPO_LIST):
+	lipo -create -output $@ $(EXPORT_JRE_LIB_DIR)/{i386,amd64}/$(subst $(EXPORT_JRE_LIB_DIR)/,,$@)
+
+$(UNIVERSAL_COPY_LIST):
+	$(CP) $(EXPORT_JRE_LIB_DIR)/i386/$(subst $(EXPORT_JRE_LIB_DIR)/,,$@) $@
+
+universalize: $(UNIVERSAL_LIPO_LIST) $(UNIVERSAL_COPY_LIST)
+endif
+
+universal_product:
+	$(QUIETLY) $(MAKE) ARCH_DATA_MODEL=32 MACOSX_UNIVERSAL=true all_product
+	$(QUIETLY) $(MAKE) ARCH_DATA_MODEL=64 MACOSX_UNIVERSAL=true all_product
+	$(MKDIR) -p $(EXPORT_JRE_LIB_DIR)/{client,server}
+	$(QUIETLY) $(MAKE) MACOSX_UNIVERSAL=true universalize
+
+universal_fastdebug:
+	$(QUIETLY) $(MAKE) ARCH_DATA_MODEL=32 MACOSX_UNIVERSAL=true all_fastdebug
+	$(QUIETLY) $(MAKE) ARCH_DATA_MODEL=64 MACOSX_UNIVERSAL=true all_fastdebug
+	$(MKDIR) -p $(EXPORT_JRE_LIB_DIR)/{client,server}
+	$(QUIETLY) $(MAKE) MACOSX_UNIVERSAL=true universalize
+
+universal_debug:
+	$(QUIETLY) $(MAKE) ARCH_DATA_MODEL=32 MACOSX_UNIVERSAL=true all_debug
+	$(QUIETLY) $(MAKE) ARCH_DATA_MODEL=64 MACOSX_UNIVERSAL=true all_debug
+	$(MKDIR) -p $(EXPORT_JRE_LIB_DIR)/{client,server}
+	$(QUIETLY) $(MAKE) MACOSX_UNIVERSAL=true universalize
+
 #
 # Check target
 #
@@ -599,5 +629,6 @@
 	export_product export_fastdebug export_debug export_optimized \
 	export_jdk_product export_jdk_fastdebug export_jdk_debug \
 	create_jdk copy_jdk update_jdk test_jdk \
-	copy_product_jdk copy_fastdebug_jdk copy_debug_jdk
+	copy_product_jdk copy_fastdebug_jdk copy_debug_jdk universalize \
+	universal_product
 
diff -Nru openjdk.orig/hotspot/make/templates/bsd-header openjdk/hotspot/make/templates/bsd-header
--- openjdk.orig/hotspot/make/templates/bsd-header	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/make/templates/bsd-header	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-Copyright (c) %YEARS%, Oracle and/or its affiliates. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-  - Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
-
-  - Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-  - Neither the name of Oracle nor the names of its
-    contributors may be used to endorse or promote products derived
-    from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -Nru openjdk.orig/hotspot/src/cpu/x86/vm/jni_x86.h openjdk/hotspot/src/cpu/x86/vm/jni_x86.h
--- openjdk.orig/hotspot/src/cpu/x86/vm/jni_x86.h	2012-07-25 15:14:34.470186120 +0100
+++ openjdk/hotspot/src/cpu/x86/vm/jni_x86.h	2012-07-25 15:27:37.279648973 +0100
@@ -38,10 +38,14 @@
 
   #define JNICALL
   typedef int jint;
-
-#ifdef _LP64
+#if defined(_LP64) && !defined(__APPLE__)
   typedef long jlong;
 #else
+  /*
+   * On _LP64 __APPLE__ "long" and "long long" are both 64 bits,
+   * but we use the "long long" typedef to avoid complaints from
+   * the __APPLE__ compiler about fprintf formats.
+   */
   typedef long long jlong;
 #endif
 
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/generateJvmOffsets.cpp openjdk/hotspot/src/os/bsd/dtrace/generateJvmOffsets.cpp
--- openjdk.orig/hotspot/src/os/bsd/dtrace/generateJvmOffsets.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/generateJvmOffsets.cpp	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,294 @@
+/*
+ * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ * This is to provide sanity check in jhelper.d which compares SCCS
+ * versions of generateJvmOffsets.cpp used to create and extract
+ * contents of __JvmOffsets[] table.
+ * The __JvmOffsets[] table is located in generated JvmOffsets.cpp.
+ *
+ * GENOFFS_SCCS_VER 34
+ */
+
+#include "generateJvmOffsets.h"
+
+/* A workaround for private and protected fields */
+#define private   public
+#define protected public
+
+// not on macosx #include <proc_service.h>
+#include "code/codeBlob.hpp"
+#include "code/nmethod.hpp"
+#include "code/pcDesc.hpp"
+#include "gc_interface/collectedHeap.hpp"
+#include "memory/heap.hpp"
+#include "memory/memRegion.hpp"
+#include "memory/universe.hpp"
+#include "oops/constMethodOop.hpp"
+#include "oops/klass.hpp"
+#include "oops/methodOop.hpp"
+#include "oops/oop.hpp"
+#include "oops/symbol.hpp"
+#include "runtime/virtualspace.hpp"
+#include "runtime/vmStructs.hpp"
+#include "utilities/accessFlags.hpp"
+#include "utilities/globalDefinitions.hpp"
+
+// These are defined somewhere for Solaris
+#define PR_MODEL_ILP32 1
+#define PR_MODEL_LP64  2
+
+#ifdef COMPILER1
+#if defined(DEBUG) || defined(FASTDEBUG)
+
+/*
+ * To avoid the most part of potential link errors
+ * we link this program with -z nodefs .
+ *
+ * But for 'debug1' and 'fastdebug1' we still have to provide
+ * a particular workaround for the following symbols bellow.
+ * It will be good to find out a generic way in the future.
+ */
+
+#pragma weak tty
+#pragma weak CMSExpAvgFactor
+
+#if defined(i386) || defined(__i386) || defined(__amd64)
+#pragma weak noreg
+#endif /* i386 */
+
+LIR_Opr LIR_OprFact::illegalOpr = (LIR_Opr) 0;
+
+address StubRoutines::_call_stub_return_address = NULL;
+
+StubQueue* AbstractInterpreter::_code = NULL;
+
+#endif /* defined(DEBUG) || defined(FASTDEBUG) */
+#endif /* COMPILER1 */
+
+#define GEN_OFFS(Type,Name)                             \
+  switch(gen_variant) {                                 \
+  case GEN_OFFSET:                                      \
+    printf("#define OFFSET_%-33s %ld\n",                 \
+           #Type #Name, offset_of(Type, Name)); \
+    break;                                              \
+  case GEN_INDEX:                                       \
+    printf("#define IDX_OFFSET_%-33s %d\n",             \
+            #Type #Name, index++);                      \
+    break;                                              \
+  case GEN_TABLE:                                       \
+    printf("\tOFFSET_%s,\n", #Type #Name);              \
+    break;                                              \
+  }
+
+#define GEN_SIZE(Type)                                  \
+  switch(gen_variant) {                                 \
+  case GEN_OFFSET:                                      \
+    printf("#define SIZE_%-35s %ld\n",                   \
+            #Type, sizeof(Type));                       \
+    break;                                              \
+  case GEN_INDEX:                                       \
+    printf("#define IDX_SIZE_%-35s %d\n",               \
+            #Type, index++);                            \
+    break;                                              \
+  case GEN_TABLE:                                       \
+    printf("\tSIZE_%s,\n", #Type);                      \
+    break;                                              \
+  }
+
+#define GEN_VALUE(String,Value)                         \
+  switch(gen_variant) {                                 \
+  case GEN_OFFSET:                                      \
+    printf("#define %-40s %d\n", #String, Value);       \
+    break;                                              \
+  case GEN_INDEX:                                       \
+    printf("#define IDX_%-40s %d\n", #String, index++); \
+    break;                                              \
+  case GEN_TABLE:                                       \
+    printf("\t" #String ",\n");                         \
+    break;                                              \
+  }
+
+void gen_prologue(GEN_variant gen_variant) {
+    const char *suffix;
+
+    switch(gen_variant) {
+      case GEN_OFFSET: suffix = ".h";        break;
+      case GEN_INDEX:  suffix = "Index.h";   break;
+      case GEN_TABLE:  suffix = ".cpp";      break;
+    }
+
+    printf("/*\n");
+    printf(" * JvmOffsets%s !!!DO NOT EDIT!!! \n", suffix);
+    printf(" * The generateJvmOffsets program generates this file!\n");
+    printf(" */\n\n");
+    switch(gen_variant) {
+
+      case GEN_OFFSET:
+      case GEN_INDEX:
+        break;
+
+      case GEN_TABLE:
+        printf("#include \"JvmOffsets.h\"\n");
+        printf("\n");
+        printf("int __JvmOffsets[] = {\n");
+        break;
+    }
+}
+
+void gen_epilogue(GEN_variant gen_variant) {
+    if (gen_variant != GEN_TABLE) {
+        return;
+    }
+    printf("};\n\n");
+    return;
+}
+
+int generateJvmOffsets(GEN_variant gen_variant) {
+  int index = 0;        /* It is used to generate JvmOffsetsIndex.h */
+  int pointer_size = sizeof(void *);
+  int data_model = (pointer_size == 4) ? PR_MODEL_ILP32 : PR_MODEL_LP64;
+
+  gen_prologue(gen_variant);
+
+  GEN_VALUE(DATA_MODEL, data_model);
+  GEN_VALUE(POINTER_SIZE, pointer_size);
+#if defined(TIERED)
+  GEN_VALUE(COMPILER, 3);
+#elif COMPILER1
+  GEN_VALUE(COMPILER, 1);
+#elif COMPILER2
+  GEN_VALUE(COMPILER, 2);
+#else
+  GEN_VALUE(COMPILER, 0);
+#endif // COMPILER1 && COMPILER2
+  printf("\n");
+
+  GEN_OFFS(CollectedHeap, _reserved);
+  GEN_OFFS(MemRegion, _start);
+  GEN_OFFS(MemRegion, _word_size);
+  GEN_SIZE(HeapWord);
+  printf("\n");
+
+  GEN_OFFS(VMStructEntry, typeName);
+  GEN_OFFS(VMStructEntry, fieldName);
+  GEN_OFFS(VMStructEntry, address);
+  GEN_SIZE(VMStructEntry);
+  printf("\n");
+
+  GEN_VALUE(MAX_METHOD_CODE_SIZE, max_method_code_size);
+#if defined(sparc) || defined(__sparc)
+  GEN_VALUE(OFFSET_interpreter_frame_method, 2 * pointer_size);     /* L2 in saved window */
+  GEN_VALUE(OFFSET_interpreter_frame_sender_sp, 13 * pointer_size); /* I5 in saved window */
+  // Fake value for consistency. It is not going to be used.
+  GEN_VALUE(OFFSET_interpreter_frame_bcx_offset, 0xFFFF);
+#elif defined(i386) || defined(__i386) || defined(__amd64)
+  GEN_VALUE(OFFSET_interpreter_frame_sender_sp, -1 * pointer_size);
+  GEN_VALUE(OFFSET_interpreter_frame_method, -3 * pointer_size);
+  GEN_VALUE(OFFSET_interpreter_frame_bcx_offset, -7 * pointer_size);
+#endif
+
+  GEN_OFFS(Klass, _name);
+  GEN_OFFS(constantPoolOopDesc, _pool_holder);
+  printf("\n");
+
+  GEN_VALUE(OFFSET_HeapBlockHeader_used, (int) offset_of(HeapBlock::Header, _used));
+  GEN_OFFS(oopDesc, _metadata);
+  printf("\n");
+
+  GEN_VALUE(AccessFlags_NATIVE, JVM_ACC_NATIVE);
+  GEN_VALUE(constMethodOopDesc_has_linenumber_table, constMethodOopDesc::_has_linenumber_table);
+  GEN_OFFS(AccessFlags, _flags);
+  GEN_OFFS(Symbol, _length);
+  GEN_OFFS(Symbol, _body);
+  printf("\n");
+
+  GEN_OFFS(methodOopDesc, _constMethod);
+  GEN_OFFS(methodOopDesc, _constants);
+  GEN_OFFS(methodOopDesc, _access_flags);
+  printf("\n");
+
+  GEN_OFFS(constMethodOopDesc, _flags);
+  GEN_OFFS(constMethodOopDesc, _code_size);
+  GEN_OFFS(constMethodOopDesc, _name_index);
+  GEN_OFFS(constMethodOopDesc, _signature_index);
+  printf("\n");
+
+  GEN_OFFS(CodeHeap, _memory);
+  GEN_OFFS(CodeHeap, _segmap);
+  GEN_OFFS(CodeHeap, _log2_segment_size);
+  printf("\n");
+
+  GEN_OFFS(VirtualSpace, _low_boundary);
+  GEN_OFFS(VirtualSpace, _high_boundary);
+  GEN_OFFS(VirtualSpace, _low);
+  GEN_OFFS(VirtualSpace, _high);
+  printf("\n");
+
+  GEN_OFFS(CodeBlob, _name);
+  GEN_OFFS(CodeBlob, _header_size);
+  GEN_OFFS(CodeBlob, _content_offset);
+  GEN_OFFS(CodeBlob, _code_offset);
+  GEN_OFFS(CodeBlob, _data_offset);
+  GEN_OFFS(CodeBlob, _frame_size);
+  printf("\n");
+
+  GEN_OFFS(nmethod, _method);
+  GEN_OFFS(nmethod, _oops_offset);
+  GEN_OFFS(nmethod, _scopes_data_offset);
+  GEN_OFFS(nmethod, _scopes_pcs_offset);
+  GEN_OFFS(nmethod, _handler_table_offset);
+  GEN_OFFS(nmethod, _deoptimize_offset);
+  GEN_OFFS(nmethod, _orig_pc_offset);
+
+  GEN_OFFS(PcDesc, _pc_offset);
+  GEN_OFFS(PcDesc, _scope_decode_offset);
+
+  printf("\n");
+
+  GEN_OFFS(NarrowOopStruct, _base);
+  GEN_OFFS(NarrowOopStruct, _shift);
+  printf("\n");
+
+  GEN_VALUE(SIZE_HeapBlockHeader, (int) sizeof(HeapBlock::Header));
+  GEN_SIZE(oopDesc);
+  GEN_SIZE(constantPoolOopDesc);
+  printf("\n");
+
+  GEN_SIZE(PcDesc);
+  GEN_SIZE(methodOopDesc);
+  GEN_SIZE(constMethodOopDesc);
+  GEN_SIZE(nmethod);
+  GEN_SIZE(CodeBlob);
+  GEN_SIZE(BufferBlob);
+  GEN_SIZE(SingletonBlob);
+  GEN_SIZE(RuntimeStub);
+  GEN_SIZE(SafepointBlob);
+
+  gen_epilogue(gen_variant);
+  printf("\n");
+
+  fflush(stdout);
+  return 0;
+}
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/generateJvmOffsets.h openjdk/hotspot/src/os/bsd/dtrace/generateJvmOffsets.h
--- openjdk.orig/hotspot/src/os/bsd/dtrace/generateJvmOffsets.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/generateJvmOffsets.h	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_SOLARIS_DTRACE_GENERATEJVMOFFSETS_H
+#define OS_SOLARIS_DTRACE_GENERATEJVMOFFSETS_H
+
+#include <stdio.h>
+#include <strings.h>
+
+typedef enum GEN_variant {
+        GEN_OFFSET = 0,
+        GEN_INDEX  = 1,
+        GEN_TABLE  = 2
+} GEN_variant;
+
+extern "C" {
+        int generateJvmOffsets(GEN_variant gen_var);
+        void gen_prologue(GEN_variant gen_var);
+        void gen_epilogue(GEN_variant gen_var);
+}
+
+#endif // OS_SOLARIS_DTRACE_GENERATEJVMOFFSETS_H
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/generateJvmOffsetsMain.c openjdk/hotspot/src/os/bsd/dtrace/generateJvmOffsetsMain.c
--- openjdk.orig/hotspot/src/os/bsd/dtrace/generateJvmOffsetsMain.c	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/generateJvmOffsetsMain.c	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+
+#include "generateJvmOffsets.h"
+
+const char *HELP =
+    "HELP: generateJvmOffsets {-header | -index | -table} \n";
+
+int main(int argc, const char *argv[]) {
+    GEN_variant gen_var;
+
+    if (argc != 2) {
+        printf("%s", HELP);
+        return 1;
+    }
+
+    if (0 == strcmp(argv[1], "-header")) {
+        gen_var = GEN_OFFSET;
+    }
+    else if (0 == strcmp(argv[1], "-index")) {
+        gen_var = GEN_INDEX;
+    }
+    else if (0 == strcmp(argv[1], "-table")) {
+        gen_var = GEN_TABLE;
+    }
+    else {
+        printf("%s", HELP);
+        return 1;
+    }
+    return generateJvmOffsets(gen_var);
+}
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/hotspot.d openjdk/hotspot/src/os/bsd/dtrace/hotspot.d
--- openjdk.orig/hotspot/src/os/bsd/dtrace/hotspot.d	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/hotspot.d	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *  
+ */
+
+provider hotspot {
+  probe class__loaded(char*, uintptr_t, void*, uintptr_t);
+  probe class__unloaded(char*, uintptr_t, void*, uintptr_t);
+  probe class__initialization__required(char*, uintptr_t, void*, intptr_t);
+  probe class__initialization__recursive(char*, uintptr_t, void*, intptr_t,int);
+  probe class__initialization__concurrent(char*, uintptr_t, void*, intptr_t,int);
+  probe class__initialization__erroneous(char*, uintptr_t, void*, intptr_t, int);
+  probe class__initialization__super__failed(char*, uintptr_t, void*, intptr_t,int);
+  probe class__initialization__clinit(char*, uintptr_t, void*, intptr_t,int);
+  probe class__initialization__error(char*, uintptr_t, void*, intptr_t,int);
+  probe class__initialization__end(char*, uintptr_t, void*, intptr_t,int);
+  probe vm__init__begin();
+  probe vm__init__end();
+  probe vm__shutdown();
+  probe vmops__request(char*, uintptr_t, int);
+  probe vmops__begin(char*, uintptr_t, int);
+  probe vmops__end(char*, uintptr_t, int);
+  probe gc__begin(uintptr_t);
+  probe gc__end();
+  probe mem__pool__gc__begin(
+    char*, uintptr_t, char*, uintptr_t, 
+    uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+  probe mem__pool__gc__end(
+    char*, uintptr_t, char*, uintptr_t, 
+    uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+  probe thread__probe__start(char*, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+  probe thread__probe__stop(char*, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+  probe thread__sleep__begin(long long);
+  probe thread__sleep__end(int);
+  probe thread__yield();
+  probe thread__park__begin(uintptr_t, int, long long);
+  probe thread__park__end(uintptr_t);
+  probe thread__unpark(uintptr_t);
+  probe method__compile__begin(
+    const char*, uintptr_t, const char*, uintptr_t, const char*, uintptr_t, const char*, uintptr_t); 
+  probe method__compile__end(
+    char*, uintptr_t, char*, uintptr_t, char*, uintptr_t, 
+    char*, uintptr_t, uintptr_t); 
+  probe compiled__method__load(
+    char*, uintptr_t, char*, uintptr_t, char*, uintptr_t, void*, uintptr_t);
+  probe compiled__method__unload(
+    char*, uintptr_t, char*, uintptr_t, char*, uintptr_t); 
+  probe monitor__contended__enter(uintptr_t, uintptr_t, char*, uintptr_t);
+  probe monitor__contended__entered(uintptr_t, uintptr_t, char*, uintptr_t);
+  probe monitor__contended__exit(uintptr_t, uintptr_t, char*, uintptr_t);
+  probe monitor__wait(uintptr_t, uintptr_t, char*, uintptr_t, uintptr_t);
+  probe monitor__probe__waited(uintptr_t, uintptr_t, char*, uintptr_t);
+  probe monitor__notify(uintptr_t, uintptr_t, char*, uintptr_t);
+  probe monitor__notifyAll(uintptr_t, uintptr_t, char*, uintptr_t);
+
+  probe object__alloc(int, char*, uintptr_t, uintptr_t);
+  probe method__entry(
+    int, char*, int, char*, int, char*, int);
+  probe method__return(
+    int, char*, int, char*, int, char*, int);
+};
+
+#pragma D attributes Evolving/Evolving/Common provider hotspot provider
+#pragma D attributes Private/Private/Unknown provider hotspot module
+#pragma D attributes Private/Private/Unknown provider hotspot function
+#pragma D attributes Evolving/Evolving/Common provider hotspot name
+#pragma D attributes Evolving/Evolving/Common provider hotspot args
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/hotspot_jni.d openjdk/hotspot/src/os/bsd/dtrace/hotspot_jni.d
--- openjdk.orig/hotspot/src/os/bsd/dtrace/hotspot_jni.d	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/hotspot_jni.d	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,506 @@
+/*
+ * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *  
+ */
+
+provider hotspot_jni {
+  probe AllocObject__entry(void*, void*);
+  probe AllocObject__return(void*);
+  probe AttachCurrentThreadAsDaemon__entry(void*, void**, void*);
+  probe AttachCurrentThreadAsDaemon__return(uint32_t);
+  probe AttachCurrentThread__entry(void*, void**, void*);
+  probe AttachCurrentThread__return(uint32_t);
+  probe CallBooleanMethodA__entry(void*, void*, uintptr_t);
+  probe CallBooleanMethodA__return(uintptr_t);
+  probe CallBooleanMethod__entry(void*, void*, uintptr_t);
+  probe CallBooleanMethod__return(uintptr_t);
+  probe CallBooleanMethodV__entry(void*, void*, uintptr_t);
+  probe CallBooleanMethodV__return(uintptr_t);
+  probe CallByteMethodA__entry(void*, void*, uintptr_t);
+  probe CallByteMethodA__return(char);
+  probe CallByteMethod__entry(void*, void*, uintptr_t);
+  probe CallByteMethod__return(char);
+  probe CallByteMethodV__entry(void*, void*, uintptr_t);
+  probe CallByteMethodV__return(char);
+  probe CallCharMethodA__entry(void*, void*, uintptr_t);
+  probe CallCharMethodA__return(uint16_t);
+  probe CallCharMethod__entry(void*, void*, uintptr_t);
+  probe CallCharMethod__return(uint16_t);
+  probe CallCharMethodV__entry(void*, void*, uintptr_t);
+  probe CallCharMethodV__return(uint16_t);
+  probe CallDoubleMethodA__entry(void*, void*, uintptr_t);
+  probe CallDoubleMethodA__return();
+  probe CallDoubleMethod__entry(void*, void*, uintptr_t);
+  probe CallDoubleMethod__return();
+  probe CallDoubleMethodV__entry(void*, void*, uintptr_t);
+  probe CallDoubleMethodV__return();
+  probe CallFloatMethodA__entry(void*, void*, uintptr_t);
+  probe CallFloatMethodA__return();
+  probe CallFloatMethod__entry(void*, void*, uintptr_t);
+  probe CallFloatMethod__return();
+  probe CallFloatMethodV__entry(void*, void*, uintptr_t);
+  probe CallFloatMethodV__return();
+  probe CallIntMethodA__entry(void*, void*, uintptr_t);
+  probe CallIntMethodA__return(uint32_t);
+  probe CallIntMethod__entry(void*, void*, uintptr_t);
+  probe CallIntMethod__return(uint32_t);
+  probe CallIntMethodV__entry(void*, void*, uintptr_t);
+  probe CallIntMethodV__return(uint32_t);
+  probe CallLongMethodA__entry(void*, void*, uintptr_t);
+  probe CallLongMethodA__return(uintptr_t);
+  probe CallLongMethod__entry(void*, void*, uintptr_t);
+  probe CallLongMethod__return(uintptr_t);
+  probe CallLongMethodV__entry(void*, void*, uintptr_t);
+  probe CallLongMethodV__return(uintptr_t);
+  probe CallNonvirtualBooleanMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualBooleanMethodA__return(uintptr_t);
+  probe CallNonvirtualBooleanMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualBooleanMethod__return(uintptr_t);
+  probe CallNonvirtualBooleanMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualBooleanMethodV__return(uintptr_t);
+  probe CallNonvirtualByteMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualByteMethodA__return(char);
+  probe CallNonvirtualByteMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualByteMethod__return(char);
+  probe CallNonvirtualByteMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualByteMethodV__return(char);
+  probe CallNonvirtualCharMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualCharMethodA__return(uint16_t);
+  probe CallNonvirtualCharMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualCharMethod__return(uint16_t);
+  probe CallNonvirtualCharMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualCharMethodV__return(uint16_t);
+  probe CallNonvirtualDoubleMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualDoubleMethodA__return();
+  probe CallNonvirtualDoubleMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualDoubleMethod__return();
+  probe CallNonvirtualDoubleMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualDoubleMethodV__return();
+  probe CallNonvirtualFloatMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualFloatMethodA__return();
+  probe CallNonvirtualFloatMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualFloatMethod__return();
+  probe CallNonvirtualFloatMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualFloatMethodV__return();
+  probe CallNonvirtualIntMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualIntMethodA__return(uint32_t);
+  probe CallNonvirtualIntMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualIntMethod__return(uint32_t);
+  probe CallNonvirtualIntMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualIntMethodV__return(uint32_t);
+  probe CallNonvirtualLongMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualLongMethodA__return(uintptr_t);
+  probe CallNonvirtualLongMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualLongMethod__return(uintptr_t);
+  probe CallNonvirtualLongMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualLongMethodV__return(uintptr_t);
+  probe CallNonvirtualObjectMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualObjectMethodA__return(void*);
+  probe CallNonvirtualObjectMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualObjectMethod__return(void*);
+  probe CallNonvirtualObjectMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualObjectMethodV__return(void*);
+  probe CallNonvirtualShortMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualShortMethodA__return(uint16_t);
+  probe CallNonvirtualShortMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualShortMethod__return(uint16_t);
+  probe CallNonvirtualShortMethodV__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualShortMethodV__return(uint16_t);
+  probe CallNonvirtualVoidMethodA__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualVoidMethodA__return();
+  probe CallNonvirtualVoidMethod__entry(void*, void*, void*, uintptr_t);
+  probe CallNonvirtualVoidMethod__return();
+  probe CallNonvirtualVoidMethodV__entry(void*, void*, void*, uintptr_t);  
+  probe CallNonvirtualVoidMethodV__return();
+  probe CallObjectMethodA__entry(void*, void*, uintptr_t);
+  probe CallObjectMethodA__return(void*);
+  probe CallObjectMethod__entry(void*, void*, uintptr_t);
+  probe CallObjectMethod__return(void*);
+  probe CallObjectMethodV__entry(void*, void*, uintptr_t);
+  probe CallObjectMethodV__return(void*);
+  probe CallShortMethodA__entry(void*, void*, uintptr_t);
+  probe CallShortMethodA__return(uint16_t);
+  probe CallShortMethod__entry(void*, void*, uintptr_t);
+  probe CallShortMethod__return(uint16_t);
+  probe CallShortMethodV__entry(void*, void*, uintptr_t);
+  probe CallShortMethodV__return(uint16_t);
+  probe CallStaticBooleanMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticBooleanMethodA__return(uintptr_t);
+  probe CallStaticBooleanMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticBooleanMethod__return(uintptr_t);
+  probe CallStaticBooleanMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticBooleanMethodV__return(uintptr_t);
+  probe CallStaticByteMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticByteMethodA__return(char);
+  probe CallStaticByteMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticByteMethod__return(char);
+  probe CallStaticByteMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticByteMethodV__return(char);
+  probe CallStaticCharMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticCharMethodA__return(uint16_t);
+  probe CallStaticCharMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticCharMethod__return(uint16_t);
+  probe CallStaticCharMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticCharMethodV__return(uint16_t);
+  probe CallStaticDoubleMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticDoubleMethodA__return();
+  probe CallStaticDoubleMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticDoubleMethod__return();
+  probe CallStaticDoubleMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticDoubleMethodV__return();
+  probe CallStaticFloatMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticFloatMethodA__return();
+  probe CallStaticFloatMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticFloatMethod__return();
+  probe CallStaticFloatMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticFloatMethodV__return();
+  probe CallStaticIntMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticIntMethodA__return(uint32_t);
+  probe CallStaticIntMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticIntMethod__return(uint32_t);
+  probe CallStaticIntMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticIntMethodV__return(uint32_t);
+  probe CallStaticLongMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticLongMethodA__return(uintptr_t);
+  probe CallStaticLongMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticLongMethod__return(uintptr_t);
+  probe CallStaticLongMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticLongMethodV__return(uintptr_t);
+  probe CallStaticObjectMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticObjectMethodA__return(void*);
+  probe CallStaticObjectMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticObjectMethod__return(void*);
+  probe CallStaticObjectMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticObjectMethodV__return(void*);
+  probe CallStaticShortMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticShortMethodA__return(uint16_t);
+  probe CallStaticShortMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticShortMethod__return(uint16_t);
+  probe CallStaticShortMethodV__entry(void*, void*, uintptr_t);
+  probe CallStaticShortMethodV__return(uint16_t);
+  probe CallStaticVoidMethodA__entry(void*, void*, uintptr_t);
+  probe CallStaticVoidMethodA__return();
+  probe CallStaticVoidMethod__entry(void*, void*, uintptr_t);
+  probe CallStaticVoidMethod__return(); 
+  probe CallStaticVoidMethodV__entry(void*, void*, uintptr_t);  
+  probe CallStaticVoidMethodV__return();
+  probe CallVoidMethodA__entry(void*, void*, uintptr_t);  
+  probe CallVoidMethodA__return();
+  probe CallVoidMethod__entry(void*, void*, uintptr_t);  
+  probe CallVoidMethod__return(); 
+  probe CallVoidMethodV__entry(void*, void*, uintptr_t);  
+  probe CallVoidMethodV__return();
+  probe CreateJavaVM__entry(void**, void**, void*);
+  probe CreateJavaVM__return(uint32_t);
+  probe DefineClass__entry(void*, const char*, void*, char*, uintptr_t);
+  probe DefineClass__return(void*);
+  probe DeleteGlobalRef__entry(void*, void*);
+  probe DeleteGlobalRef__return();
+  probe DeleteLocalRef__entry(void*, void*);
+  probe DeleteLocalRef__return();
+  probe DeleteWeakGlobalRef__entry(void*, void*);
+  probe DeleteWeakGlobalRef__return();
+  probe DestroyJavaVM__entry(void*);
+  probe DestroyJavaVM__return(uint32_t);
+  probe DetachCurrentThread__entry(void*);
+  probe DetachCurrentThread__return(uint32_t);
+  probe EnsureLocalCapacity__entry(void*, uint32_t);
+  probe EnsureLocalCapacity__return(uint32_t);
+  probe ExceptionCheck__entry(void*);
+  probe ExceptionCheck__return(uintptr_t);
+  probe ExceptionClear__entry(void*);
+  probe ExceptionClear__return();
+  probe ExceptionDescribe__entry(void*);  
+  probe ExceptionDescribe__return();
+  probe ExceptionOccurred__entry(void*);
+  probe ExceptionOccurred__return(void*);
+  probe FatalError__entry(void* env, const char*);
+  probe FindClass__entry(void*, const char*);
+  probe FindClass__return(void*);
+  probe FromReflectedField__entry(void*, void*);
+  probe FromReflectedField__return(uintptr_t);
+  probe FromReflectedMethod__entry(void*, void*);
+  probe FromReflectedMethod__return(uintptr_t);
+  probe GetArrayLength__entry(void*, void*);
+  probe GetArrayLength__return(uintptr_t);
+  probe GetBooleanArrayElements__entry(void*, void*, uintptr_t*);
+  probe GetBooleanArrayElements__return(uintptr_t*);
+  probe GetBooleanArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, uintptr_t*);
+  probe GetBooleanArrayRegion__return();
+  probe GetBooleanField__entry(void*, void*, uintptr_t);
+  probe GetBooleanField__return(uintptr_t);
+  probe GetByteArrayElements__entry(void*, void*, uintptr_t*);
+  probe GetByteArrayElements__return(char*);
+  probe GetByteArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, char*);
+  probe GetByteArrayRegion__return();
+  probe GetByteField__entry(void*, void*, uintptr_t);
+  probe GetByteField__return(char);
+  probe GetCharArrayElements__entry(void*, void*, uintptr_t*);
+  probe GetCharArrayElements__return(uint16_t*);
+  probe GetCharArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, uint16_t*);
+  probe GetCharArrayRegion__return();
+  probe GetCharField__entry(void*, void*, uintptr_t);
+  probe GetCharField__return(uint16_t);
+  probe GetCreatedJavaVMs__entry(void**, uintptr_t, uintptr_t*);
+  probe GetCreatedJavaVMs__return(uintptr_t);
+  probe GetDefaultJavaVMInitArgs__entry(void*);
+  probe GetDefaultJavaVMInitArgs__return(uint32_t);
+  probe GetDirectBufferAddress__entry(void*, void*);
+  probe GetDirectBufferAddress__return(void*);
+  probe GetDirectBufferCapacity__entry(void*, void*);
+  probe GetDirectBufferCapacity__return(uintptr_t);
+  probe GetDoubleArrayElements__entry(void*, void*, uintptr_t*);
+  probe GetDoubleArrayElements__return(double*);
+  probe GetDoubleArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, double*);
+  probe GetDoubleArrayRegion__return();
+  probe GetDoubleField__entry(void*, void*, uintptr_t);
+  probe GetDoubleField__return();
+  probe GetEnv__entry(void*, void*, uint32_t);
+  probe GetEnv__return(uint32_t);
+  probe GetFieldID__entry(void*, void*, const char*, const char*);
+  probe GetFieldID__return(uintptr_t);
+  probe GetFloatArrayElements__entry(void*, void*, uintptr_t*);
+  probe GetFloatArrayElements__return(float*);
+  probe GetFloatArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, float*);
+  probe GetFloatArrayRegion__return();
+  probe GetFloatField__entry(void*, void*, uintptr_t);
+  probe GetFloatField__return();
+  probe GetIntArrayElements__entry(void*, void*, uintptr_t*);
+  probe GetIntArrayElements__return(uint32_t*);
+  probe GetIntArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, uint32_t*);
+  probe GetIntArrayRegion__return();
+  probe GetIntField__entry(void*, void*, uintptr_t);
+  probe GetIntField__return(uint32_t);
+  probe GetJavaVM__entry(void*, void**);
+  probe GetJavaVM__return(uint32_t);
+  probe GetLongArrayElements__entry(void*, void*, uintptr_t*);
+  probe GetLongArrayElements__return(uintptr_t*);
+  probe GetLongArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, uintptr_t*);
+  probe GetLongArrayRegion__return();
+  probe GetLongField__entry(void*, void*, uintptr_t);
+  probe GetLongField__return(uintptr_t);
+  probe GetMethodID__entry(void*, void*, const char*, const char*);
+  probe GetMethodID__return(uintptr_t);
+  probe GetObjectArrayElement__entry(void*, void*, uintptr_t);
+  probe GetObjectArrayElement__return(void*);
+  probe GetObjectClass__entry(void*, void*);
+  probe GetObjectClass__return(void*);
+  probe GetObjectField__entry(void*, void*, uintptr_t);
+  probe GetObjectField__return(void*);
+  probe GetObjectRefType__entry(void*, void*);
+  probe GetObjectRefType__return(void*);
+  probe GetPrimitiveArrayCritical__entry(void*, void*, uintptr_t*);
+  probe GetPrimitiveArrayCritical__return(void*);
+  probe GetShortArrayElements__entry(void*, void*, uintptr_t*);
+  probe GetShortArrayElements__return(uint16_t*);
+  probe GetShortArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, uint16_t*);
+  probe GetShortArrayRegion__return();
+  probe GetShortField__entry(void*, void*, uintptr_t);
+  probe GetShortField__return(uint16_t);
+  probe GetStaticBooleanField__entry(void*, void*, uintptr_t);
+  probe GetStaticBooleanField__return(uintptr_t);
+  probe GetStaticByteField__entry(void*, void*, uintptr_t);
+  probe GetStaticByteField__return(char);
+  probe GetStaticCharField__entry(void*, void*, uintptr_t);
+  probe GetStaticCharField__return(uint16_t);
+  probe GetStaticDoubleField__entry(void*, void*, uintptr_t);
+  probe GetStaticDoubleField__return();
+  probe GetStaticFieldID__entry(void*, void*, const char*, const char*);
+  probe GetStaticFieldID__return(uintptr_t);
+  probe GetStaticFloatField__entry(void*, void*, uintptr_t);
+  probe GetStaticFloatField__return();
+  probe GetStaticIntField__entry(void*, void*, uintptr_t);
+  probe GetStaticIntField__return(uint32_t);
+  probe GetStaticLongField__entry(void*, void*, uintptr_t);
+  probe GetStaticLongField__return(uintptr_t);
+  probe GetStaticMethodID__entry(void*, void*, const char*, const char*);
+  probe GetStaticMethodID__return(uintptr_t);
+  probe GetStaticObjectField__entry(void*, void*, uintptr_t);
+  probe GetStaticObjectField__return(void*);
+  probe GetStaticShortField__entry(void*, void*, uintptr_t);
+  probe GetStaticShortField__return(uint16_t);
+  probe GetStringChars__entry(void*, void*, uintptr_t*);
+  probe GetStringChars__return(const uint16_t*);
+  probe GetStringCritical__entry(void*, void*, uintptr_t*);
+  probe GetStringCritical__return(const uint16_t*);
+  probe GetStringLength__entry(void*, void*);
+  probe GetStringLength__return(uintptr_t);
+  probe GetStringRegion__entry(void*, void*, uintptr_t, uintptr_t, uint16_t*);
+  probe GetStringRegion__return();
+  probe GetStringUTFChars__entry(void*, void*, uintptr_t*);
+  probe GetStringUTFChars__return(const char*);
+  probe GetStringUTFLength__entry(void*, void*);
+  probe GetStringUTFLength__return(uintptr_t);
+  probe GetStringUTFRegion__entry(void*, void*, uintptr_t, uintptr_t, char*);
+  probe GetStringUTFRegion__return();
+  probe GetSuperclass__entry(void*, void*);
+  probe GetSuperclass__return(void*);
+  probe GetVersion__entry(void*);
+  probe GetVersion__return(uint32_t);
+  probe IsAssignableFrom__entry(void*, void*, void*);
+  probe IsAssignableFrom__return(uintptr_t);
+  probe IsInstanceOf__entry(void*, void*, void*);
+  probe IsInstanceOf__return(uintptr_t);
+  probe IsSameObject__entry(void*, void*, void*);
+  probe IsSameObject__return(uintptr_t);
+  probe MonitorEnter__entry(void*, void*);
+  probe MonitorEnter__return(uint32_t);
+  probe MonitorExit__entry(void*, void*);
+  probe MonitorExit__return(uint32_t);
+  probe NewBooleanArray__entry(void*, uintptr_t);
+  probe NewBooleanArray__return(void*);
+  probe NewByteArray__entry(void*, uintptr_t);
+  probe NewByteArray__return(void*);
+  probe NewCharArray__entry(void*, uintptr_t);
+  probe NewCharArray__return(void*);
+  probe NewDirectByteBuffer__entry(void*, void*, uintptr_t);
+  probe NewDirectByteBuffer__return(void*);
+  probe NewDoubleArray__entry(void*, uintptr_t);
+  probe NewDoubleArray__return(void*);
+  probe NewFloatArray__entry(void*, uintptr_t);
+  probe NewFloatArray__return(void*);
+  probe NewGlobalRef__entry(void*, void*);
+  probe NewGlobalRef__return(void*);
+  probe NewIntArray__entry(void*, uintptr_t);
+  probe NewIntArray__return(void*);
+  probe NewLocalRef__entry(void*, void*);
+  probe NewLocalRef__return(void*);
+  probe NewLongArray__entry(void*, uintptr_t);
+  probe NewLongArray__return(void*);
+  probe NewObjectA__entry(void*, void*, uintptr_t);  
+  probe NewObjectA__return(void*);
+  probe NewObjectArray__entry(void*, uintptr_t, void*, void*);
+  probe NewObjectArray__return(void*);
+  probe NewObject__entry(void*, void*, uintptr_t); 
+  probe NewObject__return(void*);
+  probe NewObjectV__entry(void*, void*, uintptr_t);  
+  probe NewObjectV__return(void*);
+  probe NewShortArray__entry(void*, uintptr_t);
+  probe NewShortArray__return(void*);
+  probe NewString__entry(void*, const uint16_t*, uintptr_t);
+  probe NewString__return(void*);
+  probe NewStringUTF__entry(void*, const char*);
+  probe NewStringUTF__return(void*);
+  probe NewWeakGlobalRef__entry(void*, void*);
+  probe NewWeakGlobalRef__return(void*);
+  probe PopLocalFrame__entry(void*, void*);
+  probe PopLocalFrame__return(void*);
+  probe PushLocalFrame__entry(void*, uint32_t);
+  probe PushLocalFrame__return(uint32_t);
+  probe RegisterNatives__entry(void*, void*, const void*, uint32_t);  
+  probe RegisterNatives__return(uint32_t);
+  probe ReleaseBooleanArrayElements__entry(void*, void*, uintptr_t*, uint32_t);
+  probe ReleaseBooleanArrayElements__return();
+  probe ReleaseByteArrayElements__entry(void*, void*, char*, uint32_t);
+  probe ReleaseByteArrayElements__return();
+  probe ReleaseCharArrayElements__entry(void*, void*, uint16_t*, uint32_t);
+  probe ReleaseCharArrayElements__return();
+  probe ReleaseDoubleArrayElements__entry(void*, void*, double*, uint32_t);
+  probe ReleaseDoubleArrayElements__return();
+  probe ReleaseFloatArrayElements__entry(void*, void*, float*, uint32_t);
+  probe ReleaseFloatArrayElements__return();
+  probe ReleaseIntArrayElements__entry(void*, void*, uint32_t*, uint32_t);
+  probe ReleaseIntArrayElements__return();
+  probe ReleaseLongArrayElements__entry(void*, void*, uintptr_t*, uint32_t);
+  probe ReleaseLongArrayElements__return();
+  probe ReleasePrimitiveArrayCritical__entry(void*, void*, void*, uint32_t);
+  probe ReleasePrimitiveArrayCritical__return();
+  probe ReleaseShortArrayElements__entry(void*, void*, uint16_t*, uint32_t);
+  probe ReleaseShortArrayElements__return();
+  probe ReleaseStringChars__entry(void*, void*, const uint16_t*);
+  probe ReleaseStringChars__return();
+  probe ReleaseStringCritical__entry(void*, void*, const uint16_t*);
+  probe ReleaseStringCritical__return();
+  probe ReleaseStringUTFChars__entry(void*, void*, const char*);
+  probe ReleaseStringUTFChars__return();
+  probe SetBooleanArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, const uintptr_t*);
+  probe SetBooleanArrayRegion__return();
+  probe SetBooleanField__entry(void*, void*, uintptr_t, uintptr_t);
+  probe SetBooleanField__return();
+  probe SetByteArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, const char*);
+  probe SetByteArrayRegion__return();
+  probe SetByteField__entry(void*, void*, uintptr_t, char);
+  probe SetByteField__return();
+  probe SetCharArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, const uint16_t*);
+  probe SetCharArrayRegion__return();
+  probe SetCharField__entry(void*, void*, uintptr_t, uint16_t);
+  probe SetCharField__return();
+  probe SetDoubleArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, const double*);
+  probe SetDoubleArrayRegion__return();
+  probe SetDoubleField__entry(void*, void*, uintptr_t);
+  probe SetDoubleField__return();
+  probe SetFloatArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, const float*);
+  probe SetFloatArrayRegion__return();
+  probe SetFloatField__entry(void*, void*, uintptr_t);
+  probe SetFloatField__return();
+  probe SetIntArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, const uint32_t*);
+  probe SetIntArrayRegion__return();
+  probe SetIntField__entry(void*, void*, uintptr_t, uint32_t);
+  probe SetIntField__return();
+  probe SetLongArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, const uintptr_t*);
+  probe SetLongArrayRegion__return();
+  probe SetLongField__entry(void*, void*, uintptr_t, uintptr_t);
+  probe SetLongField__return();
+  probe SetObjectArrayElement__entry(void*, void*, uintptr_t, void*);
+  probe SetObjectArrayElement__return();
+  probe SetObjectField__entry(void*, void*, uintptr_t, void*);
+  probe SetObjectField__return();
+  probe SetShortArrayRegion__entry(void*, void*, uintptr_t, uintptr_t, const uint16_t*);
+  probe SetShortArrayRegion__return();
+  probe SetShortField__entry(void*, void*, uintptr_t, uint16_t);
+  probe SetShortField__return();
+  probe SetStaticBooleanField__entry(void*, void*, uintptr_t, uintptr_t);
+  probe SetStaticBooleanField__return();
+  probe SetStaticByteField__entry(void*, void*, uintptr_t, char);
+  probe SetStaticByteField__return();
+  probe SetStaticCharField__entry(void*, void*, uintptr_t, uint16_t);
+  probe SetStaticCharField__return();
+  probe SetStaticDoubleField__entry(void*, void*, uintptr_t);
+  probe SetStaticDoubleField__return();
+  probe SetStaticFloatField__entry(void*, void*, uintptr_t);
+  probe SetStaticFloatField__return();
+  probe SetStaticIntField__entry(void*, void*, uintptr_t, uint32_t);
+  probe SetStaticIntField__return();
+  probe SetStaticLongField__entry(void*, void*, uintptr_t, uintptr_t);
+  probe SetStaticLongField__return();
+  probe SetStaticObjectField__entry(void*, void*, uintptr_t, void*);
+  probe SetStaticObjectField__return();
+  probe SetStaticShortField__entry(void*, void*, uintptr_t, uint16_t);
+  probe SetStaticShortField__return();
+  probe Throw__entry(void*, void*);
+  probe Throw__return(intptr_t);
+  probe ThrowNew__entry(void*, void*, const char*);  
+  probe ThrowNew__return(intptr_t);  
+  probe ToReflectedField__entry(void*, void*, uintptr_t, uintptr_t);
+  probe ToReflectedField__return(void*);
+  probe ToReflectedMethod__entry(void*, void*, uintptr_t, uintptr_t);
+  probe ToReflectedMethod__return(void*);
+  probe UnregisterNatives__entry(void*, void*);  
+  probe UnregisterNatives__return(uint32_t);
+};
+
+#pragma D attributes Standard/Standard/Common provider hotspot_jni provider
+#pragma D attributes Private/Private/Unknown provider hotspot_jni module
+#pragma D attributes Private/Private/Unknown provider hotspot_jni function
+#pragma D attributes Standard/Standard/Common provider hotspot_jni name
+#pragma D attributes Evolving/Evolving/Common provider hotspot_jni args
+
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/hs_private.d openjdk/hotspot/src/os/bsd/dtrace/hs_private.d
--- openjdk.orig/hotspot/src/os/bsd/dtrace/hs_private.d	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/hs_private.d	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *  
+ */
+
+provider hs_private {
+  probe hashtable__new_entry(void*, uint32_t, uintptr_t, void*); 
+  probe safepoint__begin();
+  probe safepoint__end();
+  probe cms__initmark__begin();
+  probe cms__initmark__end();
+  probe cms__remark__begin();
+  probe cms__remark__end();
+};
+
+#pragma D attributes Private/Private/Common provider hs_private provider
+#pragma D attributes Private/Private/Unknown provider hs_private module
+#pragma D attributes Private/Private/Unknown provider hs_private function
+#pragma D attributes Private/Private/Common provider hs_private name
+#pragma D attributes Private/Private/Common provider hs_private args
+
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/jhelper.d openjdk/hotspot/src/os/bsd/dtrace/jhelper.d
--- openjdk.orig/hotspot/src/os/bsd/dtrace/jhelper.d	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/jhelper.d	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,447 @@
+/*
+ * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *  
+ */
+
+/* This file is auto-generated */
+#include "JvmOffsetsIndex.h"
+
+#define DEBUG
+
+#ifdef DEBUG
+#define MARK_LINE this->line = __LINE__
+#else
+#define MARK_LINE 
+#endif
+
+#ifdef _LP64
+#define STACK_BIAS 0x7ff
+#define pointer uint64_t
+#else
+#define STACK_BIAS 0
+#define pointer uint32_t
+#endif
+
+extern pointer __JvmOffsets;
+
+extern pointer __1cJCodeCacheF_heap_;
+extern pointer __1cIUniverseP_methodKlassObj_;
+extern pointer __1cIUniverseO_collectedHeap_;
+extern pointer __1cIUniverseL_narrow_oop_;
+#ifdef _LP64
+extern pointer UseCompressedOops;
+#endif
+
+extern pointer __1cHnmethodG__vtbl_;
+extern pointer __1cKBufferBlobG__vtbl_;
+
+#define copyin_ptr(ADDR)    *(pointer*)  copyin((pointer) (ADDR), sizeof(pointer))
+#define copyin_uchar(ADDR)  *(uchar_t*)  copyin((pointer) (ADDR), sizeof(uchar_t))
+#define copyin_uint16(ADDR) *(uint16_t*) copyin((pointer) (ADDR), sizeof(uint16_t))
+#define copyin_uint32(ADDR) *(uint32_t*) copyin((pointer) (ADDR), sizeof(uint32_t))
+#define copyin_int32(ADDR)  *(int32_t*)  copyin((pointer) (ADDR), sizeof(int32_t))
+#define copyin_uint8(ADDR)  *(uint8_t*)  copyin((pointer) (ADDR), sizeof(uint8_t))
+
+#define SAME(x) x
+#define copyin_offset(JVM_CONST)  JVM_CONST = \
+	copyin_int32(JvmOffsetsPtr + SAME(IDX_)JVM_CONST * sizeof(int32_t))
+
+int init_done;
+
+dtrace:helper:ustack:
+{
+  MARK_LINE;
+  this->done = 0;
+  /*
+   * TBD:
+   * Here we initialize init_done, otherwise jhelper does not work.
+   * Therefore, copyin_offset() statements work multiple times now.
+   * There is a hope we could avoid it in the future, and so,
+   * this initialization can be removed.
+   */
+  init_done  = 0;
+  this->error = (char *) NULL;
+  this->result = (char *) NULL;
+  this->methodOop = 0;
+  this->codecache = 0;
+  this->klass = (pointer) NULL;
+  this->vtbl  = (pointer) NULL;
+  this->suffix = '\0';
+}
+
+dtrace:helper:ustack:
+{
+  MARK_LINE;
+  /* Initialization of JvmOffsets constants */
+  JvmOffsetsPtr = (pointer) &``__JvmOffsets;
+}
+
+dtrace:helper:ustack:
+/!init_done && !this->done/
+{
+  MARK_LINE;
+  init_done = 1;
+
+  copyin_offset(COMPILER);
+  copyin_offset(OFFSET_CollectedHeap_reserved);
+  copyin_offset(OFFSET_MemRegion_start);
+  copyin_offset(OFFSET_MemRegion_word_size);
+  copyin_offset(SIZE_HeapWord);
+
+  copyin_offset(OFFSET_interpreter_frame_method);
+  copyin_offset(OFFSET_Klass_name);
+  copyin_offset(OFFSET_constantPoolOopDesc_pool_holder);
+
+  copyin_offset(OFFSET_HeapBlockHeader_used);
+  copyin_offset(OFFSET_oopDesc_metadata);
+
+  copyin_offset(OFFSET_Symbol_length);
+  copyin_offset(OFFSET_Symbol_body);
+
+  copyin_offset(OFFSET_methodOopDesc_constMethod);
+  copyin_offset(OFFSET_methodOopDesc_constants);
+  copyin_offset(OFFSET_constMethodOopDesc_name_index);
+  copyin_offset(OFFSET_constMethodOopDesc_signature_index);
+
+  copyin_offset(OFFSET_CodeHeap_memory);
+  copyin_offset(OFFSET_CodeHeap_segmap);
+  copyin_offset(OFFSET_CodeHeap_log2_segment_size);
+
+  copyin_offset(OFFSET_VirtualSpace_low);
+  copyin_offset(OFFSET_VirtualSpace_high);
+
+  copyin_offset(OFFSET_CodeBlob_name);
+
+  copyin_offset(OFFSET_nmethod_method);
+  copyin_offset(SIZE_HeapBlockHeader);
+  copyin_offset(SIZE_oopDesc);
+  copyin_offset(SIZE_constantPoolOopDesc);
+
+  copyin_offset(OFFSET_NarrowOopStruct_base);
+  copyin_offset(OFFSET_NarrowOopStruct_shift);
+
+  /*
+   * The PC to translate is in arg0.
+   */
+  this->pc = arg0;
+
+  /*
+   * The methodOopPtr is in %l2 on SPARC.  This can be found at
+   * offset 8 from the frame pointer on 32-bit processes.
+   */
+#if   defined(__sparc)
+  this->methodOopPtr = copyin_ptr(arg1 + 2 * sizeof(pointer) + STACK_BIAS);
+#elif defined(__i386) || defined(__amd64)
+  this->methodOopPtr = copyin_ptr(arg1 + OFFSET_interpreter_frame_method);
+#else
+#error "Don't know architecture"
+#endif
+
+  this->Universe_methodKlassOop = copyin_ptr(&``__1cIUniverseP_methodKlassObj_);
+  this->CodeCache_heap_address = copyin_ptr(&``__1cJCodeCacheF_heap_);
+
+  /* Reading volatile values */
+#ifdef _LP64
+  this->Use_Compressed_Oops  = copyin_uint8(&``UseCompressedOops);
+#else
+  this->Use_Compressed_Oops  = 0;
+#endif
+
+  this->Universe_narrow_oop_base  = copyin_ptr(&``__1cIUniverseL_narrow_oop_ +
+                                               OFFSET_NarrowOopStruct_base);
+  this->Universe_narrow_oop_shift = copyin_int32(&``__1cIUniverseL_narrow_oop_ +
+                                                 OFFSET_NarrowOopStruct_shift);
+
+  this->CodeCache_low = copyin_ptr(this->CodeCache_heap_address + 
+      OFFSET_CodeHeap_memory + OFFSET_VirtualSpace_low);
+
+  this->CodeCache_high = copyin_ptr(this->CodeCache_heap_address +
+      OFFSET_CodeHeap_memory + OFFSET_VirtualSpace_high);
+
+  this->CodeCache_segmap_low = copyin_ptr(this->CodeCache_heap_address +
+      OFFSET_CodeHeap_segmap + OFFSET_VirtualSpace_low);
+
+  this->CodeCache_segmap_high = copyin_ptr(this->CodeCache_heap_address +
+      OFFSET_CodeHeap_segmap + OFFSET_VirtualSpace_high);
+
+  this->CodeHeap_log2_segment_size = copyin_uint32(
+      this->CodeCache_heap_address + OFFSET_CodeHeap_log2_segment_size);
+
+  /*
+   * Get Java heap bounds
+   */
+  this->Universe_collectedHeap = copyin_ptr(&``__1cIUniverseO_collectedHeap_);
+  this->heap_start = copyin_ptr(this->Universe_collectedHeap +
+      OFFSET_CollectedHeap_reserved +
+      OFFSET_MemRegion_start);
+  this->heap_size = SIZE_HeapWord *
+    copyin_ptr(this->Universe_collectedHeap +
+        OFFSET_CollectedHeap_reserved +
+        OFFSET_MemRegion_word_size
+        );
+  this->heap_end = this->heap_start + this->heap_size;
+}
+
+dtrace:helper:ustack:
+/!this->done &&
+this->CodeCache_low <= this->pc && this->pc < this->CodeCache_high/
+{
+  MARK_LINE;
+  this->codecache = 1;
+
+  /*
+   * Find start.
+   */
+  this->segment = (this->pc - this->CodeCache_low) >>
+    this->CodeHeap_log2_segment_size;
+  this->block = this->CodeCache_segmap_low;
+  this->tag = copyin_uchar(this->block + this->segment);
+  "second";
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache && this->tag > 0/
+{
+  MARK_LINE;
+  this->tag = copyin_uchar(this->block + this->segment);
+  this->segment = this->segment - this->tag;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache && this->tag > 0/
+{
+  MARK_LINE;
+  this->tag = copyin_uchar(this->block + this->segment);
+  this->segment = this->segment - this->tag;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache && this->tag > 0/
+{
+  MARK_LINE;
+  this->tag = copyin_uchar(this->block + this->segment);
+  this->segment = this->segment - this->tag;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache && this->tag > 0/
+{
+  MARK_LINE;
+  this->tag = copyin_uchar(this->block + this->segment);
+  this->segment = this->segment - this->tag;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache && this->tag > 0/
+{
+  MARK_LINE;
+  this->tag = copyin_uchar(this->block + this->segment);
+  this->segment = this->segment - this->tag;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache && this->tag > 0/
+{
+  MARK_LINE;
+  this->error = "<couldn't find start>";
+  this->done = 1;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache/
+{
+  MARK_LINE;
+  this->block = this->CodeCache_low +
+    (this->segment << this->CodeHeap_log2_segment_size);
+  this->used = copyin_uint32(this->block + OFFSET_HeapBlockHeader_used);
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache && !this->used/
+{
+  MARK_LINE;
+  this->error = "<block not in use>";
+  this->done = 1;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache/
+{
+  MARK_LINE;
+  this->start = this->block + SIZE_HeapBlockHeader;
+  this->vtbl = copyin_ptr(this->start);
+
+  this->nmethod_vtbl            = (pointer) &``__1cHnmethodG__vtbl_;
+  this->BufferBlob_vtbl         = (pointer) &``__1cKBufferBlobG__vtbl_;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->vtbl == this->nmethod_vtbl/
+{
+  MARK_LINE;
+  this->methodOopPtr = copyin_ptr(this->start + OFFSET_nmethod_method);
+  this->suffix = '*';
+  this->methodOop = 1;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->vtbl == this->BufferBlob_vtbl/
+{
+  MARK_LINE;
+  this->name = copyin_ptr(this->start + OFFSET_CodeBlob_name);
+}
+
+dtrace:helper:ustack:
+/!this->done && this->vtbl == this->BufferBlob_vtbl &&
+this->Use_Compressed_Oops == 0 &&
+this->methodOopPtr > this->heap_start && this->methodOopPtr < this->heap_end/
+{
+  MARK_LINE;
+  this->klass = copyin_ptr(this->methodOopPtr + OFFSET_oopDesc_metadata);
+  this->methodOop = this->klass == this->Universe_methodKlassOop;
+  this->done = !this->methodOop;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->vtbl == this->BufferBlob_vtbl &&
+this->Use_Compressed_Oops != 0 &&
+this->methodOopPtr > this->heap_start && this->methodOopPtr < this->heap_end/
+{
+  MARK_LINE;
+  /*
+   * Read compressed pointer and  decode heap oop, same as oop.inline.hpp
+   */
+  this->cklass = copyin_uint32(this->methodOopPtr + OFFSET_oopDesc_metadata);
+  this->klass = (uint64_t)((uintptr_t)this->Universe_narrow_oop_base +
+                ((uintptr_t)this->cklass << this->Universe_narrow_oop_shift));
+  this->methodOop = this->klass == this->Universe_methodKlassOop;
+  this->done = !this->methodOop;
+}
+
+dtrace:helper:ustack:
+/!this->done && !this->methodOop/
+{
+  MARK_LINE;
+  this->name = copyin_ptr(this->start + OFFSET_CodeBlob_name);
+  this->result = this->name != 0 ? copyinstr(this->name) : "<CodeBlob>";
+  this->done = 1;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->methodOop/
+{
+  MARK_LINE;
+  this->constMethod = copyin_ptr(this->methodOopPtr +
+      OFFSET_methodOopDesc_constMethod);
+
+  this->nameIndex = copyin_uint16(this->constMethod +
+      OFFSET_constMethodOopDesc_name_index);
+
+  this->signatureIndex = copyin_uint16(this->constMethod +
+      OFFSET_constMethodOopDesc_signature_index);
+
+  this->constantPool = copyin_ptr(this->methodOopPtr +
+      OFFSET_methodOopDesc_constants);
+
+  this->nameSymbol = copyin_ptr(this->constantPool +
+      this->nameIndex * sizeof (pointer) + SIZE_constantPoolOopDesc);
+
+  this->nameSymbolLength = copyin_uint16(this->nameSymbol +
+      OFFSET_Symbol_length);
+
+  this->signatureSymbol = copyin_ptr(this->constantPool +
+      this->signatureIndex * sizeof (pointer) + SIZE_constantPoolOopDesc);
+
+  this->signatureSymbolLength = copyin_uint16(this->signatureSymbol +
+      OFFSET_Symbol_length);
+
+  this->klassPtr = copyin_ptr(this->constantPool +
+      OFFSET_constantPoolOopDesc_pool_holder);
+
+  this->klassSymbol = copyin_ptr(this->klassPtr +
+      OFFSET_Klass_name + SIZE_oopDesc);
+
+  this->klassSymbolLength = copyin_uint16(this->klassSymbol +
+      OFFSET_Symbol_length);
+
+  /*
+   * Enough for three strings, plus the '.', plus the trailing '\0'.
+   */
+  this->result = (char *) alloca(this->klassSymbolLength +
+      this->nameSymbolLength +
+      this->signatureSymbolLength + 2 + 1);
+
+  copyinto(this->klassSymbol + OFFSET_Symbol_body,
+      this->klassSymbolLength, this->result);
+
+  /*
+   * Add the '.' between the class and the name.
+   */
+  this->result[this->klassSymbolLength] = '.';
+
+  copyinto(this->nameSymbol + OFFSET_Symbol_body,
+      this->nameSymbolLength,
+      this->result + this->klassSymbolLength + 1);
+
+  copyinto(this->signatureSymbol + OFFSET_Symbol_body,
+      this->signatureSymbolLength,
+      this->result + this->klassSymbolLength +
+      this->nameSymbolLength + 1);
+
+  /*
+   * Now we need to add a trailing '\0' and possibly a tag character.
+   */
+  this->result[this->klassSymbolLength + 1 + 
+      this->nameSymbolLength +
+      this->signatureSymbolLength] = this->suffix;
+  this->result[this->klassSymbolLength + 2 + 
+      this->nameSymbolLength +
+      this->signatureSymbolLength] = '\0';
+
+  this->done = 1;
+}
+
+dtrace:helper:ustack:
+/this->done && this->error == (char *) NULL/
+{
+  this->result;   
+}
+
+dtrace:helper:ustack:
+/this->done && this->error != (char *) NULL/
+{
+  this->error;
+}
+
+dtrace:helper:ustack:
+/!this->done && this->codecache/
+{
+  this->done = 1;
+  "error";
+}
+
+
+dtrace:helper:ustack:
+/!this->done/
+{
+  NULL;
+}
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/jvm_dtrace.c openjdk/hotspot/src/os/bsd/dtrace/jvm_dtrace.c
--- openjdk.orig/hotspot/src/os/bsd/dtrace/jvm_dtrace.c	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/jvm_dtrace.c	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,565 @@
+/*
+ * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include <door.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <poll.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <thread.h>
+#include <unistd.h>
+#include "jvm_dtrace.h"
+
+// NOTE: These constants are used in JVM code as well.
+// KEEP JVM CODE IN SYNC if you are going to change these...
+
+#define DTRACE_ALLOC_PROBES   0x1
+#define DTRACE_METHOD_PROBES  0x2
+#define DTRACE_MONITOR_PROBES 0x4
+#define DTRACE_ALL_PROBES     -1
+
+// generic error messages
+#define JVM_ERR_OUT_OF_MEMORY            "out of memory (native heap)"
+#define JVM_ERR_INVALID_PARAM            "invalid input parameter(s)"
+#define JVM_ERR_NULL_PARAM               "input paramater is NULL"
+
+// error messages for attach
+#define JVM_ERR_CANT_OPEN_DOOR           "cannot open door file"
+#define JVM_ERR_CANT_CREATE_ATTACH_FILE  "cannot create attach file"
+#define JVM_ERR_DOOR_FILE_PERMISSION     "door file is not secure"
+#define JVM_ERR_CANT_SIGNAL              "cannot send SIGQUIT to target"
+
+// error messages for enable probe
+#define JVM_ERR_DOOR_CMD_SEND            "door command send failed"
+#define JVM_ERR_DOOR_CANT_READ_STATUS    "cannot read door command status"
+#define JVM_ERR_DOOR_CMD_STATUS          "door command error status"
+
+// error message for detach
+#define JVM_ERR_CANT_CLOSE_DOOR          "cannot close door file"
+
+#define RESTARTABLE(_cmd, _result) do { \
+    do { \
+        _result = _cmd; \
+    } while((_result == -1) && (errno == EINTR)); \
+} while(0)
+
+struct _jvm_t {
+    pid_t pid;
+    int door_fd;
+};
+
+static int libjvm_dtrace_debug;
+static void print_debug(const char* fmt,...) {
+    if (libjvm_dtrace_debug) {
+        va_list alist;
+        va_start(alist, fmt);
+        fputs("libjvm_dtrace DEBUG: ", stderr);
+        vfprintf(stderr, fmt, alist);
+        va_end(alist);
+    }
+}
+
+/* Key for thread local error message */
+static thread_key_t jvm_error_key;
+
+/* init function for this library */
+static void init_jvm_dtrace() {
+    /* check for env. var for debug mode */
+    libjvm_dtrace_debug = getenv("LIBJVM_DTRACE_DEBUG") != NULL;
+    /* create key for thread local error message */
+    if (thr_keycreate(&jvm_error_key, NULL) != 0) {
+        print_debug("can't create thread_key_t for jvm error key\n");
+        // exit(1); ?
+    }
+}
+
+#pragma init(init_jvm_dtrace)
+
+/* set thread local error message */
+static void set_jvm_error(const char* msg) {
+    thr_setspecific(jvm_error_key, (void*)msg);
+}
+
+/* clear thread local error message */
+static void clear_jvm_error() {
+    thr_setspecific(jvm_error_key, NULL);
+}
+
+/* file handling functions that can handle interrupt */
+
+static int file_open(const char* path, int flag) {
+    int ret;
+    RESTARTABLE(open(path, flag), ret);
+    return ret;
+}
+
+static int file_close(int fd) {
+    int ret;
+    RESTARTABLE(close(fd), ret);
+    return ret;
+}
+
+static int file_read(int fd, char* buf, int len) {
+    int ret;
+    RESTARTABLE(read(fd, buf, len), ret);
+    return ret;
+}
+
+/* send SIGQUIT signal to given process */
+static int send_sigquit(pid_t pid) {
+    int ret;
+    RESTARTABLE(kill(pid, SIGQUIT), ret);
+    return ret;
+}
+
+/* called to check permissions on attach file */
+static int check_permission(const char* path) {
+    struct stat64 sb;
+    uid_t uid, gid;
+    int res;
+
+    /*
+     * Check that the path is owned by the effective uid/gid of this
+     * process. Also check that group/other access is not allowed.
+     */
+    uid = geteuid();
+    gid = getegid();
+
+    res = stat64(path, &sb);
+    if (res != 0) {
+        print_debug("stat failed for %s\n", path);
+        return -1;
+    }
+
+    if ((sb.st_uid != uid) || (sb.st_gid != gid) ||
+        ((sb.st_mode & (S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)) != 0)) {
+        print_debug("well-known file %s is not secure\n", path);
+        return -1;
+    }
+    return 0;
+}
+
+#define ATTACH_FILE_PATTERN "/tmp/.attach_pid%d"
+
+/* fill-in the name of attach file name in given buffer */
+static void fill_attach_file_name(char* path, int len, pid_t pid) {
+    memset(path, 0, len);
+    sprintf(path, ATTACH_FILE_PATTERN, pid);
+}
+
+#define DOOR_FILE_PATTERN "/tmp/.java_pid%d"
+
+/* open door file for the given JVM */
+static int open_door(pid_t pid) {
+    char path[PATH_MAX + 1];
+    int fd;
+
+    sprintf(path, DOOR_FILE_PATTERN, pid);
+    fd = file_open(path, O_RDONLY);
+    if (fd < 0) {
+        set_jvm_error(JVM_ERR_CANT_OPEN_DOOR);
+        print_debug("cannot open door file %s\n", path);
+        return -1;
+    }
+    print_debug("opened door file %s\n", path);
+    if (check_permission(path) != 0) {
+        set_jvm_error(JVM_ERR_DOOR_FILE_PERMISSION);
+        print_debug("check permission failed for %s\n", path);
+        file_close(fd);
+        fd = -1;
+    }
+    return fd;
+}
+
+/* create attach file for given process */
+static int create_attach_file(pid_t pid) {
+    char path[PATH_MAX + 1];
+    int fd;
+    fill_attach_file_name(path, sizeof(path), pid);
+    fd = file_open(path, O_CREAT | O_RDWR);
+    if (fd < 0) {
+        set_jvm_error(JVM_ERR_CANT_CREATE_ATTACH_FILE);
+        print_debug("cannot create file %s\n", path);
+    } else {
+        print_debug("created attach file %s\n", path);
+    }
+    return fd;
+}
+
+/* delete attach file for given process */
+static void delete_attach_file(pid_t pid) {
+    char path[PATH_MAX + 1];
+    fill_attach_file_name(path, sizeof(path), pid);
+    int res = unlink(path);
+    if (res) {
+        print_debug("cannot delete attach file %s\n", path);
+    } else {
+        print_debug("deleted attach file %s\n", path);
+    }
+}
+
+/* attach to given JVM */
+jvm_t* jvm_attach(pid_t pid) {
+    jvm_t* jvm;
+    int door_fd, attach_fd, i;
+
+    jvm = (jvm_t*) calloc(1, sizeof(jvm_t));
+    if (jvm == NULL) {
+        set_jvm_error(JVM_ERR_OUT_OF_MEMORY);
+        print_debug("calloc failed in %s at %d\n", __FILE__, __LINE__);
+        return NULL;
+    }
+    jvm->pid = pid;
+    attach_fd = -1;
+
+    door_fd = open_door(pid);
+    if (door_fd < 0) {
+        print_debug("trying to create attach file\n");
+        if ((attach_fd = create_attach_file(pid)) < 0) {
+            goto quit;
+        }
+
+        /* send QUIT signal to the target so that it will
+         * check for the attach file.
+         */
+        if (send_sigquit(pid) != 0) {
+            set_jvm_error(JVM_ERR_CANT_SIGNAL);
+            print_debug("sending SIGQUIT failed\n");
+            goto quit;
+        }
+
+        /* give the target VM time to start the attach mechanism */
+        do {
+            int res;
+            RESTARTABLE(poll(0, 0, 200), res);
+            door_fd = open_door(pid);
+            i++;
+        } while (i <= 50 && door_fd == -1);
+        if (door_fd < 0) {
+            print_debug("Unable to open door to process %d\n", pid);
+            goto quit;
+        }
+    }
+
+quit:
+    if (attach_fd >= 0) {
+        file_close(attach_fd);
+        delete_attach_file(jvm->pid);
+    }
+    if (door_fd >= 0) {
+        jvm->door_fd = door_fd;
+        clear_jvm_error();
+    } else {
+        free(jvm);
+        jvm = NULL;
+    }
+    return jvm;
+}
+
+/* return the last thread local error message */
+const char* jvm_get_last_error() {
+    const char* res = NULL;
+    thr_getspecific(jvm_error_key, (void**)&res);
+    return res;
+}
+
+/* detach the givenb JVM */
+int jvm_detach(jvm_t* jvm) {
+    if (jvm) {
+        int res;
+        if (jvm->door_fd != -1) {
+            if (file_close(jvm->door_fd) != 0) {
+                set_jvm_error(JVM_ERR_CANT_CLOSE_DOOR);
+                res = -1;
+            } else {
+                clear_jvm_error();
+                res = 0;
+            }
+        }
+        free(jvm);
+        return res;
+    } else {
+        set_jvm_error(JVM_ERR_NULL_PARAM);
+        print_debug("jvm_t* is NULL\n");
+        return -1;
+    }
+}
+
+/*
+ * A simple table to translate some known errors into reasonable
+ * error messages
+ */
+static struct {
+    int err;
+    const char* msg;
+} const error_messages[] = {
+    { 100,      "Bad request" },
+    { 101,      "Protocol mismatch" },
+    { 102,      "Resource failure" },
+    { 103,      "Internal error" },
+    { 104,      "Permission denied" },
+};
+
+/*
+ * Lookup the given error code and return the appropriate
+ * message. If not found return NULL.
+ */
+static const char* translate_error(int err) {
+    int table_size = sizeof(error_messages) / sizeof(error_messages[0]);
+    int i;
+
+    for (i=0; i<table_size; i++) {
+        if (err == error_messages[i].err) {
+            return error_messages[i].msg;
+        }
+    }
+    return NULL;
+}
+
+/*
+ * Current protocol version
+ */
+static const char* PROTOCOL_VERSION = "1";
+
+#define RES_BUF_SIZE 128
+
+/*
+ * Enqueue attach-on-demand command to the given JVM
+ */
+static
+int enqueue_command(jvm_t* jvm, const char* cstr, int arg_count, const char** args) {
+    size_t size;
+    door_arg_t door_args;
+    char res_buffer[RES_BUF_SIZE];
+    int rc, i;
+    char* buf = NULL;
+    int result = -1;
+
+    /*
+     * First we get the command string and create the start of the
+     * argument string to send to the target VM:
+     * <ver>\0<cmd>\0
+     */
+    if (cstr == NULL) {
+        print_debug("command name is NULL\n");
+        goto quit;
+    }
+    size = strlen(PROTOCOL_VERSION) + strlen(cstr) + 2;
+    buf = (char*)malloc(size);
+    if (buf != NULL) {
+        char* pos = buf;
+        strcpy(buf, PROTOCOL_VERSION);
+        pos += strlen(PROTOCOL_VERSION)+1;
+        strcpy(pos, cstr);
+    } else {
+        set_jvm_error(JVM_ERR_OUT_OF_MEMORY);
+        print_debug("malloc failed at %d in %s\n", __LINE__, __FILE__);
+        goto quit;
+    }
+
+    /*
+     * Next we iterate over the arguments and extend the buffer
+     * to include them.
+     */
+    for (i=0; i<arg_count; i++) {
+        cstr = args[i];
+        if (cstr != NULL) {
+            size_t len = strlen(cstr);
+            char* newbuf = (char*)realloc(buf, size+len+1);
+            if (newbuf == NULL) {
+                set_jvm_error(JVM_ERR_OUT_OF_MEMORY);
+                print_debug("realloc failed in %s at %d\n", __FILE__, __LINE__);
+                goto quit;
+            }
+            buf = newbuf;
+            strcpy(buf+size, cstr);
+            size += len+1;
+        }
+    }
+
+    /*
+     * The arguments to the door function are in 'buf' so we now
+     * do the door call
+     */
+    door_args.data_ptr = buf;
+    door_args.data_size = size;
+    door_args.desc_ptr = NULL;
+    door_args.desc_num = 0;
+    door_args.rbuf = (char*)&res_buffer;
+    door_args.rsize = sizeof(res_buffer);
+
+    RESTARTABLE(door_call(jvm->door_fd, &door_args), rc);
+
+    /*
+     * door_call failed
+     */
+    if (rc == -1) {
+        print_debug("door_call failed\n");
+    } else {
+        /*
+         * door_call succeeded but the call didn't return the the expected jint.
+         */
+        if (door_args.data_size < sizeof(int)) {
+            print_debug("Enqueue error - reason unknown as result is truncated!");
+        } else {
+            int* res = (int*)(door_args.data_ptr);
+            if (*res != 0) {
+                const char* msg = translate_error(*res);
+                if (msg == NULL) {
+                    print_debug("Unable to enqueue command to target VM: %d\n", *res);
+                } else {
+                    print_debug("Unable to enqueue command to target VM: %s\n", msg);
+                }
+            } else {
+                /*
+                 * The door call should return a file descriptor to one end of
+                 * a socket pair
+                 */
+                if ((door_args.desc_ptr != NULL) &&
+                    (door_args.desc_num == 1) &&
+                    (door_args.desc_ptr->d_attributes & DOOR_DESCRIPTOR)) {
+                    result = door_args.desc_ptr->d_data.d_desc.d_descriptor;
+                } else {
+                    print_debug("Reply from enqueue missing descriptor!\n");
+                }
+            }
+        }
+    }
+
+quit:
+    if (buf) free(buf);
+    return result;
+}
+
+/* read status code for a door command */
+static int read_status(int fd) {
+    char ch, buf[16];
+    int index = 0;
+
+    while (1) {
+        if (file_read(fd, &ch, sizeof(ch)) != sizeof(ch)) {
+            set_jvm_error(JVM_ERR_DOOR_CANT_READ_STATUS);
+            print_debug("door cmd status: read status failed\n");
+            return -1;
+        }
+        buf[index++] = ch;
+        if (ch == '\n') {
+            buf[index - 1] = '\0';
+            return atoi(buf);
+        }
+        if (index == sizeof(buf)) {
+            set_jvm_error(JVM_ERR_DOOR_CANT_READ_STATUS);
+            print_debug("door cmd status: read status overflow\n");
+            return -1;
+        }
+    }
+}
+
+static const char* ENABLE_DPROBES_CMD = "enabledprobes";
+
+/* enable one or more DTrace probes for a given JVM */
+int jvm_enable_dtprobes(jvm_t* jvm, int num_probe_types, const char** probe_types) {
+    int fd, status = 0;
+    char ch;
+    const char* args[1];
+    char buf[16];
+    int probe_type = 0, index;
+    int count = 0;
+
+    if (jvm == NULL) {
+        set_jvm_error(JVM_ERR_NULL_PARAM);
+        print_debug("jvm_t* is NULL\n");
+        return -1;
+    }
+
+    if (num_probe_types == 0 || probe_types == NULL ||
+        probe_types[0] == NULL) {
+        set_jvm_error(JVM_ERR_INVALID_PARAM);
+        print_debug("invalid probe type argument(s)\n");
+        return -1;
+    }
+
+    for (index = 0; index < num_probe_types; index++) {
+        const char* p = probe_types[index];
+        if (strcmp(p, JVM_DTPROBE_OBJECT_ALLOC) == 0) {
+            probe_type |= DTRACE_ALLOC_PROBES;
+            count++;
+        } else if (strcmp(p, JVM_DTPROBE_METHOD_ENTRY) == 0 ||
+                   strcmp(p, JVM_DTPROBE_METHOD_RETURN) == 0) {
+            probe_type |= DTRACE_METHOD_PROBES;
+            count++;
+        } else if (strcmp(p, JVM_DTPROBE_MONITOR_ENTER) == 0   ||
+                   strcmp(p, JVM_DTPROBE_MONITOR_ENTERED) == 0 ||
+                   strcmp(p, JVM_DTPROBE_MONITOR_EXIT) == 0    ||
+                   strcmp(p, JVM_DTPROBE_MONITOR_WAIT) == 0    ||
+                   strcmp(p, JVM_DTPROBE_MONITOR_WAITED) == 0  ||
+                   strcmp(p, JVM_DTPROBE_MONITOR_NOTIFY) == 0  ||
+                   strcmp(p, JVM_DTPROBE_MONITOR_NOTIFYALL) == 0) {
+            probe_type |= DTRACE_MONITOR_PROBES;
+            count++;
+        } else if (strcmp(p, JVM_DTPROBE_ALL) == 0) {
+            probe_type |= DTRACE_ALL_PROBES;
+            count++;
+        }
+    }
+
+    if (count == 0) {
+        return count;
+    }
+    sprintf(buf, "%d", probe_type);
+    args[0] = buf;
+
+    fd = enqueue_command(jvm, ENABLE_DPROBES_CMD, 1, args);
+    if (fd < 0) {
+        set_jvm_error(JVM_ERR_DOOR_CMD_SEND);
+        return -1;
+    }
+
+    status = read_status(fd);
+    // non-zero status is error
+    if (status) {
+        set_jvm_error(JVM_ERR_DOOR_CMD_STATUS);
+        print_debug("%s command failed (status: %d) in target JVM\n",
+                    ENABLE_DPROBES_CMD, status);
+        file_close(fd);
+        return -1;
+    }
+    // read from stream until EOF
+    while (file_read(fd, &ch, sizeof(ch)) == sizeof(ch)) {
+        if (libjvm_dtrace_debug) {
+            printf("%c", ch);
+        }
+    }
+
+    file_close(fd);
+    clear_jvm_error();
+    return count;
+}
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/jvm_dtrace.h openjdk/hotspot/src/os/bsd/dtrace/jvm_dtrace.h
--- openjdk.orig/hotspot/src/os/bsd/dtrace/jvm_dtrace.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/jvm_dtrace.h	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef _JVM_DTRACE_H_
+#define _JVM_DTRACE_H_
+
+/*
+ * Interface to dynamically turn on probes in Hotspot JVM. Currently,
+ * this interface can be used to dynamically enable certain DTrace
+ * probe points that are costly to have "always on".
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+struct _jvm_t;
+typedef struct _jvm_t jvm_t;
+
+
+/* Attach to the given JVM process. Returns NULL on failure.
+   jvm_get_last_error() returns last error message. */
+jvm_t* jvm_attach(pid_t pid);
+
+/* Returns the last error message from this library or NULL if none. */
+const char* jvm_get_last_error();
+
+/* few well-known probe type constants for 'probe_types' param below */
+
+#define JVM_DTPROBE_METHOD_ENTRY         "method-entry"
+#define JVM_DTPROBE_METHOD_RETURN        "method-return"
+#define JVM_DTPROBE_MONITOR_ENTER        "monitor-contended-enter"
+#define JVM_DTPROBE_MONITOR_ENTERED      "monitor-contended-entered"
+#define JVM_DTPROBE_MONITOR_EXIT         "monitor-contended-exit"
+#define JVM_DTPROBE_MONITOR_WAIT         "monitor-wait"
+#define JVM_DTPROBE_MONITOR_WAITED       "monitor-waited"
+#define JVM_DTPROBE_MONITOR_NOTIFY       "monitor-notify"
+#define JVM_DTPROBE_MONITOR_NOTIFYALL    "monitor-notifyall"
+#define JVM_DTPROBE_OBJECT_ALLOC         "object-alloc"
+#define JVM_DTPROBE_ALL                  "*"
+
+/* Enable the specified DTrace probes of given probe types on
+ * the specified JVM. Returns >= 0 on success, -1 on failure.
+ * On success, this returns number of probe_types enabled.
+ * On failure, jvm_get_last_error() returns the last error message.
+ */
+int jvm_enable_dtprobes(jvm_t* jvm, int num_probe_types, const char** probe_types);
+
+/* Note: There is no jvm_disable_dtprobes function. Probes are automatically
+ * disabled when there are no more clients requiring those probes.
+ */
+
+/* Detach the given JVM. Returns 0 on success, -1 on failure.
+ * jvm_get_last_error() returns the last error message.
+ */
+int jvm_detach(jvm_t* jvm);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _JVM_DTRACE_H_ */
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/libjvm_db.c openjdk/hotspot/src/os/bsd/dtrace/libjvm_db.c
--- openjdk.orig/hotspot/src/os/bsd/dtrace/libjvm_db.c	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/libjvm_db.c	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,1548 @@
+/*
+ * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+// not available on macosx #include <gelf.h>
+
+#include "libjvm_db.h"
+#include "JvmOffsets.h"
+
+#define LIBJVM_SO "libjvm.so"
+
+#if defined(i386) || defined(__i386) || defined(__amd64)
+#ifdef COMPILER2
+#define X86_COMPILER2
+#endif /* COMPILER2 */
+#endif /* i386 */
+
+typedef struct {
+    short     vf_cnt; /* number of recognized java vframes */
+    short     bci;    /* current frame method byte code index */
+    int       line;   /* current frame method source line */
+    uint64_t new_fp; /* fp for the next frame */
+    uint64_t new_pc; /* pc for the next frame */
+    uint64_t new_sp; /* "raw" sp for the next frame (includes extension by interpreter/adapter */
+    char      locinf; /* indicates there is valid location info */
+} Jframe_t;
+
+int Jlookup_by_regs(jvm_agent_t* J, const prgregset_t regs, char *name,
+                    size_t size, Jframe_t *jframe);
+
+int main(int arg) { return arg; }
+
+static int debug = 0;
+
+static void failed(int err, const char * file, int line) {
+  if (debug) {
+    fprintf(stderr, "failed %d at %s:%d\n", err, file, line);
+  }
+}
+
+static void warn(const char * file, int line, const char * msg) {
+  if (debug) {
+    fprintf(stderr, "warning: %s at %s:%d\n", msg, file, line);
+  }
+}
+
+static void warn1(const char * file, int line, const char * msg, intptr_t arg1) {
+  if (debug) {
+    fprintf(stderr, "warning: ");
+    fprintf(stderr, msg, arg1);
+    fprintf(stderr, " at %s:%d\n", file, line);
+  }
+}
+
+#define CHECK_FAIL(err) \
+        if (err != PS_OK) { failed(err, __FILE__, __LINE__); goto fail; }
+#define WARN(msg)  warn(__FILE__, __LINE__, msg)
+#define WARN1(msg, arg1)  warn1(__FILE__, __LINE__, msg, arg1)
+
+typedef struct VMStructEntry {
+  const char * typeName;           /* The type name containing the given field (example: "Klass") */
+  const char * fieldName;          /* The field name within the type           (example: "_name") */
+  uint64_t address;                /* Address of field; only used for static fields */
+                                   /* ("offset" can not be reused because of apparent SparcWorks compiler bug */
+                                   /* in generation of initializer data) */
+} VMStructEntry;
+
+/* Prototyping inlined methods */
+
+int sprintf(char *s, const char *format, ...);
+
+#define SZ16  sizeof(int16_t)
+#define SZ32  sizeof(int32_t)
+
+#define COMP_METHOD_SIGN '*'
+
+#define MAX_VFRAMES_CNT 256
+
+typedef struct vframe {
+  uint64_t methodOop;
+  int32_t  sender_decode_offset;
+  int32_t  methodIdx;
+  int32_t  bci;
+  int32_t  line;
+} Vframe_t;
+
+typedef struct frame {
+  uintptr_t fp;
+  uintptr_t pc;
+  uintptr_t sp;
+  uintptr_t sender_sp; // The unextended sp of the caller
+} Frame_t;
+
+typedef struct Nmethod_t {
+  struct jvm_agent* J;
+  Jframe_t *jframe;
+
+  uint64_t nm;                  /* _nmethod */
+  uint64_t pc;
+  uint64_t pc_desc;
+
+  int32_t  orig_pc_offset;      /* _orig_pc_offset */
+  int32_t  instrs_beg;          /* _code_offset */
+  int32_t  instrs_end;
+  int32_t  deopt_beg;           /* _deoptimize_offset */
+  int32_t  scopes_data_beg;     /* _scopes_data_offset */
+  int32_t  scopes_data_end;
+  int32_t  oops_beg;            /* _oops_offset */
+  int32_t  oops_end;
+  int32_t  scopes_pcs_beg;      /* _scopes_pcs_offset */
+  int32_t  scopes_pcs_end;
+
+  int      vf_cnt;
+  Vframe_t vframes[MAX_VFRAMES_CNT];
+} Nmethod_t;
+
+struct jvm_agent {
+  struct ps_prochandle* P;
+
+  uint64_t nmethod_vtbl;
+  uint64_t CodeBlob_vtbl;
+  uint64_t BufferBlob_vtbl;
+  uint64_t RuntimeStub_vtbl;
+
+  uint64_t Use_Compressed_Oops_address;
+  uint64_t Universe_methodKlassObj_address;
+  uint64_t Universe_narrow_oop_base_address;
+  uint64_t Universe_narrow_oop_shift_address;
+  uint64_t CodeCache_heap_address;
+
+  /* Volatiles */
+  uint8_t  Use_Compressed_Oops;
+  uint64_t Universe_methodKlassObj;
+  uint64_t Universe_narrow_oop_base;
+  uint32_t Universe_narrow_oop_shift;
+  uint64_t CodeCache_low;
+  uint64_t CodeCache_high;
+  uint64_t CodeCache_segmap_low;
+  uint64_t CodeCache_segmap_high;
+
+  int32_t  SIZE_CodeCache_log2_segment;
+
+  uint64_t methodOopPtr;
+  uint64_t bcx;
+
+  Nmethod_t *N;                 /*Inlined methods support */
+  Frame_t   prev_fr;
+  Frame_t   curr_fr;
+};
+
+static int
+read_string(struct ps_prochandle *P,
+        char *buf,              /* caller's buffer */
+        size_t size,            /* upper limit on bytes to read */
+        uintptr_t addr)         /* address in process */
+{
+  int err = PS_OK;
+  while (size-- > 1 && err == PS_OK) {
+    err = ps_pread(P, addr, buf, 1);
+    if (*buf == '\0') {
+      return PS_OK;
+    }
+    addr += 1;
+    buf += 1;
+  }
+  return -1;
+}
+
+static int read_compressed_pointer(jvm_agent_t* J, uint64_t base, uint32_t *ptr) {
+  int err = -1;
+  uint32_t ptr32;
+  err = ps_pread(J->P, base, &ptr32, sizeof(uint32_t));
+  *ptr = ptr32;
+  return err;
+}
+
+static int read_pointer(jvm_agent_t* J, uint64_t base, uint64_t* ptr) {
+  int err = -1;
+  uint32_t ptr32;
+
+  switch (DATA_MODEL) {
+  case PR_MODEL_LP64:
+    err = ps_pread(J->P, base, ptr, sizeof(uint64_t));
+    break;
+  case PR_MODEL_ILP32:
+    err = ps_pread(J->P, base, &ptr32, sizeof(uint32_t));
+    *ptr = ptr32;
+    break;
+  }
+
+  return err;
+}
+
+static int read_string_pointer(jvm_agent_t* J, uint64_t base, const char ** stringp) {
+  uint64_t ptr;
+  int err;
+  char buffer[1024];
+
+  *stringp = NULL;
+  err = read_pointer(J, base, &ptr);
+  CHECK_FAIL(err);
+  if (ptr != 0) {
+    err = read_string(J->P, buffer, sizeof(buffer), ptr);
+    CHECK_FAIL(err);
+    *stringp = strdup(buffer);
+  }
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+static int parse_vmstruct_entry(jvm_agent_t* J, uint64_t base, VMStructEntry* vmp) {
+  uint64_t ptr;
+  int err;
+
+  err = read_string_pointer(J, base + OFFSET_VMStructEntrytypeName, &vmp->typeName);
+  CHECK_FAIL(err);
+  err = read_string_pointer(J, base + OFFSET_VMStructEntryfieldName, &vmp->fieldName);
+  CHECK_FAIL(err);
+  err = read_pointer(J, base + OFFSET_VMStructEntryaddress, &vmp->address);
+  CHECK_FAIL(err);
+
+  return PS_OK;
+
+ fail:
+  if (vmp->typeName != NULL) free((void*)vmp->typeName);
+  if (vmp->fieldName != NULL) free((void*)vmp->fieldName);
+  return err;
+}
+
+static int parse_vmstructs(jvm_agent_t* J) {
+  VMStructEntry  vmVar;
+  VMStructEntry* vmp = &vmVar;
+  uint64_t gHotSpotVMStructs;
+  psaddr_t sym_addr;
+  uint64_t base;
+  int err;
+
+  err = ps_pglobal_lookup(J->P, LIBJVM_SO, "gHotSpotVMStructs", &sym_addr);
+  CHECK_FAIL(err);
+  err = read_pointer(J, sym_addr, &gHotSpotVMStructs);
+  CHECK_FAIL(err);
+  base = gHotSpotVMStructs;
+
+  err = PS_OK;
+  while (err == PS_OK) {
+    memset(vmp, 0, sizeof(VMStructEntry));
+    err = parse_vmstruct_entry(J, base, vmp);
+    if (err != PS_OK || vmp->typeName == NULL) {
+      break;
+    }
+
+    if (vmp->typeName[0] == 'C' && strcmp("CodeCache", vmp->typeName) == 0) {
+      if (strcmp("_heap", vmp->fieldName) == 0) {
+        err = read_pointer(J, vmp->address, &J->CodeCache_heap_address);
+      }
+    } else if (vmp->typeName[0] == 'U' && strcmp("Universe", vmp->typeName) == 0) {
+      if (strcmp("_methodKlassObj", vmp->fieldName) == 0) {
+        J->Universe_methodKlassObj_address = vmp->address;
+      }
+      if (strcmp("_narrow_oop._base", vmp->fieldName) == 0) {
+        J->Universe_narrow_oop_base_address = vmp->address;
+      }
+      if (strcmp("_narrow_oop._shift", vmp->fieldName) == 0) {
+        J->Universe_narrow_oop_shift_address = vmp->address;
+      }
+    }
+    CHECK_FAIL(err);
+
+    base += SIZE_VMStructEntry;
+    if (vmp->typeName != NULL) free((void*)vmp->typeName);
+    if (vmp->fieldName != NULL) free((void*)vmp->fieldName);
+  }
+
+  return PS_OK;
+
+ fail:
+  if (vmp->typeName != NULL) free((void*)vmp->typeName);
+  if (vmp->fieldName != NULL) free((void*)vmp->fieldName);
+  return -1;
+}
+
+static int find_symbol(jvm_agent_t* J, const char *name, uint64_t* valuep) {
+  psaddr_t sym_addr;
+  int err;
+
+  err = ps_pglobal_lookup(J->P, LIBJVM_SO, name, &sym_addr);
+  if (err != PS_OK) goto fail;
+  *valuep = sym_addr;
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+static int read_volatiles(jvm_agent_t* J) {
+  uint64_t ptr;
+  int err;
+
+  err = find_symbol(J, "UseCompressedOops", &J->Use_Compressed_Oops_address);
+  if (err == PS_OK) {
+    err = ps_pread(J->P,  J->Use_Compressed_Oops_address, &J->Use_Compressed_Oops, sizeof(uint8_t));
+    CHECK_FAIL(err);
+  } else {
+    J->Use_Compressed_Oops = 0;
+  }
+
+  err = read_pointer(J, J->Universe_methodKlassObj_address, &J->Universe_methodKlassObj);
+  CHECK_FAIL(err);
+
+  err = read_pointer(J, J->Universe_narrow_oop_base_address, &J->Universe_narrow_oop_base);
+  CHECK_FAIL(err);
+  err = ps_pread(J->P,  J->Universe_narrow_oop_shift_address, &J->Universe_narrow_oop_shift, sizeof(uint32_t));
+  CHECK_FAIL(err);
+
+  err = read_pointer(J, J->CodeCache_heap_address + OFFSET_CodeHeap_memory +
+                     OFFSET_VirtualSpace_low, &J->CodeCache_low);
+  CHECK_FAIL(err);
+  err = read_pointer(J, J->CodeCache_heap_address + OFFSET_CodeHeap_memory +
+                     OFFSET_VirtualSpace_high, &J->CodeCache_high);
+  CHECK_FAIL(err);
+  err = read_pointer(J, J->CodeCache_heap_address + OFFSET_CodeHeap_segmap +
+                     OFFSET_VirtualSpace_low, &J->CodeCache_segmap_low);
+  CHECK_FAIL(err);
+  err = read_pointer(J, J->CodeCache_heap_address + OFFSET_CodeHeap_segmap +
+                     OFFSET_VirtualSpace_high, &J->CodeCache_segmap_high);
+  CHECK_FAIL(err);
+
+  err = ps_pread(J->P, J->CodeCache_heap_address + OFFSET_CodeHeap_log2_segment_size,
+                 &J->SIZE_CodeCache_log2_segment, sizeof(J->SIZE_CodeCache_log2_segment));
+  CHECK_FAIL(err);
+
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+
+static int codecache_contains(jvm_agent_t* J, uint64_t ptr) {
+  /* make sure the code cache is up to date */
+  return (J->CodeCache_low <= ptr && ptr < J->CodeCache_high);
+}
+
+static uint64_t segment_for(jvm_agent_t* J, uint64_t p) {
+  return (p - J->CodeCache_low) >> J->SIZE_CodeCache_log2_segment;
+}
+
+static uint64_t block_at(jvm_agent_t* J, int i) {
+  return J->CodeCache_low + (i << J->SIZE_CodeCache_log2_segment);
+}
+
+static int find_start(jvm_agent_t* J, uint64_t ptr, uint64_t *startp) {
+  int err;
+
+  *startp = 0;
+  if (J->CodeCache_low <= ptr && ptr < J->CodeCache_high) {
+    int32_t used;
+    uint64_t segment = segment_for(J, ptr);
+    uint64_t block = J->CodeCache_segmap_low;
+    uint8_t tag;
+    err = ps_pread(J->P, block + segment, &tag, sizeof(tag));
+    CHECK_FAIL(err);
+    if (tag == 0xff)
+      return PS_OK;
+    while (tag > 0) {
+      err = ps_pread(J->P, block + segment, &tag, sizeof(tag));
+      CHECK_FAIL(err);
+      segment -= tag;
+    }
+    block = block_at(J, segment);
+    err = ps_pread(J->P, block + OFFSET_HeapBlockHeader_used, &used, sizeof(used));
+    CHECK_FAIL(err);
+    if (used) {
+      *startp = block + SIZE_HeapBlockHeader;
+    }
+  }
+  return PS_OK;
+
+ fail:
+  return -1;
+}
+
+static int find_jlong_constant(jvm_agent_t* J, const char *name, uint64_t* valuep) {
+  psaddr_t sym_addr;
+  int err = ps_pglobal_lookup(J->P, LIBJVM_SO, name, &sym_addr);
+  if (err == PS_OK) {
+    err = ps_pread(J->P, sym_addr, valuep, sizeof(uint64_t));
+    return err;
+  }
+  *valuep = -1;
+  return -1;
+}
+
+jvm_agent_t *Jagent_create(struct ps_prochandle *P, int vers) {
+  jvm_agent_t* J;
+  int err;
+
+  if (vers != JVM_DB_VERSION) {
+    errno = ENOTSUP;
+    return NULL;
+  }
+
+  J = (jvm_agent_t*)calloc(sizeof(struct jvm_agent), 1);
+
+  debug = getenv("LIBJVMDB_DEBUG") != NULL;
+  if (debug) debug = 3;
+
+  if (debug) {
+      fprintf(stderr, "Jagent_create: debug=%d\n", debug);
+#ifdef X86_COMPILER2
+      fprintf(stderr, "Jagent_create: R_SP=%d, R_FP=%d, POINTER_SIZE=%d\n", R_SP, R_FP, POINTER_SIZE);
+#endif  /* X86_COMPILER2 */
+  }
+
+  J->P = P;
+
+  // Initialize the initial previous frame
+
+  J->prev_fr.fp = 0;
+  J->prev_fr.pc = 0;
+  J->prev_fr.sp = 0;
+  J->prev_fr.sender_sp = 0;
+
+  err = find_symbol(J, "__1cHnmethodG__vtbl_", &J->nmethod_vtbl);
+  CHECK_FAIL(err);
+  err = find_symbol(J, "__1cKBufferBlobG__vtbl_", &J->BufferBlob_vtbl);
+  if (err != PS_OK) J->BufferBlob_vtbl = 0;
+  err = find_symbol(J, "__1cICodeBlobG__vtbl_", &J->CodeBlob_vtbl);
+  CHECK_FAIL(err);
+  err = find_symbol(J, "__1cLRuntimeStubG__vtbl_", &J->RuntimeStub_vtbl);
+  CHECK_FAIL(err);
+
+  err = parse_vmstructs(J);
+  CHECK_FAIL(err);
+  err = read_volatiles(J);
+  CHECK_FAIL(err);
+
+  return J;
+
+ fail:
+  Jagent_destroy(J);
+  return NULL;
+}
+
+void Jagent_destroy(jvm_agent_t *J) {
+  if (J != NULL) {
+    free(J);
+  }
+}
+
+static int is_methodOop(jvm_agent_t* J, uint64_t methodOopPtr) {
+  uint64_t klass;
+  int err;
+  // If UseCompressedOops, this was a compressed oop.
+  if (J->Use_Compressed_Oops != 0) {
+    uint32_t cklass;
+    err = read_compressed_pointer(J, methodOopPtr + OFFSET_oopDesc_metadata,
+          &cklass);
+    // decode heap oop, same as oop.inline.hpp
+    klass = (uint64_t)((uintptr_t)J->Universe_narrow_oop_base +
+            ((uintptr_t)cklass << J->Universe_narrow_oop_shift));
+  } else {
+    err = read_pointer(J, methodOopPtr + OFFSET_oopDesc_metadata, &klass);
+  }
+  if (err != PS_OK) goto fail;
+  return klass == J->Universe_methodKlassObj;
+
+ fail:
+  return 0;
+}
+
+static int
+name_for_methodOop(jvm_agent_t* J, uint64_t methodOopPtr, char * result, size_t size)
+{
+  short nameIndex;
+  short signatureIndex;
+  uint64_t constantPool;
+  uint64_t constMethod;
+  uint64_t nameSymbol;
+  uint64_t signatureSymbol;
+  uint64_t klassPtr;
+  uint64_t klassSymbol;
+  short klassSymbolLength;
+  short nameSymbolLength;
+  short signatureSymbolLength;
+  char * nameString = NULL;
+  char * klassString = NULL;
+  char * signatureString = NULL;
+  int err;
+
+  err = read_pointer(J, methodOopPtr + OFFSET_methodOopDesc_constants, &constantPool);
+  CHECK_FAIL(err);
+  err = read_pointer(J, methodOopPtr + OFFSET_methodOopDesc_constMethod, &constMethod);
+  CHECK_FAIL(err);
+
+  /* To get name string */
+  err = ps_pread(J->P, constMethod + OFFSET_constMethodOopDesc_name_index, &nameIndex, 2);
+  CHECK_FAIL(err);
+  err = read_pointer(J, constantPool + nameIndex * POINTER_SIZE + SIZE_constantPoolOopDesc, &nameSymbol);
+  CHECK_FAIL(err);
+  // The symbol is a CPSlot and has lower bit set to indicate metadata
+  nameSymbol &= (~1); // remove metadata lsb
+  err = ps_pread(J->P, nameSymbol + OFFSET_Symbol_length, &nameSymbolLength, 2);
+  CHECK_FAIL(err);
+  nameString = (char*)calloc(nameSymbolLength + 1, 1);
+  err = ps_pread(J->P, nameSymbol + OFFSET_Symbol_body, nameString, nameSymbolLength);
+  CHECK_FAIL(err);
+
+  /* To get signature string */
+  err = ps_pread(J->P, constMethod + OFFSET_constMethodOopDesc_signature_index, &signatureIndex, 2);
+  CHECK_FAIL(err);
+  err = read_pointer(J, constantPool + signatureIndex * POINTER_SIZE + SIZE_constantPoolOopDesc, &signatureSymbol);
+  CHECK_FAIL(err);
+  signatureSymbol &= (~1);  // remove metadata lsb
+  err = ps_pread(J->P, signatureSymbol + OFFSET_Symbol_length, &signatureSymbolLength, 2);
+  CHECK_FAIL(err);
+  signatureString = (char*)calloc(signatureSymbolLength + 1, 1);
+  err = ps_pread(J->P, signatureSymbol + OFFSET_Symbol_body, signatureString, signatureSymbolLength);
+  CHECK_FAIL(err);
+
+  /* To get klass string */
+  err = read_pointer(J, constantPool + OFFSET_constantPoolOopDesc_pool_holder, &klassPtr);
+  CHECK_FAIL(err);
+  err = read_pointer(J, klassPtr + OFFSET_Klass_name + SIZE_oopDesc, &klassSymbol);
+  CHECK_FAIL(err);
+  err = ps_pread(J->P, klassSymbol + OFFSET_Symbol_length, &klassSymbolLength, 2);
+  CHECK_FAIL(err);
+  klassString = (char*)calloc(klassSymbolLength + 1, 1);
+  err = ps_pread(J->P, klassSymbol + OFFSET_Symbol_body, klassString, klassSymbolLength);
+  CHECK_FAIL(err);
+
+  result[0] = '\0';
+  strncat(result, klassString, size);
+  size -= strlen(klassString);
+  strncat(result, ".", size);
+  size -= 1;
+  strncat(result, nameString, size);
+  size -= strlen(nameString);
+  strncat(result, signatureString, size);
+
+  if (nameString != NULL) free(nameString);
+  if (klassString != NULL) free(klassString);
+  if (signatureString != NULL) free(signatureString);
+
+  return PS_OK;
+
+ fail:
+  if (debug) {
+      fprintf(stderr, "name_for_methodOop: FAIL \n\n");
+  }
+  if (nameString != NULL) free(nameString);
+  if (klassString != NULL) free(klassString);
+  if (signatureString != NULL) free(signatureString);
+  return -1;
+}
+
+static int nmethod_info(Nmethod_t *N)
+{
+  jvm_agent_t *J = N->J;
+  uint64_t    nm = N->nm;
+  int32_t err;
+
+  if (debug > 2 )
+      fprintf(stderr, "\t nmethod_info: BEGIN \n");
+
+  /* Instructions */
+  err = ps_pread(J->P, nm + OFFSET_CodeBlob_code_offset, &N->instrs_beg, SZ32);
+  CHECK_FAIL(err);
+  err = ps_pread(J->P, nm + OFFSET_CodeBlob_data_offset, &N->instrs_end, SZ32);
+  CHECK_FAIL(err);
+  err = ps_pread(J->P, nm + OFFSET_nmethod_deoptimize_offset, &N->deopt_beg, SZ32);
+  CHECK_FAIL(err);
+  err = ps_pread(J->P, nm + OFFSET_nmethod_orig_pc_offset, &N->orig_pc_offset, SZ32);
+  CHECK_FAIL(err);
+
+  /* Oops */
+  err = ps_pread(J->P, nm + OFFSET_nmethod_oops_offset, &N->oops_beg, SZ32);
+  CHECK_FAIL(err);
+  err = ps_pread(J->P, nm + OFFSET_nmethod_scopes_data_offset, &N->oops_end, SZ32);
+  CHECK_FAIL(err);
+
+  /* scopes_pcs */
+  err = ps_pread(J->P, nm + OFFSET_nmethod_scopes_pcs_offset, &N->scopes_pcs_beg, SZ32);
+  CHECK_FAIL(err);
+  err = ps_pread(J->P, nm + OFFSET_nmethod_handler_table_offset, &N->scopes_pcs_end, SZ32);
+  CHECK_FAIL(err);
+
+  /* scopes_data */
+  err = ps_pread(J->P, nm + OFFSET_nmethod_scopes_data_offset, &N->scopes_data_beg, SZ32);
+  CHECK_FAIL(err);
+
+  if (debug > 2 ) {
+      N->scopes_data_end = N->scopes_pcs_beg;
+
+      fprintf(stderr, "\t nmethod_info: instrs_beg: %#x, instrs_end: %#x\n",
+                       N->instrs_beg, N->instrs_end);
+
+      fprintf(stderr, "\t nmethod_info: deopt_beg: %#x \n",
+                       N->deopt_beg);
+
+      fprintf(stderr, "\t nmethod_info: orig_pc_offset: %#x \n",
+                       N->orig_pc_offset);
+
+      fprintf(stderr, "\t nmethod_info: oops_beg: %#x, oops_end: %#x\n",
+                       N->oops_beg, N->oops_end);
+
+      fprintf(stderr, "\t nmethod_info: scopes_data_beg: %#x, scopes_data_end: %#x\n",
+                       N->scopes_data_beg, N->scopes_data_end);
+
+      fprintf(stderr, "\t nmethod_info: scopes_pcs_beg: %#x, scopes_pcs_end: %#x\n",
+                       N->scopes_pcs_beg, N->scopes_pcs_end);
+
+      fprintf(stderr, "\t nmethod_info: END \n\n");
+  }
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+static int
+raw_read_int(jvm_agent_t* J, uint64_t *buffer, int32_t *val)
+{
+  int shift = 0;
+  int value = 0;
+  uint8_t ch = 0;
+  int32_t  err;
+  int32_t sum;
+  // Constants for UNSIGNED5 coding of Pack200
+  // see compressedStream.hpp
+  enum {
+    lg_H = 6,
+    H = 1<<lg_H,
+    BitsPerByte = 8,
+    L = (1<<BitsPerByte)-H,
+  };
+  int i;
+
+  err = ps_pread(J->P, (*buffer)++, &ch, sizeof(uint8_t));
+  CHECK_FAIL(err);
+  if (debug > 2)
+      fprintf(stderr, "\t\t\t raw_read_int: *buffer: %#llx, ch: %#x\n", *buffer, ch);
+
+  sum = ch;
+  if ( sum >= L ) {
+    int32_t lg_H_i = lg_H;
+    // Read maximum of 5 total bytes (we've already read 1).
+    // See CompressedReadStream::read_int_mb
+    for ( i = 0;  i < 4; i++) {
+      err = ps_pread(J->P, (*buffer)++, &ch, sizeof(uint8_t));
+      CHECK_FAIL(err);
+      sum += ch << lg_H_i;
+      if (ch < L ) {
+        *val = sum;
+        return PS_OK;
+      }
+      lg_H_i += lg_H;
+    }
+  }
+  *val = sum;
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+static int
+read_pair(jvm_agent_t* J, uint64_t *buffer, int32_t *bci, int32_t *line)
+{
+  uint8_t next = 0;
+  int32_t bci_delta;
+  int32_t line_delta;
+  int32_t err;
+
+  if (debug > 2)
+      fprintf(stderr, "\t\t read_pair: BEGIN\n");
+
+  err = ps_pread(J->P, (*buffer)++, &next, sizeof(uint8_t));
+  CHECK_FAIL(err);
+
+  if (next == 0) {
+      if (debug > 2)
+          fprintf(stderr, "\t\t read_pair: END: next == 0\n");
+      return 1; /* stream terminated */
+  }
+  if (next == 0xFF) {
+      if (debug > 2)
+          fprintf(stderr, "\t\t read_pair: END: next == 0xFF\n");
+
+      /* Escape character, regular compression used */
+
+      err = raw_read_int(J, buffer, &bci_delta);
+      CHECK_FAIL(err);
+
+      err = raw_read_int(J, buffer, &line_delta);
+      CHECK_FAIL(err);
+
+      *bci  += bci_delta;
+      *line += line_delta;
+
+      if (debug > 2) {
+          fprintf(stderr, "\t\t read_pair: delta = (line %d: %d)\n",
+                          line_delta, bci_delta);
+          fprintf(stderr, "\t\t read_pair: unpack= (line %d: %d)\n",
+                          *line, *bci);
+      }
+  } else {
+      /* Single byte compression used */
+      *bci  += next >> 3;
+      *line += next & 0x7;
+      if (debug > 2) {
+          fprintf(stderr, "\t\t read_pair: delta = (line %d: %d)\n",
+                          next & 0x7, next >> 3);
+          fprintf(stderr, "\t\t read_pair: unpack= (line %d: %d)\n",
+                          *line, *bci);
+      }
+  }
+  if (debug > 2)
+      fprintf(stderr, "\t\t read_pair: END\n");
+  return PS_OK;
+
+ fail:
+  if (debug)
+      fprintf(stderr, "\t\t read_pair: FAIL\n");
+  return err;
+}
+
+static int
+line_number_from_bci(jvm_agent_t* J, Vframe_t *vf)
+{
+  uint64_t buffer;
+  uint16_t code_size;
+  uint64_t code_end_delta;
+  uint64_t constMethod;
+  int8_t   access_flags;
+  int32_t  best_bci    = 0;
+  int32_t  stream_bci  = 0;
+  int32_t  stream_line = 0;
+  int32_t  err;
+
+  if (debug > 2) {
+      char name[256];
+      err = name_for_methodOop(J, vf->methodOop, name, 256);
+      CHECK_FAIL(err);
+      fprintf(stderr, "\t line_number_from_bci: BEGIN, method name: %s, targ bci: %d\n",
+                       name, vf->bci);
+  }
+
+  err = read_pointer(J, vf->methodOop + OFFSET_methodOopDesc_constMethod, &constMethod);
+  CHECK_FAIL(err);
+
+  vf->line = 0;
+  err = ps_pread(J->P, constMethod + OFFSET_constMethodOopDesc_flags, &access_flags, sizeof(int8_t));
+  CHECK_FAIL(err);
+
+  if (!(access_flags & constMethodOopDesc_has_linenumber_table)) {
+      if (debug > 2)
+          fprintf(stderr, "\t line_number_from_bci: END: !HAS_LINE_NUMBER_TABLE \n\n");
+      return PS_OK;
+  }
+
+  /*  The line numbers are a short array of 2-tuples [start_pc, line_number].
+   *  Not necessarily sorted and not necessarily one-to-one.
+   */
+
+  err = ps_pread(J->P, constMethod + OFFSET_constMethodOopDesc_code_size, &code_size, SZ16);
+  CHECK_FAIL(err);
+
+  /* inlined_table_start() */
+  code_end_delta = (uint64_t) (access_flags & AccessFlags_NATIVE) ? 2*POINTER_SIZE : 0;
+  buffer = constMethod + (uint64_t) SIZE_constMethodOopDesc + (uint64_t) code_size + code_end_delta;
+
+  if (debug > 2) {
+      fprintf(stderr, "\t\t line_number_from_bci: methodOop: %#llx, native: %d\n",
+                      vf->methodOop, (access_flags & AccessFlags_NATIVE));
+      fprintf(stderr, "\t\t line_number_from_bci: buffer: %#llx, code_size: %d\n",
+                      buffer, (int) code_size);
+  }
+
+  while (read_pair(J, &buffer, &stream_bci, &stream_line) == 0) {
+      if (stream_bci == vf->bci) {
+          /* perfect match */
+          if (debug > 2)
+              fprintf(stderr, "\t line_number_from_bci: END: exact line: %ld \n\n", vf->line);
+          vf->line = stream_line;
+          return PS_OK;
+      } else {
+          /* update best_bci/line */
+          if (stream_bci < vf->bci && stream_bci >= best_bci) {
+              best_bci = stream_bci;
+              vf->line = stream_line;
+              if (debug > 2) {
+                  fprintf(stderr, "\t line_number_from_bci: best_bci: %ld, best_line: %ld\n",
+                                   best_bci, vf->line);
+              }
+          }
+      }
+  }
+  if (debug > 2)
+      fprintf(stderr, "\t line_number_from_bci: END: line: %ld \n\n", vf->line);
+  return PS_OK;
+
+ fail:
+  if (debug)
+      fprintf(stderr, "\t line_number_from_bci: FAIL\n");
+  return err;
+}
+
+static int
+get_real_pc(Nmethod_t *N, uint64_t pc_desc, uint64_t *real_pc)
+{
+  int32_t pc_offset;
+  int32_t err;
+
+  err = ps_pread(N->J->P, pc_desc + OFFSET_PcDesc_pc_offset, &pc_offset, SZ32);
+  CHECK_FAIL(err);
+
+  *real_pc = N->nm + N->instrs_beg + pc_offset;
+  if (debug > 2) {
+      fprintf(stderr, "\t\t get_real_pc: pc_offset: %lx, real_pc: %llx\n",
+                       pc_offset, *real_pc);
+  }
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+/* Finds a PcDesc with real-pc equal to N->pc */
+static int pc_desc_at(Nmethod_t *N)
+{
+  uint64_t pc_diff;
+  int32_t offs;
+  int32_t err;
+
+  if (debug > 2)
+      fprintf(stderr, "\t pc_desc_at: BEGIN\n");
+
+  N->vf_cnt  = 0;
+  N->pc_desc = 0;
+
+  for (offs = N->scopes_pcs_beg; offs < N->scopes_pcs_end; offs += SIZE_PcDesc) {
+      uint64_t pd;
+      uint64_t best_pc_diff = 16;       /* some approximation */
+      uint64_t real_pc = 0;
+
+      pd = N->nm + offs;
+      err = get_real_pc(N, pd, &real_pc);
+      CHECK_FAIL(err);
+
+      pc_diff = real_pc - N->pc;
+
+      /* In general, this fragment should work */
+      if (pc_diff == 0) {
+          N->pc_desc = pd;
+          if (debug) {
+            fprintf(stderr, "\t pc_desc_at: END: pc_desc: FOUND: %#lx \n\n", pd);
+          }
+          return PS_OK;
+      }
+      /* This fragment is to be able to find out an appropriate
+       * pc_desc entry even if pc_desc info is inaccurate.
+       */
+      if (best_pc_diff > pc_diff && pc_diff > 0) {
+          best_pc_diff = pc_diff;
+          N->pc_desc = pd;
+      }
+  }
+  if (debug) {
+      fprintf(stderr, "\t pc_desc_at: END: pc_desc NOT FOUND");
+      if (pc_diff < 20)
+          fprintf(stderr, ", best pc_diff: %d\n\n", pc_diff);
+      else
+          fprintf(stderr, "\n\n");
+  }
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+static int
+scope_desc_at(Nmethod_t *N, int32_t decode_offset, Vframe_t *vf)
+{
+  uint64_t buffer;
+  int32_t  err;
+
+  if (debug > 2) {
+      fprintf(stderr, "\t\t scope_desc_at: BEGIN \n");
+  }
+
+  buffer = N->nm + N->scopes_data_beg + decode_offset;
+
+  err = raw_read_int(N->J, &buffer, &vf->sender_decode_offset);
+  CHECK_FAIL(err);
+
+  err = raw_read_int(N->J, &buffer, &vf->methodIdx);
+  CHECK_FAIL(err);
+
+  err = raw_read_int(N->J, &buffer, &vf->bci);
+  CHECK_FAIL(err);
+
+  if (debug > 2) {
+      fprintf(stderr, "\t\t scope_desc_at: sender_decode_offset: %#x\n",
+                      vf->sender_decode_offset);
+      fprintf(stderr, "\t\t scope_desc_at: methodIdx: %d\n", vf->methodIdx);
+      fprintf(stderr, "\t\t scope_desc_at: bci: %d\n", vf->bci);
+
+      fprintf(stderr, "\t\t scope_desc_at: END \n\n");
+  }
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+static int scopeDesc_chain(Nmethod_t *N) {
+  int32_t decode_offset = 0;
+  int32_t err;
+
+  if (debug > 2) {
+    fprintf(stderr, "\t scopeDesc_chain: BEGIN\n");
+  }
+
+  err = ps_pread(N->J->P, N->pc_desc + OFFSET_PcDesc_scope_decode_offset,
+                 &decode_offset, SZ32);
+  CHECK_FAIL(err);
+
+  while (decode_offset > 0) {
+    Vframe_t *vf = &N->vframes[N->vf_cnt];
+
+    if (debug > 2) {
+      fprintf(stderr, "\t scopeDesc_chain: decode_offset: %#x\n", decode_offset);
+    }
+
+    err = scope_desc_at(N, decode_offset, vf);
+    CHECK_FAIL(err);
+
+    if (vf->methodIdx > ((N->oops_end - N->oops_beg) / POINTER_SIZE)) {
+      fprintf(stderr, "\t scopeDesc_chain: (methodIdx > oops length) !\n");
+      return -1;
+    }
+    err = read_pointer(N->J, N->nm + N->oops_beg + (vf->methodIdx-1)*POINTER_SIZE,
+                       &vf->methodOop);
+    CHECK_FAIL(err);
+
+    if (vf->methodOop) {
+      N->vf_cnt++;
+      err = line_number_from_bci(N->J, vf);
+      CHECK_FAIL(err);
+      if (debug > 2) {
+        fprintf(stderr, "\t scopeDesc_chain: methodOop: %#8llx, line: %ld\n",
+                vf->methodOop, vf->line);
+      }
+    }
+    decode_offset = vf->sender_decode_offset;
+  }
+  if (debug > 2) {
+    fprintf(stderr, "\t scopeDesc_chain: END \n\n");
+  }
+  return PS_OK;
+
+ fail:
+  if (debug) {
+    fprintf(stderr, "\t scopeDesc_chain: FAIL \n\n");
+  }
+  return err;
+}
+
+
+static int
+name_for_nmethod(jvm_agent_t* J,
+                 uint64_t nm,
+                 uint64_t pc,
+                 uint64_t methodOop,
+                 char *result,
+                 size_t size,
+                 Jframe_t *jframe
+) {
+  Nmethod_t *N;
+  Vframe_t *vf;
+  int32_t err;
+  int deoptimized = 0;
+
+  if (debug) {
+      fprintf(stderr, "name_for_nmethod: BEGIN: nmethod: %#llx, pc: %#llx\n", nm, pc);
+  }
+  if (J->N == NULL) {
+    J->N = (Nmethod_t *) malloc(sizeof(Nmethod_t));
+  }
+  memset(J->N, 0, sizeof(Nmethod_t));   /* Initial stat: all values are zeros */
+  N     = J->N;
+  N->J  = J;
+  N->nm = nm;
+  N->pc = pc;
+  N->jframe = jframe;
+
+  err = nmethod_info(N);
+  CHECK_FAIL(err);
+  if (debug) {
+      fprintf(stderr, "name_for_nmethod: pc: %#llx, deopt_pc:  %#llx\n",
+              pc, N->nm + N->deopt_beg);
+  }
+
+  /* check for a deoptimized frame */
+  if ( pc == N->nm + N->deopt_beg) {
+    uint64_t base;
+    if (debug) {
+        fprintf(stderr, "name_for_nmethod: found deoptimized frame\n");
+    }
+    if (J->prev_fr.sender_sp != 0) {
+      base = J->prev_fr.sender_sp + N->orig_pc_offset;
+    } else {
+      base = J->curr_fr.sp + N->orig_pc_offset;
+    }
+    err = read_pointer(J, base, &N->pc);
+    CHECK_FAIL(err);
+    if (debug) {
+        fprintf(stderr, "name_for_nmethod: found deoptimized frame converting pc from %#8llx to %#8llx\n",
+        pc,  N->pc);
+    }
+    deoptimized = 1;
+  }
+
+  err = pc_desc_at(N);
+  CHECK_FAIL(err);
+
+  if (N->pc_desc > 0) {
+      jframe->locinf = 1;
+      err = scopeDesc_chain(N);
+      CHECK_FAIL(err);
+  }
+  result[0] = COMP_METHOD_SIGN;
+  vf = &N->vframes[0];
+  if (N->vf_cnt > 0) {
+      jframe->vf_cnt = N->vf_cnt;
+      jframe->bci  = vf->bci;
+      jframe->line = vf->line;
+      err = name_for_methodOop(J, N->vframes[0].methodOop, result+1, size-1);
+      CHECK_FAIL(err);
+  } else {
+      err = name_for_methodOop(J, methodOop, result+1, size-1);
+      CHECK_FAIL(err);
+  }
+  if (deoptimized) {
+    strncat(result + 1, " [deoptimized frame]; ", size-1);
+  } else {
+    strncat(result + 1, " [compiled] ", size-1);
+  }
+  if (debug)
+      fprintf(stderr, "name_for_nmethod: END: method name: %s, vf_cnt: %d\n\n",
+                      result, N->vf_cnt);
+  return PS_OK;
+
+ fail:
+  if (debug)
+      fprintf(stderr, "name_for_nmethod: FAIL \n\n");
+  return err;
+}
+
+int is_bci(intptr_t bcx) {
+  switch (DATA_MODEL) {
+  case PR_MODEL_LP64:
+    return ((uintptr_t) bcx) <= ((uintptr_t) MAX_METHOD_CODE_SIZE) ;
+  case PR_MODEL_ILP32:
+  default:
+    return 0 <= bcx && bcx <= MAX_METHOD_CODE_SIZE;
+  }
+}
+
+static int
+name_for_imethod(jvm_agent_t* J,
+                 uint64_t bcx,
+                 uint64_t methodOop,
+                 char *result,
+                 size_t size,
+                 Jframe_t *jframe
+) {
+  uint64_t bci;
+  uint64_t constMethod;
+  Vframe_t vframe = {0};
+  Vframe_t *vf = &vframe;
+  int32_t   err;
+
+  err = read_pointer(J, methodOop + OFFSET_methodOopDesc_constMethod, &constMethod);
+  CHECK_FAIL(err);
+
+  bci = is_bci(bcx) ? bcx : bcx - (constMethod + (uint64_t) SIZE_constMethodOopDesc);
+
+  if (debug)
+      fprintf(stderr, "\t name_for_imethod: BEGIN: methodOop: %#llx\n", methodOop);
+
+  err = name_for_methodOop(J, methodOop, result, size);
+  CHECK_FAIL(err);
+  if (debug)
+      fprintf(stderr, "\t name_for_imethod: method name: %s\n", result);
+
+  if (bci > 0) {
+      vf->methodOop = methodOop;
+      vf->bci       = bci;
+      err = line_number_from_bci(J, vf);
+      CHECK_FAIL(err);
+  }
+  jframe->bci  = vf->bci;
+  jframe->line = vf->line;
+  jframe->locinf = 1;
+
+  if (debug) {
+      fprintf(stderr, "\t name_for_imethod: END: bci: %d, line: %d\n\n",
+                      vf->bci, vf->line);
+  }
+  return PS_OK;
+
+ fail:
+  if (debug)
+      fprintf(stderr, "\t name_for_imethod: FAIL\n");
+  return err;
+}
+
+static int
+name_for_codecache(jvm_agent_t* J, uint64_t fp, uint64_t pc, char * result,
+                   size_t size, Jframe_t *jframe, int* is_interpreted)
+{
+  uint64_t start;
+  uint64_t vtbl;
+  int32_t err;
+  *is_interpreted = 0;
+
+  result[0] = '\0';
+
+  err = find_start(J, pc, &start);
+  CHECK_FAIL(err);
+
+  err = read_pointer(J, start, &vtbl);
+  CHECK_FAIL(err);
+
+  if (vtbl == J->nmethod_vtbl) {
+    uint64_t methodOop;
+
+    err = read_pointer(J, start + OFFSET_nmethod_method, &methodOop);
+    CHECK_FAIL(err);
+
+    if (debug) {
+        fprintf(stderr, "name_for_codecache: start: %#8llx, pc: %#8llx, methodOop: %#8llx \n",
+                        start, pc, methodOop);
+    }
+    err = name_for_nmethod(J, start, pc, methodOop, result, size, jframe);
+    CHECK_FAIL(err);
+  } else if (vtbl == J->BufferBlob_vtbl) {
+    const char * name;
+
+    err = read_string_pointer(J, start + OFFSET_CodeBlob_name, &name);
+
+    /*
+     * Temporary usage of string "Interpreter".
+     * We need some other way to distinguish "StubRoutines"
+     * and regular interpreted frames.
+     */
+    if (err == PS_OK && strncmp(name, "Interpreter", 11) == 0) {
+      *is_interpreted = 1;
+      if (is_methodOop(J, J->methodOopPtr)) {
+        return name_for_imethod(J, J->bcx, J->methodOopPtr, result, size, jframe);
+      }
+    }
+
+    if (err == PS_OK) {
+      strncpy(result, name, size);
+      free((void*)name);
+    } else {
+      strncpy(result, "<unknown BufferBlob>", size);
+    }
+    /* return PS_OK; */
+  } else {
+    const char * name;
+
+    err = read_string_pointer(J, start + OFFSET_CodeBlob_name, &name);
+    if (err == PS_OK) {
+      strncpy(result, name, size);
+      free((void*)name);
+    } else {
+      strncpy(result, "<unknown CodeBlob>", size);
+      WARN1("unknown CodeBlob: vtbl = 0x%x", vtbl);
+    }
+  }
+  result[size-1] = '\0';
+
+#ifdef X86_COMPILER2
+  if (vtbl != J->RuntimeStub_vtbl) {
+    uint64_t trial_pc;
+    int frame_size;
+    err = ps_pread(J->P, start + OFFSET_CodeBlob_frame_size,
+                         &frame_size, SZ32);
+    CHECK_FAIL(err);
+
+    // frame_size is in words, we want bytes.
+    frame_size *= POINTER_SIZE; /* word => byte conversion */
+
+    /*
+      Because c2 doesn't use FP as a framepointer the value of sp/fp we receive
+      in the initial entry to a set of stack frames containing server frames
+      will pretty much be nonsense. We can detect that nonsense by looking to
+      see if the PC we received is correct if we look at the expected storage
+      location in relation to the FP (ie. POINTER_SIZE(FP) )
+    */
+
+    err = read_pointer(J, fp + POINTER_SIZE , &trial_pc);
+    if ( (err != PS_OK || trial_pc != pc) && frame_size > 0 ) {
+      // Either we couldn't even read at the "fp" or the pc didn't match
+      // both are sure clues that the fp is bogus. We no search the stack
+      // for a reasonable number of words trying to find the bogus fp
+      // and the current pc in adjacent words. The we will be able to
+      // deduce an approximation of the frame pointer and actually get
+      // the correct stack pointer. Which we can then unwind for the
+      // next frame.
+      int i;
+      uint64_t check;
+      uint64_t base = J->curr_fr.sp;
+      uint64_t prev_fp = 0;
+      for ( i = 0; i < frame_size * 5 ; i++, base += POINTER_SIZE ) {
+        err = read_pointer(J, base , &check);
+        CHECK_FAIL(err);
+        if (check == fp) {
+          base += POINTER_SIZE;
+          err = read_pointer(J, base , &check);
+          CHECK_FAIL(err);
+          if (check == pc) {
+            if (debug) {
+              fprintf(stderr, "name_for_codecache: found matching fp/pc combo at 0x%llx\n", base - POINTER_SIZE);
+            }
+            prev_fp = base - 2 * POINTER_SIZE;
+            break;
+          }
+        }
+      }
+      if ( prev_fp != 0 ) {
+        // real_sp is the sp we should have received for this frame
+        uint64_t real_sp = prev_fp + 2 * POINTER_SIZE;
+        // +POINTER_SIZE because callee owns the return address so caller's sp is +1 word
+        jframe->new_sp = real_sp + frame_size + POINTER_SIZE;
+        err = read_pointer(J, jframe->new_sp - POINTER_SIZE , &jframe->new_pc);
+        CHECK_FAIL(err);
+        err = read_pointer(J, jframe->new_sp - 2*POINTER_SIZE, &jframe->new_fp);
+        CHECK_FAIL(err);
+        return PS_OK;
+      }
+    }
+
+    /* A prototype to workaround FP absence */
+    /*
+     * frame_size can be 0 for StubRoutines (1) frame.
+     * In this case it should work with fp as usual.
+     */
+    if (frame_size > 0) {
+      jframe->new_fp = J->prev_fr.fp + frame_size;
+      jframe->new_sp = jframe->new_fp + 2 * POINTER_SIZE;
+    } else {
+      memset(&J->curr_fr, 0, sizeof(Frame_t));
+      err = read_pointer(J,  fp, &jframe->new_fp);
+      CHECK_FAIL(err);
+
+      err = read_pointer(J,  jframe->new_fp + POINTER_SIZE,  &jframe->new_pc);
+      CHECK_FAIL(err);
+    }
+    if (debug) {
+      fprintf(stderr, "name_for_codecache: %s, frame_size=%#lx\n",
+                       result, frame_size);
+      fprintf(stderr, "name_for_codecache: prev_fr.fp=%#lx, fp=%#lx\n",
+                       J->prev_fr.fp, jframe->new_fp);
+    }
+  }
+#endif /* X86_COMPILER2 */
+
+  return PS_OK;
+
+ fail:
+  return err;
+}
+
+int Jget_vframe(jvm_agent_t* J, int vframe_no,
+                char *name, size_t size, Jframe_t *jframe)
+{
+  Nmethod_t *N = J->N;
+  Vframe_t  *vf;
+  int32_t   err;
+
+  if (vframe_no >= N->vf_cnt) {
+     (void) sprintf(name, "Wrong inlinedMethod%1d()", vframe_no);
+     return -1;
+  }
+  vf = N->vframes + vframe_no;
+  name[0] = COMP_METHOD_SIGN;
+  err = name_for_methodOop(J, vf->methodOop, name + 1, size);
+  CHECK_FAIL(err);
+
+  jframe->bci = vf->bci;
+  jframe->line = vf->line;
+  if (debug) {
+      fprintf(stderr, "\t Jget_vframe: method name: %s, line: %ld\n",
+                       name, vf->line);
+  }
+  return PS_OK;
+
+ fail:
+  if (debug) {
+      fprintf(stderr, "\t Jget_vframe: FAIL\n");
+  }
+  return err;
+}
+
+#define MAX_SYM_SIZE 256
+
+int Jlookup_by_regs(jvm_agent_t* J, const prgregset_t regs, char *name,
+                    size_t size, Jframe_t *jframe) {
+  uintptr_t fp;
+  uintptr_t pc;
+  /* arguments given to read_pointer need to be worst case sized */
+  uint64_t methodOopPtr = 0;
+  uint64_t sender_sp;
+  uint64_t bcx = 0;
+  int is_interpreted = 0;
+  int result = PS_OK;
+  int err = PS_OK;
+
+  if (J == NULL) {
+    return -1;
+  }
+
+  jframe->vf_cnt = 1;
+  jframe->new_fp = 0;
+  jframe->new_pc = 0;
+  jframe->line   = 0;
+  jframe->bci    = 0;
+  jframe->locinf = 0;
+
+  read_volatiles(J);
+  pc = (uintptr_t) regs[R_PC];
+  J->curr_fr.pc = pc;
+  J->curr_fr.fp = regs[R_FP];
+  J->curr_fr.sp = regs[R_SP];
+
+  if (debug)
+      fprintf(stderr, "Jlookup_by_regs: BEGINs: fp=%#lx, pc=%#lx\n", regs[R_FP], pc);
+
+#if defined(sparc) || defined(__sparc)
+    /* The following workaround is for SPARC. CALL instruction occupates 8 bytes.
+     * In the pcDesc structure return pc offset is recorded for CALL instructions.
+     * regs[R_PC] contains a CALL instruction pc offset.
+     */
+    pc += 8;
+    bcx          = (uintptr_t) regs[R_L1];
+    methodOopPtr = (uintptr_t) regs[R_L2];
+    sender_sp = regs[R_I5];
+    if (debug > 2) {
+        fprintf(stderr, "\nregs[R_I1]=%lx, regs[R_I2]=%lx, regs[R_I5]=%lx, regs[R_L1]=%lx, regs[R_L2]=%lx\n",
+                         regs[R_I1], regs[R_I2], regs[R_I5], regs[R_L1], regs[R_L2]);
+    }
+#elif defined(i386) || defined(__i386) || defined(__amd64)
+
+    fp = (uintptr_t) regs[R_FP];
+    if (J->prev_fr.fp == 0) {
+#ifdef X86_COMPILER2
+        /* A workaround for top java frames */
+        J->prev_fr.fp = (uintptr_t)(regs[R_SP] - 2 * POINTER_SIZE);
+#else
+        J->prev_fr.fp = (uintptr_t)(regs[R_SP] - POINTER_SIZE);
+#endif /* COMPILER2 */
+    }
+    if (debug > 2) {
+        printf("Jlookup_by_regs: J->prev_fr.fp = %#lx\n", J->prev_fr.fp);
+    }
+
+    if (read_pointer(J,  fp + OFFSET_interpreter_frame_method, &methodOopPtr) != PS_OK) {
+      methodOopPtr = 0;
+    }
+    if (read_pointer(J,  fp + OFFSET_interpreter_frame_sender_sp, &sender_sp) != PS_OK) {
+      sender_sp = 0;
+    }
+    if (read_pointer(J,  fp + OFFSET_interpreter_frame_bcx_offset, &bcx) != PS_OK) {
+      bcx = 0;
+    }
+#endif /* i386 */
+
+  J->methodOopPtr = methodOopPtr;
+  J->bcx = bcx;
+
+  /* On x86 with C2 JVM: native frame may have wrong regs[R_FP]
+   * For example: JVM_SuspendThread frame poins to the top interpreted frame.
+   * If we call is_methodOop(J, methodOopPtr) before codecache_contains(J, pc)
+   * then we go over and omit both: nmethod and I2CAdapter frames.
+   * Note, that regs[R_PC] is always correct if frame defined correctly.
+   * So it is better to call codecache_contains(J, pc) from the beginning.
+   */
+#ifndef X86_COMPILER2
+  if (is_methodOop(J, J->methodOopPtr)) {
+    result = name_for_imethod(J, bcx, J->methodOopPtr, name, size, jframe);
+    /* If the methodOopPtr is a method then this is highly likely to be
+       an interpreter frame */
+    if (result >= 0) {
+      is_interpreted = 1;
+    }
+  } else
+#endif /* ! X86_COMPILER2 */
+
+  if (codecache_contains(J, pc)) {
+    result = name_for_codecache(J, fp, pc, name, size, jframe, &is_interpreted);
+  }
+#ifdef X86_COMPILER2
+  else if (is_methodOop(J, J->methodOopPtr)) {
+    result = name_for_imethod(J, bcx, J->methodOopPtr, name, size, jframe);
+    /* If the methodOopPtr is a method then this is highly likely to be
+       an interpreter frame */
+    if (result >= 0) {
+      is_interpreted = 1;
+    }
+  }
+#endif /* X86_COMPILER2 */
+  else {
+    if (debug) {
+        fprintf(stderr, "Jlookup_by_regs: END with -1\n\n");
+    }
+    result = -1;
+  }
+  if (!is_interpreted) {
+    sender_sp = 0;
+  }
+  J->curr_fr.sender_sp = sender_sp;
+
+#ifdef X86_COMPILER2
+  if (!J->curr_fr.fp) {
+    J->curr_fr.fp = (jframe->new_fp) ? jframe->new_fp : (uintptr_t)regs[R_FP];
+  }
+  if (!jframe->new_pc && jframe->new_fp) {
+    // This seems dubious
+    read_pointer(J,  jframe->new_fp + POINTER_SIZE,  &jframe->new_pc);
+    CHECK_FAIL(err);
+    if (debug > 2) {
+        printf("Jlookup_by_regs: (update pc) jframe->new_fp: %#llx, jframe->new_pc: %#llx\n",
+               jframe->new_fp, jframe->new_pc);
+    }
+  }
+
+#endif /* X86_COMPILER2 */
+  J->prev_fr = J->curr_fr;
+
+  if (debug)
+      fprintf(stderr, "Jlookup_by_regs: END\n\n");
+
+  return result;
+
+ fail:
+  return err;
+}
+
+void update_gregs(prgregset_t gregs, Jframe_t jframe) {
+#ifdef X86_COMPILER2
+    if (debug > 0) {
+      fprintf(stderr, "update_gregs: before update sp = 0x%llx, fp = 0x%llx, pc = 0x%llx\n", gregs[R_SP], gregs[R_FP], gregs[R_PC]);
+    }
+    /*
+     * A workaround for java C2 frames with unconventional FP.
+     * may have to modify regset with new values for FP/PC/SP when needed.
+     */
+     if (jframe.new_sp) {
+         *((uintptr_t *) &gregs[R_SP]) = (uintptr_t) jframe.new_sp;
+     } else {
+         // *((uintptr_t *) &gregs[R_SP]) = (uintptr_t) gregs[R_FP] + 2 * POINTER_SIZE;
+     }
+
+     if (jframe.new_fp) {
+         *((uintptr_t *) &gregs[R_FP]) = (uintptr_t) jframe.new_fp;
+     }
+     if (jframe.new_pc) {
+         *((uintptr_t *) &gregs[R_PC]) = (uintptr_t) jframe.new_pc;
+     }
+    if (debug > 0) {
+      fprintf(stderr, "update_gregs: after update sp = 0x%llx, fp = 0x%llx, pc = 0x%llx\n", gregs[R_SP], gregs[R_FP], gregs[R_PC]);
+    }
+#endif  /* X86_COMPILER2 */
+}
+
+/*
+ * Iterates over java frames at current location given by 'gregs'.
+ *
+ *  Returns -1 if no java frames are present or if an error is encountered.
+ *  Returns the result of calling 'func' if the return value is non-zero.
+ *  Returns 0 otherwise.
+ */
+int Jframe_iter(jvm_agent_t *J, prgregset_t gregs, java_stack_f *func, void* cld) {
+    char buf[MAX_SYM_SIZE + 1];
+    Jframe_t jframe;
+    int i = 0, res;
+#ifdef X86_COMPILER2
+    if (debug > 0) {
+      fprintf(stderr, "Jframe_iter: Entry sp = 0x%llx, fp = 0x%llx, pc = 0x%llx\n", gregs[R_SP], gregs[R_FP], gregs[R_PC]);
+    }
+#endif  /* X86_COMPILER2 */
+
+    memset(&jframe, 0, sizeof(Jframe_t));
+    memset(buf, 0, sizeof(buf));
+    res =  Jlookup_by_regs(J, gregs, buf, sizeof(buf), &jframe);
+    if (res != PS_OK)
+        return (-1);
+
+
+    res = func(cld, gregs, buf, (jframe.locinf)? jframe.bci : -1,
+               jframe.line, NULL);
+    if (res != 0) {
+        update_gregs(gregs, jframe);
+        return (res);
+    }
+    for (i = 1; i < jframe.vf_cnt; i++) {
+        Jget_vframe(J, i, buf, sizeof(buf), &jframe);
+        res = func(cld, gregs, buf, (jframe.locinf)? jframe.bci : -1,
+                   jframe.line, NULL);
+        if (res != 0) {
+            update_gregs(gregs, jframe);
+            return (res);
+        }
+    }
+    update_gregs(gregs, jframe);
+    return (0);
+}
diff -Nru openjdk.orig/hotspot/src/os/bsd/dtrace/libjvm_db.h openjdk/hotspot/src/os/bsd/dtrace/libjvm_db.h
--- openjdk.orig/hotspot/src/os/bsd/dtrace/libjvm_db.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/os/bsd/dtrace/libjvm_db.h	2012-07-25 15:27:37.279648973 +0100
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_SOLARIS_DTRACE_LIBJVM_DB_H
+#define OS_SOLARIS_DTRACE_LIBJVM_DB_H
+
+// not available on macosx #include <proc_service.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct jvm_agent jvm_agent_t;
+
+#define JVM_DB_VERSION  1
+
+jvm_agent_t *Jagent_create(struct ps_prochandle *P, int vers);
+
+/*
+ * Called from Jframe_iter() for each java frame.  If it returns 0, then
+ * Jframe_iter() proceeds to the next frame.  Otherwise, the return value is
+ * immediately returned to the caller of Jframe_iter().
+ *
+ * Parameters:
+ *    'cld' is client supplied data (to maintain iterator state, if any).
+ *    'name' is java method name.
+ *    'bci' is byte code index. it will be -1 if not available.
+ *    'line' is java source line number. it will be 0 if not available.
+ *    'handle' is an abstract client handle, reserved for future expansions
+ */
+
+typedef int java_stack_f(void *cld, const prgregset_t regs, const char* name, int bci, int line, void *handle);
+
+/*
+ * Iterates over the java frames at the current location.  Returns -1 if no java
+ * frames were found, or if there was some unrecoverable error.  Otherwise,
+ * returns the last value returned from 'func'.
+ */
+int Jframe_iter(jvm_agent_t *agent, prgregset_t gregs, java_stack_f *func, void* cld);
+
+void Jagent_destroy(jvm_agent_t *J);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif // OS_SOLARIS_DTRACE_LIBJVM_DB_H
diff -Nru openjdk.orig/hotspot/src/os/bsd/vm/dtraceJSDT_bsd.cpp openjdk/hotspot/src/os/bsd/vm/dtraceJSDT_bsd.cpp
--- openjdk.orig/hotspot/src/os/bsd/vm/dtraceJSDT_bsd.cpp	2012-07-25 15:14:34.482186327 +0100
+++ openjdk/hotspot/src/os/bsd/vm/dtraceJSDT_bsd.cpp	2012-07-25 15:27:37.279648973 +0100
@@ -33,6 +33,13 @@
 #include "runtime/signature.hpp"
 #include "utilities/globalDefinitions.hpp"
 
+/*
+ * JSDT java dtrace probes have never been implemented in macosx.  It is unknown if the solaris implementation
+ * is close or if significant implementation work is necessary.  The future of the solaris implementation also
+ * appears to be unclear since compiling code with JSDT probes produces the following warning:
+ * "warning: ProviderFactory is internal proprietary API and may be removed in a future release"
+ */
+
 int DTraceJSDT::pd_activate(
     void* baseAddress, jstring module,
     jint providers_count, JVM_DTraceProvider* providers) {
diff -Nru openjdk.orig/hotspot/src/os/bsd/vm/jvm_bsd.h openjdk/hotspot/src/os/bsd/vm/jvm_bsd.h
--- openjdk.orig/hotspot/src/os/bsd/vm/jvm_bsd.h	2012-07-25 15:14:34.486186395 +0100
+++ openjdk/hotspot/src/os/bsd/vm/jvm_bsd.h	2012-07-25 15:27:37.279648973 +0100
@@ -41,6 +41,21 @@
  * This file is currently collecting system-specific dregs for the
  * JNI conversion, which should be sorted out later.
  */
+#ifdef __NetBSD__
+/*
+ * Since we are compiling with c++, we need the following to make c macros
+ * visible.
+ */
+# if !defined(__STDC_LIMIT_MACROS)
+#  define __STDC_LIMIT_MACROS           1
+# endif
+# if !defined(__STDC_CONSTANT_MACROS)
+#  define __STDC_CONSTANT_MACROS        1
+# endif
+# if !defined(__STDC_FORMAT_MACROS)
+#  define __STDC_FORMAT_MACROS          1
+# endif
+#endif
 
 #include <dirent.h>             /* For DIR */
 #include <sys/param.h>          /* For MAXPATHLEN */
diff -Nru openjdk.orig/hotspot/src/os/bsd/vm/os_bsd.cpp openjdk/hotspot/src/os/bsd/vm/os_bsd.cpp
--- openjdk.orig/hotspot/src/os/bsd/vm/os_bsd.cpp	2012-07-25 15:14:34.494186535 +0100
+++ openjdk/hotspot/src/os/bsd/vm/os_bsd.cpp	2012-07-25 15:27:37.283649042 +0100
@@ -136,8 +136,10 @@
 #endif
 
 #ifdef __APPLE__
-#include <mach/mach.h> // semaphore_* API
-#include <mach-o/dyld.h>
+# include <mach/mach.h> // semaphore_* API
+# include <mach-o/dyld.h>
+# include <sys/proc_info.h>
+# include <objc/objc-auto.h>
 #endif
 
 #ifndef MAP_ANONYMOUS
@@ -388,6 +390,20 @@
 }
 #endif
 
+#ifdef __APPLE__
+static const char *get_home() {
+  const char *home_dir = ::getenv("HOME");
+  if ((home_dir == NULL) || (*home_dir == '\0')) {
+    struct passwd *passwd_info = getpwuid(geteuid());
+    if (passwd_info != NULL) {
+      home_dir = passwd_info->pw_dir;
+    }
+  }
+
+  return home_dir;
+}
+#endif
+
 void os::init_system_properties_values() {
 //  char arch[12];
 //  sysinfo(SI_ARCHITECTURE, arch, sizeof(arch));
@@ -438,6 +454,15 @@
 #define ENDORSED_DIR    "/lib/endorsed"
 #define REG_DIR         "/usr/java/packages"
 
+#ifdef __APPLE__
+#define SYS_EXTENSIONS_DIR   "/Library/Java/Extensions"
+#define SYS_EXTENSIONS_DIRS  SYS_EXTENSIONS_DIR ":/Network" SYS_EXTENSIONS_DIR ":/System" SYS_EXTENSIONS_DIR ":/usr/lib/java"
+        const char *user_home_dir = get_home();
+        // the null in SYS_EXTENSIONS_DIRS counts for the size of the colon after user_home_dir
+        int system_ext_size = strlen(user_home_dir) + sizeof(SYS_EXTENSIONS_DIR) +
+            sizeof(SYS_EXTENSIONS_DIRS);
+#endif
+
   {
     /* sysclasspath, java_home, dll_dir */
     {
@@ -462,10 +487,12 @@
         if (pslash != NULL) {
             pslash = strrchr(buf, '/');
             if (pslash != NULL) {
-                *pslash = '\0';       /* get rid of /<arch> */
+                *pslash = '\0';       /* get rid of /<arch> (/lib on macosx) */
+#ifndef __APPLE__
                 pslash = strrchr(buf, '/');
                 if (pslash != NULL)
                     *pslash = '\0';   /* get rid of /lib */
+#endif
             }
         }
 
@@ -500,9 +527,14 @@
          * nulls included by the sizeof operator (so actually we allocate
          * a byte more than necessary).
          */
+#ifdef __APPLE__
+        ld_library_path = (char *) malloc(system_ext_size);
+        sprintf(ld_library_path, "%s" SYS_EXTENSIONS_DIR ":" SYS_EXTENSIONS_DIRS, user_home_dir);
+#else
         ld_library_path = (char *) malloc(sizeof(REG_DIR) + sizeof("/lib/") +
             strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH));
         sprintf(ld_library_path, REG_DIR "/lib/%s:" DEFAULT_LIBPATH, cpu_arch);
+#endif
 
         /*
          * Get the user setting of LD_LIBRARY_PATH, and prepended it.  It
@@ -510,6 +542,16 @@
          * addressed).
          */
 #ifdef __APPLE__
+        // Prepend the default path with the JAVA_LIBRARY_PATH so that the app launcher code can specify a directory inside an app wrapper
+        char *l = getenv("JAVA_LIBRARY_PATH");
+        if (l != NULL) {
+            char *t = ld_library_path;
+            /* That's +1 for the colon and +1 for the trailing '\0' */
+            ld_library_path = (char *) malloc(strlen(l) + 1 + strlen(t) + 1);
+            sprintf(ld_library_path, "%s:%s", l, t);
+            free(t);
+        }
+
         char *v = getenv("DYLD_LIBRARY_PATH");
 #else
         char *v = getenv("LD_LIBRARY_PATH");
@@ -519,6 +561,7 @@
             /* That's +1 for the colon and +1 for the trailing '\0' */
             ld_library_path = (char *) malloc(strlen(v) + 1 + strlen(t) + 1);
             sprintf(ld_library_path, "%s:%s", v, t);
+            free(t);
         }
         Arguments::set_library_path(ld_library_path);
     }
@@ -531,10 +574,18 @@
      * than necessary is allocated).
      */
     {
+#ifdef __APPLE__
+        char *buf = malloc(strlen(Arguments::get_java_home()) +
+            sizeof(EXTENSIONS_DIR) + system_ext_size);
+        sprintf(buf, "%s" SYS_EXTENSIONS_DIR ":%s" EXTENSIONS_DIR ":"
+            SYS_EXTENSIONS_DIRS, user_home_dir, Arguments::get_java_home());
+#else
         char *buf = malloc(strlen(Arguments::get_java_home()) +
             sizeof(EXTENSIONS_DIR) + sizeof(REG_DIR) + sizeof(EXTENSIONS_DIR));
         sprintf(buf, "%s" EXTENSIONS_DIR ":" REG_DIR EXTENSIONS_DIR,
             Arguments::get_java_home());
+#endif
+
         Arguments::set_ext_dirs(buf);
     }
 
@@ -547,6 +598,9 @@
     }
   }
 
+#ifdef __APPLE__
+#undef SYS_EXTENSIONS_DIR
+#endif
 #undef malloc
 #undef getenv
 #undef EXTENSIONS_DIR
@@ -884,6 +938,16 @@
 #endif
 }
 
+#ifdef __APPLE__
+// library handle for calling objc_registerThreadWithCollector()
+// without static linking to the libobjc library
+#define OBJC_LIB "/usr/lib/libobjc.dylib"
+#define OBJC_GCREGISTER "objc_registerThreadWithCollector"
+typedef void (*objc_registerThreadWithCollector_t)();
+extern "C" objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction;
+objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = NULL;
+#endif
+
 // Thread start routine for all newly created threads
 static void *java_start(Thread *thread) {
   // Try to randomize the cache line index of hot stack frames.
@@ -929,6 +993,13 @@
   // initialize floating point control register
   os::Bsd::init_thread_fpu_state();
 
+#ifdef __APPLE__
+  // register thread with objc gc
+  if (objc_registerThreadWithCollectorFunction != NULL) {
+    objc_registerThreadWithCollectorFunction();
+  }
+#endif
+
   // handshaking with parent thread
   {
     MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);
@@ -1747,7 +1818,23 @@
 
 // This must be hard coded because it's the system's temporary
 // directory not the java application's temp directory, ala java.io.tmpdir.
+#ifdef __APPLE__
+// macosx has a secure per-user temporary directory
+char temp_path_storage[PATH_MAX];
+const char* os::get_temp_directory() {
+  static char *temp_path = NULL;
+  if (temp_path == NULL) {
+    int pathSize = confstr(_CS_DARWIN_USER_TEMP_DIR, temp_path_storage, PATH_MAX);
+    if (pathSize == 0 || pathSize > PATH_MAX) {
+      strlcpy(temp_path_storage, "/tmp/", sizeof(temp_path_storage));
+    }
+    temp_path = temp_path_storage;
+  }
+  return temp_path;
+}
+#else /* __APPLE__ */
 const char* os::get_temp_directory() { return "/tmp"; }
+#endif /* __APPLE__ */
 
 static bool file_exists(const char* filename) {
   struct stat statbuf;
@@ -4531,6 +4618,14 @@
   // initialize thread priority policy
   prio_init();
 
+#ifdef __APPLE__
+  // dynamically link to objective c gc registration
+  void *handleLibObjc = dlopen(OBJC_LIB, RTLD_LAZY);
+  if (handleLibObjc != NULL) {
+    objc_registerThreadWithCollectorFunction = (objc_registerThreadWithCollector_t) dlsym(handleLibObjc, OBJC_GCREGISTER);
+  }
+#endif
+
   return JNI_OK;
 }
 
@@ -4562,6 +4657,18 @@
 #endif
 }
 
+void os::set_native_thread_name(const char *name) {
+#if defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5
+  // This is only supported in Snow Leopard and beyond
+  if (name != NULL) {
+    // Add a "Java: " prefix to the name
+    char buf[MAXTHREADNAMESIZE];
+    snprintf(buf, sizeof(buf), "Java: %s", name);
+    pthread_setname_np(buf);
+  }
+#endif
+}
+
 bool os::distribute_processes(uint length, uint* distribution) {
   // Not yet implemented.
   return false;
@@ -5678,8 +5785,8 @@
     struct stat statbuf;
     char buf[MAXPATHLEN];
     char libmawtpath[MAXPATHLEN];
-    const char *xawtstr  = "/xawt/libmawt.so";
-    const char *motifstr = "/motif21/libmawt.so";
+    const char *xawtstr  = "/xawt/libmawt" JNI_LIB_SUFFIX;
+    const char *motifstr = "/motif21/libmawt" JNI_LIB_SUFFIX;
     char *p;
 
     // Get path to libjvm.so
diff -Nru openjdk.orig/hotspot/src/os/linux/vm/os_linux.cpp openjdk/hotspot/src/os/linux/vm/os_linux.cpp
--- openjdk.orig/hotspot/src/os/linux/vm/os_linux.cpp	2012-07-25 15:14:34.502186673 +0100
+++ openjdk/hotspot/src/os/linux/vm/os_linux.cpp	2012-07-25 15:27:37.283649042 +0100
@@ -4387,6 +4387,11 @@
   return online_cpus;
 }
 
+void os::set_native_thread_name(const char *name) {
+  // Not yet implemented.
+  return;
+}
+
 bool os::distribute_processes(uint length, uint* distribution) {
   // Not yet implemented.
   return false;
diff -Nru openjdk.orig/hotspot/src/os/solaris/vm/os_solaris.cpp openjdk/hotspot/src/os/solaris/vm/os_solaris.cpp
--- openjdk.orig/hotspot/src/os/solaris/vm/os_solaris.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/os/solaris/vm/os_solaris.cpp	2012-07-25 15:27:37.283649042 +0100
@@ -669,6 +669,11 @@
   return true;
 }
 
+void os::set_native_thread_name(const char *name) {
+  // Not yet implemented.
+  return;
+}
+
 bool os::distribute_processes(uint length, uint* distribution) {
   bool result = false;
   // Find the processor id's of all the available CPUs.
diff -Nru openjdk.orig/hotspot/src/os/windows/vm/os_windows.cpp openjdk/hotspot/src/os/windows/vm/os_windows.cpp
--- openjdk.orig/hotspot/src/os/windows/vm/os_windows.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/os/windows/vm/os_windows.cpp	2012-07-25 15:27:37.283649042 +0100
@@ -710,6 +710,11 @@
   }
 }
 
+void os::set_native_thread_name(const char *name) {
+  // Not yet implemented.
+  return;
+}
+
 bool os::distribute_processes(uint length, uint* distribution) {
   // Not yet implemented.
   return false;
diff -Nru openjdk.orig/hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s openjdk/hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s
--- openjdk.orig/hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s	2012-07-25 15:14:34.510186811 +0100
+++ openjdk/hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s	2012-07-25 15:27:37.283649042 +0100
@@ -1,4 +1,4 @@
-# 
+#
 # Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
@@ -19,9 +19,9 @@
 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 # or visit www.oracle.com if you need additional information or have any
 # questions.
-# 
+#
+
 
- 
 #ifdef __APPLE__
 # Darwin uses _ prefixed global symbols
 #define SYMBOL(s) _ ## s
@@ -31,37 +31,37 @@
 #define ELF_TYPE(name, description) .type name,description
 #endif
 
-	.globl SYMBOL(fixcw)
-	
+        .globl SYMBOL(fixcw)
+
         # NOTE WELL!  The _Copy functions are called directly
-	# from server-compiler-generated code via CallLeafNoFP,
-	# which means that they *must* either not use floating
-	# point or use it in the same manner as does the server
-	# compiler.
-	
+        # from server-compiler-generated code via CallLeafNoFP,
+        # which means that they *must* either not use floating
+        # point or use it in the same manner as does the server
+        # compiler.
+
         .globl SYMBOL(_Copy_conjoint_bytes)
         .globl SYMBOL(_Copy_arrayof_conjoint_bytes)
         .globl SYMBOL(_Copy_conjoint_jshorts_atomic)
-	.globl SYMBOL(_Copy_arrayof_conjoint_jshorts)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jshorts)
         .globl SYMBOL(_Copy_conjoint_jints_atomic)
         .globl SYMBOL(_Copy_arrayof_conjoint_jints)
-	.globl SYMBOL(_Copy_conjoint_jlongs_atomic)
-	.globl SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts)
+        .globl SYMBOL(_Copy_conjoint_jlongs_atomic)
+        .globl SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts)
 
         .globl SYMBOL(_Atomic_cmpxchg_long)
         .globl SYMBOL(_Atomic_move_long)
 
-	.text
+        .text
 
 # Support for void os::Solaris::init_thread_fpu_state() in os_solaris_i486.cpp
 # Set fpu to 53 bit precision.  This happens too early to use a stub.
 # ported from solaris_x86_32.s
         .p2align 4,,15
 SYMBOL(fixcw):
-	pushl    $0x27f
-	fldcw    0(%esp)
-	popl     %eax
-	ret
+        pushl    $0x27f
+        fldcw    0(%esp)
+        popl     %eax
+        ret
 
         .globl  SYMBOL(SafeFetch32), SYMBOL(Fetch32PFI), SYMBOL(Fetch32Resume)
         .globl  SYMBOL(SafeFetchN)
@@ -69,7 +69,7 @@
         ## Instead, the signal handler would call a new SafeFetchTriage(FaultingEIP)
         ## routine to vet the address.  If the address is the faulting LD then
         ## SafeFetchTriage() would return the resume-at EIP, otherwise null.
-	ELF_TYPE(SafeFetch32,@function)
+        ELF_TYPE(SafeFetch32,@function)
         .p2align 4,,15
 SYMBOL(SafeFetch32):
 SYMBOL(SafeFetchN):
@@ -82,7 +82,7 @@
 
 
         .globl  SYMBOL(SpinPause)
-	ELF_TYPE(SpinPause,@function)
+        ELF_TYPE(SpinPause,@function)
         .p2align 4,,15
 SYMBOL(SpinPause):
         rep
@@ -94,7 +94,7 @@
         #                                       void* to,
         #                                       size_t count)
         .p2align 4,,15
-	ELF_TYPE(_Copy_conjoint_bytes,@function)
+        ELF_TYPE(_Copy_conjoint_bytes,@function)
 SYMBOL(_Copy_conjoint_bytes):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
@@ -188,7 +188,7 @@
         addl     $3,%esi
 6:      movb     (%esi),%dl
         movb     %dl,(%edi,%esi,1)
-	subl     $1,%esi
+        subl     $1,%esi
         subl     $1,%ecx
         jnz      6b
 7:      cld
@@ -202,7 +202,7 @@
         #
         # Same as _Copy_conjoint_bytes, except no source alignment check.
         .p2align 4,,15
-	ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)
+        ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)
 SYMBOL(_Copy_arrayof_conjoint_bytes):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
@@ -213,7 +213,7 @@
         leal     -1(%esi,%ecx),%eax   # from + count - 1
         jbe      acb_CopyRight
         cmpl     %eax,%edi
-        jbe      acb_CopyLeft 
+        jbe      acb_CopyLeft
         # copy from low to high
 acb_CopyRight:
         cmpl     $3,%ecx
@@ -262,7 +262,7 @@
         jbe      2f                   # <= 32 dwords
         rep;     smovl
         jmp      4f
-	.=.+8
+        .space 8
 2:      subl     %esi,%edi
         .p2align 4,,15
 3:      movl     (%esi),%edx
@@ -278,7 +278,7 @@
         addl     $3,%esi
 6:      movb     (%esi),%dl
         movb     %dl,(%edi,%esi,1)
-	subl     $1,%esi
+        subl     $1,%esi
         subl     $1,%ecx
         jnz      6b
 7:      cld
@@ -290,7 +290,7 @@
         #                                                void* to,
         #                                                size_t count)
         .p2align 4,,15
-	ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)
+        ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)
 SYMBOL(_Copy_conjoint_jshorts_atomic):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
@@ -301,7 +301,7 @@
         leal     -2(%esi,%ecx,2),%eax # from + count*2 - 2
         jbe      cs_CopyRight
         cmpl     %eax,%edi
-        jbe      cs_CopyLeft 
+        jbe      cs_CopyLeft
         # copy from low to high
 cs_CopyRight:
         # align source address at dword address boundary
@@ -322,7 +322,7 @@
         jbe      2f                   # <= 32 dwords
         # copy aligned dwords
         rep;     smovl
-        jmp      4f 
+        jmp      4f
         # copy aligned dwords
 2:      subl     %esi,%edi
         .p2align 4,,15
@@ -377,7 +377,7 @@
         #                                                 void* to,
         #                                                 size_t count)
         .p2align 4,,15
-	ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)
+        ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)
 SYMBOL(_Copy_arrayof_conjoint_jshorts):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
@@ -388,7 +388,7 @@
         leal     -2(%esi,%ecx,2),%eax # from + count*2 - 2
         jbe      acs_CopyRight
         cmpl     %eax,%edi
-        jbe      acs_CopyLeft 
+        jbe      acs_CopyLeft
 acs_CopyRight:
         movl     %ecx,%eax            # word count
         sarl     %ecx                 # dword count
@@ -397,10 +397,10 @@
         jbe      2f                   # <= 32 dwords
         # copy aligned dwords
         rep;     smovl
-        jmp      4f 
+        jmp      4f
         # copy aligned dwords
-        .=.+5
-2:      subl     %esi,%edi 
+        .space 5
+2:      subl     %esi,%edi
         .p2align 4,,15
 3:      movl     (%esi),%edx
         movl     %edx,(%edi,%esi,1)
@@ -454,8 +454,8 @@
         # Equivalent to
         #   arrayof_conjoint_jints
         .p2align 4,,15
-	ELF_TYPE(_Copy_conjoint_jints_atomic,@function)
-	ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)
+        ELF_TYPE(_Copy_conjoint_jints_atomic,@function)
+        ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)
 SYMBOL(_Copy_conjoint_jints_atomic):
 SYMBOL(_Copy_arrayof_conjoint_jints):
         pushl    %esi
@@ -467,7 +467,7 @@
         leal     -4(%esi,%ecx,4),%eax # from + count*4 - 4
         jbe      ci_CopyRight
         cmpl     %eax,%edi
-        jbe      ci_CopyLeft 
+        jbe      ci_CopyLeft
 ci_CopyRight:
         cmpl     $32,%ecx
         jbe      2f                   # <= 32 dwords
@@ -475,7 +475,7 @@
         popl     %edi
         popl     %esi
         ret
-        .=.+10
+        .space 10
 2:      subl     %esi,%edi
         jmp      4f
         .p2align 4,,15
@@ -510,7 +510,7 @@
         popl     %edi
         popl     %esi
         ret
-	
+
         # Support for void Copy::conjoint_jlongs_atomic(jlong* from,
         #                                               jlong* to,
         #                                               size_t count)
@@ -529,7 +529,7 @@
         #   }
         # }
         .p2align 4,,15
-	ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)
+        ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)
 SYMBOL(_Copy_conjoint_jlongs_atomic):
         movl     4+8(%esp),%ecx       # count
         movl     4+0(%esp),%eax       # from
@@ -558,7 +558,7 @@
         #                                                 void* to,
         #                                                 size_t count)
         .p2align 4,,15
-	ELF_TYPE(_mmx_Copy_arrayof_conjoint_jshorts,@function)
+        ELF_TYPE(_mmx_Copy_arrayof_conjoint_jshorts,@function)
 SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts):
         pushl    %esi
         movl     4+12(%esp),%ecx
@@ -576,7 +576,7 @@
         je       5f
         cmpl     $33,%ecx
         jae      3f
-1:      subl     %esi,%edi 
+1:      subl     %esi,%edi
         .p2align 4,,15
 2:      movl     (%esi),%edx
         movl     %edx,(%edi,%esi,1)
@@ -584,7 +584,7 @@
         subl     $1,%ecx
         jnz      2b
         addl     %esi,%edi
-        jmp      5f 
+        jmp      5f
 3:      smovl # align to 8 bytes, we know we are 4 byte aligned to start
         subl     $1,%ecx
 4:      .p2align 4,,15
@@ -610,13 +610,13 @@
         cmpl     $16,%ecx
         jge      4b
         emms
-	testl    %ecx,%ecx
-	ja       1b
+        testl    %ecx,%ecx
+        ja       1b
 5:      andl     $1,%eax
         je       7f
 6:      movw     (%esi),%dx
         movw     %dx,(%edi)
-7:	popl     %edi
+7:      popl     %edi
         popl     %esi
         ret
 mmx_acs_CopyLeft:
@@ -657,7 +657,7 @@
         #                                   bool is_MP)
         #
         .p2align 4,,15
-	ELF_TYPE(_Atomic_cmpxchg_long,@function)
+        ELF_TYPE(_Atomic_cmpxchg_long,@function)
 SYMBOL(_Atomic_cmpxchg_long):
                                    #  8(%esp) : return PC
         pushl    %ebx              #  4(%esp) : old %ebx
@@ -679,7 +679,7 @@
         # Support for jlong Atomic::load and Atomic::store.
         # void _Atomic_move_long(volatile jlong* src, volatile jlong* dst)
         .p2align 4,,15
-	ELF_TYPE(_Atomic_move_long,@function)
+        ELF_TYPE(_Atomic_move_long,@function)
 SYMBOL(_Atomic_move_long):
         movl     4(%esp), %eax   # src
         fildll    (%eax)
diff -Nru openjdk.orig/hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp openjdk/hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp
--- openjdk.orig/hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	2012-07-25 15:14:34.514186879 +0100
+++ openjdk/hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	2012-07-25 15:27:37.283649042 +0100
@@ -275,7 +275,11 @@
 #endif
 
 address os::current_stack_pointer() {
-#ifdef SPARC_WORKS
+#if defined(__clang__) || defined(__llvm__)
+  register void *esp;
+  __asm__("mov %%"SPELL_REG_SP", %0":"=r"(esp));
+  return (address) esp;
+#elif defined(SPARC_WORKS)
   register void *esp;
   __asm__("mov %%"SPELL_REG_SP", %0":"=r"(esp));
   return (address) ((char*)esp + sizeof(long)*2);
@@ -358,7 +362,7 @@
 }
 
 intptr_t* _get_previous_fp() {
-#ifdef SPARC_WORKS
+#if defined(SPARC_WORKS) || defined(__clang__)
   register intptr_t **ebp;
   __asm__("mov %%"SPELL_REG_FP", %0":"=r"(ebp));
 #else
diff -Nru openjdk.orig/hotspot/src/os_cpu/bsd_zero/vm/bytes_bsd_zero.inline.hpp openjdk/hotspot/src/os_cpu/bsd_zero/vm/bytes_bsd_zero.inline.hpp
--- openjdk.orig/hotspot/src/os_cpu/bsd_zero/vm/bytes_bsd_zero.inline.hpp	2012-07-25 15:14:34.522187019 +0100
+++ openjdk/hotspot/src/os_cpu/bsd_zero/vm/bytes_bsd_zero.inline.hpp	2012-07-25 15:27:37.283649042 +0100
@@ -29,7 +29,7 @@
 // ordering to native byte ordering and vice versa.
 
 #ifdef __APPLE__
-#include <libkern/OSByteOrder.h>
+#  include <libkern/OSByteOrder.h>
 #else
 #  include <sys/endian.h>
 #endif
diff -Nru openjdk.orig/hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp openjdk/hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp
--- openjdk.orig/hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp	2012-07-25 15:14:34.522187019 +0100
+++ openjdk/hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp	2012-07-25 15:27:37.287649111 +0100
@@ -169,7 +169,7 @@
 
   if (info != NULL && thread != NULL) {
     // Handle ALL stack overflow variations here
-    if (sig == SIGSEGV) {
+    if (sig == SIGSEGV || sig == SIGBUS) {
       address addr = (address) info->si_addr;
 
       // check if fault address is within thread stack
@@ -228,7 +228,7 @@
     // of write protecting the memory serialization page.  It write
     // enables the page immediately after protecting it so we can
     // just return to retry the write.
-    if (sig == SIGSEGV &&
+    if ((sig == SIGSEGV || sig == SIGBUS) &&
         os::is_memory_serialize_page(thread, (address) info->si_addr)) {
       // Block current thread until permission is restored.
       os::block_on_serialize_page_trap();
@@ -260,10 +260,11 @@
   }
 #endif // !PRODUCT
 
-  const char *fmt = "caught unhandled signal %d";
-  char buf[64];
+  const char *fmt =
+      "caught unhandled signal " INT32_FORMAT " at address " PTR_FORMAT;
+  char buf[128];
 
-  sprintf(buf, fmt, sig);
+  sprintf(buf, fmt, sig, info->si_addr);
   fatal(buf);
 }
 
@@ -338,7 +339,8 @@
   int rslt = pthread_stackseg_np(pthread_self(), &ss);
 
   if (rslt != 0)
-    fatal(err_msg("pthread_stackseg_np failed with err = %d", rslt));
+    fatal(err_msg("pthread_stackseg_np failed with err = " INT32_FORMAT,
+          rslt));
 
   stack_top = (address) ss.ss_sp;
   stack_bytes  = ss.ss_size;
@@ -350,12 +352,13 @@
 
   // JVM needs to know exact stack location, abort if it fails
   if (rslt != 0)
-    fatal(err_msg("pthread_attr_init failed with err = %d", rslt));
+    fatal(err_msg("pthread_attr_init failed with err = " INT32_FORMAT, rslt));
 
   rslt = pthread_attr_get_np(pthread_self(), &attr);
 
   if (rslt != 0)
-    fatal(err_msg("pthread_attr_get_np failed with err = %d", rslt));
+    fatal(err_msg("pthread_attr_get_np failed with err = " INT32_FORMAT,
+          rslt));
 
   if (pthread_attr_getstackaddr(&attr, (void **) &stack_bottom) != 0 ||
       pthread_attr_getstacksize(&attr, &stack_bytes) != 0) {
@@ -373,13 +376,15 @@
       vm_exit_out_of_memory(0, "pthread_getattr_np");
     }
     else {
-      fatal(err_msg("pthread_getattr_np failed with errno = %d", res));
+      fatal(err_msg("pthread_getattr_np failed with errno = " INT32_FORMAT,
+            res));
     }
   }
 
   res = pthread_attr_getstack(&attr, (void **) &stack_bottom, &stack_bytes);
   if (res != 0) {
-    fatal(err_msg("pthread_attr_getstack failed with errno = %d", res));
+    fatal(err_msg("pthread_attr_getstack failed with errno = " INT32_FORMAT,
+          res));
   }
   stack_top = stack_bottom + stack_bytes;
 
@@ -391,7 +396,8 @@
   size_t guard_bytes;
   res = pthread_attr_getguardsize(&attr, &guard_bytes);
   if (res != 0) {
-    fatal(err_msg("pthread_attr_getguardsize failed with errno = %d", res));
+    fatal(err_msg(
+        "pthread_attr_getguardsize failed with errno = " INT32_FORMAT, res));
   }
   int guard_pages = align_size_up(guard_bytes, page_bytes) / page_bytes;
   assert(guard_bytes == guard_pages * page_bytes, "unaligned guard");
diff -Nru openjdk.orig/hotspot/src/share/vm/code/nmethod.cpp openjdk/hotspot/src/share/vm/code/nmethod.cpp
--- openjdk.orig/hotspot/src/share/vm/code/nmethod.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/code/nmethod.cpp	2012-07-25 15:27:37.287649111 +0100
@@ -50,6 +50,7 @@
 
 // Only bother with this argument setup if dtrace is available
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL8(hotspot, compiled__method__load,
   const char*, int, const char*, int, const char*, int, void*, size_t);
 
@@ -69,6 +70,21 @@
         signature->bytes(), signature->utf8_length());                    \
     }                                                                     \
   }
+#else /* USDT2 */
+#define DTRACE_METHOD_UNLOAD_PROBE(method)                                \
+  {                                                                       \
+    methodOop m = (method);                                               \
+    if (m != NULL) {                                                      \
+      Symbol* klass_name = m->klass_name();                               \
+      Symbol* name = m->name();                                           \
+      Symbol* signature = m->signature();                                 \
+      HOTSPOT_COMPILED_METHOD_UNLOAD(                                     \
+        (char *) klass_name->bytes(), klass_name->utf8_length(),                   \
+        (char *) name->bytes(), name->utf8_length(),                               \
+        (char *) signature->bytes(), signature->utf8_length());                    \
+    }                                                                     \
+  }
+#endif /* USDT2 */
 
 #else //  ndef DTRACE_ENABLED
 
@@ -1473,6 +1489,7 @@
 void nmethod::post_compiled_method_load_event() {
 
   methodOop moop = method();
+#ifndef USDT2
   HS_DTRACE_PROBE8(hotspot, compiled__method__load,
       moop->klass_name()->bytes(),
       moop->klass_name()->utf8_length(),
@@ -1481,6 +1498,16 @@
       moop->signature()->bytes(),
       moop->signature()->utf8_length(),
       insts_begin(), insts_size());
+#else /* USDT2 */
+  HOTSPOT_COMPILED_METHOD_LOAD(
+      (char *) moop->klass_name()->bytes(),
+      moop->klass_name()->utf8_length(),
+      (char *) moop->name()->bytes(),
+      moop->name()->utf8_length(),
+      (char *) moop->signature()->bytes(),
+      moop->signature()->utf8_length(),
+      insts_begin(), insts_size());
+#endif /* USDT2 */
 
   if (JvmtiExport::should_post_compiled_method_load() ||
       JvmtiExport::should_post_compiled_method_unload()) {
diff -Nru openjdk.orig/hotspot/src/share/vm/compiler/compileBroker.cpp openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp
--- openjdk.orig/hotspot/src/share/vm/compiler/compileBroker.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp	2012-07-25 15:27:37.287649111 +0100
@@ -58,6 +58,7 @@
 
 // Only bother with this argument setup if dtrace is available
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL8(hotspot, method__compile__begin,
   char*, intptr_t, char*, intptr_t, char*, intptr_t, char*, intptr_t);
 HS_DTRACE_PROBE_DECL9(hotspot, method__compile__end,
@@ -89,6 +90,35 @@
       signature->bytes(), signature->utf8_length(), (success));          \
   }
 
+#else /* USDT2 */
+
+#define DTRACE_METHOD_COMPILE_BEGIN_PROBE(compiler, method)              \
+  {                                                                      \
+    char* comp_name = (char*)(compiler)->name();                         \
+    Symbol* klass_name = (method)->klass_name();                         \
+    Symbol* name = (method)->name();                                     \
+    Symbol* signature = (method)->signature();                           \
+    HOTSPOT_METHOD_COMPILE_BEGIN(                                       \
+      comp_name, strlen(comp_name),                                      \
+      (char *) klass_name->bytes(), klass_name->utf8_length(),          \
+      (char *) name->bytes(), name->utf8_length(),                       \
+      (char *) signature->bytes(), signature->utf8_length());            \
+  }
+
+#define DTRACE_METHOD_COMPILE_END_PROBE(compiler, method, success)       \
+  {                                                                      \
+    char* comp_name = (char*)(compiler)->name();                         \
+    Symbol* klass_name = (method)->klass_name();                         \
+    Symbol* name = (method)->name();                                     \
+    Symbol* signature = (method)->signature();                           \
+    HOTSPOT_METHOD_COMPILE_END(                                          \
+      comp_name, strlen(comp_name),                                      \
+      (char *) klass_name->bytes(), klass_name->utf8_length(),           \
+      (char *) name->bytes(), name->utf8_length(),                       \
+      (char *) signature->bytes(), signature->utf8_length(), (success)); \
+  }
+#endif /* USDT2 */
+
 #else //  ndef DTRACE_ENABLED
 
 #define DTRACE_METHOD_COMPILE_BEGIN_PROBE(compiler, method)
diff -Nru openjdk.orig/hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp openjdk/hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp
--- openjdk.orig/hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp	2012-07-25 15:27:37.287649111 +0100
@@ -30,11 +30,15 @@
 #include "memory/gcLocker.inline.hpp"
 #include "runtime/interfaceSupport.hpp"
 #include "utilities/dtrace.hpp"
+
+
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL(hs_private, cms__initmark__begin);
 HS_DTRACE_PROBE_DECL(hs_private, cms__initmark__end);
 
 HS_DTRACE_PROBE_DECL(hs_private, cms__remark__begin);
 HS_DTRACE_PROBE_DECL(hs_private, cms__remark__end);
+#endif /* !USDT2 */
 
 //////////////////////////////////////////////////////////
 // Methods in abstract class VM_CMS_Operation
@@ -129,7 +133,12 @@
     // Nothing to do.
     return;
   }
+#ifndef USDT2
   HS_DTRACE_PROBE(hs_private, cms__initmark__begin);
+#else /* USDT2 */
+  HS_PRIVATE_CMS_INITMARK_BEGIN(
+                                );
+#endif /* USDT2 */
 
   GenCollectedHeap* gch = GenCollectedHeap::heap();
   GCCauseSetter gccs(gch, GCCause::_cms_initial_mark);
@@ -140,7 +149,12 @@
   _collector->do_CMS_operation(CMSCollector::CMS_op_checkpointRootsInitial);
 
   VM_CMS_Operation::verify_after_gc();
+#ifndef USDT2
   HS_DTRACE_PROBE(hs_private, cms__initmark__end);
+#else /* USDT2 */
+  HS_PRIVATE_CMS_INITMARK_END(
+                                );
+#endif /* USDT2 */
 }
 
 //////////////////////////////////////////////////////////
@@ -151,7 +165,12 @@
     // Nothing to do.
     return;
   }
+#ifndef USDT2
   HS_DTRACE_PROBE(hs_private, cms__remark__begin);
+#else /* USDT2 */
+  HS_PRIVATE_CMS_REMARK_BEGIN(
+                                );
+#endif /* USDT2 */
 
   GenCollectedHeap* gch = GenCollectedHeap::heap();
   GCCauseSetter gccs(gch, GCCause::_cms_final_remark);
@@ -162,7 +181,12 @@
   _collector->do_CMS_operation(CMSCollector::CMS_op_checkpointRootsFinal);
 
   VM_CMS_Operation::verify_after_gc();
+#ifndef USDT2
   HS_DTRACE_PROBE(hs_private, cms__remark__end);
+#else /* USDT2 */
+  HS_PRIVATE_CMS_REMARK_END(
+                                );
+#endif /* USDT2 */
 }
 
 // VM operation to invoke a concurrent collection of a
diff -Nru openjdk.orig/hotspot/src/share/vm/gc_implementation/shared/vmGCOperations.cpp openjdk/hotspot/src/share/vm/gc_implementation/shared/vmGCOperations.cpp
--- openjdk.orig/hotspot/src/share/vm/gc_implementation/shared/vmGCOperations.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/gc_implementation/shared/vmGCOperations.cpp	2012-07-25 15:27:37.287649111 +0100
@@ -40,20 +40,32 @@
 #include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
 #endif
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL1(hotspot, gc__begin, bool);
 HS_DTRACE_PROBE_DECL(hotspot, gc__end);
+#endif /* !USDT2 */
 
 // The same dtrace probe can't be inserted in two different files, so we
 // have to call it here, so it's only in one file.  Can't create new probes
 // for the other file anymore.   The dtrace probes have to remain stable.
 void VM_GC_Operation::notify_gc_begin(bool full) {
+#ifndef USDT2
   HS_DTRACE_PROBE1(hotspot, gc__begin, full);
   HS_DTRACE_WORKAROUND_TAIL_CALL_BUG();
+#else /* USDT2 */
+  HOTSPOT_GC_BEGIN(
+                   full);
+#endif /* USDT2 */
 }
 
 void VM_GC_Operation::notify_gc_end() {
+#ifndef USDT2
   HS_DTRACE_PROBE(hotspot, gc__end);
   HS_DTRACE_WORKAROUND_TAIL_CALL_BUG();
+#else /* USDT2 */
+  HOTSPOT_GC_END(
+);
+#endif /* USDT2 */
 }
 
 void VM_GC_Operation::acquire_pending_list_lock() {
diff -Nru openjdk.orig/hotspot/src/share/vm/oops/instanceKlass.cpp openjdk/hotspot/src/share/vm/oops/instanceKlass.cpp
--- openjdk.orig/hotspot/src/share/vm/oops/instanceKlass.cpp	2012-07-25 15:14:34.550187503 +0100
+++ openjdk/hotspot/src/share/vm/oops/instanceKlass.cpp	2012-07-25 15:27:37.287649111 +0100
@@ -80,6 +80,8 @@
 
 #ifdef DTRACE_ENABLED
 
+#ifndef USDT2
+
 HS_DTRACE_PROBE_DECL4(hotspot, class__initialization__required,
   char*, intptr_t, oop, intptr_t);
 HS_DTRACE_PROBE_DECL5(hotspot, class__initialization__recursive,
@@ -122,6 +124,42 @@
     HS_DTRACE_PROBE5(hotspot, class__initialization__##type,     \
       data, len, (clss)->class_loader(), thread_type, wait);     \
   }
+#else /* USDT2 */
+
+#define HOTSPOT_CLASS_INITIALIZATION_required HOTSPOT_CLASS_INITIALIZATION_REQUIRED
+#define HOTSPOT_CLASS_INITIALIZATION_recursive HOTSPOT_CLASS_INITIALIZATION_RECURSIVE
+#define HOTSPOT_CLASS_INITIALIZATION_concurrent HOTSPOT_CLASS_INITIALIZATION_CONCURRENT
+#define HOTSPOT_CLASS_INITIALIZATION_erroneous HOTSPOT_CLASS_INITIALIZATION_ERRONEOUS
+#define HOTSPOT_CLASS_INITIALIZATION_super__failed HOTSPOT_CLASS_INITIALIZATION_SUPER_FAILED
+#define HOTSPOT_CLASS_INITIALIZATION_clinit HOTSPOT_CLASS_INITIALIZATION_CLINIT
+#define HOTSPOT_CLASS_INITIALIZATION_error HOTSPOT_CLASS_INITIALIZATION_ERROR
+#define HOTSPOT_CLASS_INITIALIZATION_end HOTSPOT_CLASS_INITIALIZATION_END
+#define DTRACE_CLASSINIT_PROBE(type, clss, thread_type)          \
+  {                                                              \
+    char* data = NULL;                                           \
+    int len = 0;                                                 \
+    Symbol* name = (clss)->name();                               \
+    if (name != NULL) {                                          \
+      data = (char*)name->bytes();                               \
+      len = name->utf8_length();                                 \
+    }                                                            \
+    HOTSPOT_CLASS_INITIALIZATION_##type(                         \
+      data, len, (clss)->class_loader(), thread_type);           \
+  }
+
+#define DTRACE_CLASSINIT_PROBE_WAIT(type, clss, thread_type, wait) \
+  {                                                              \
+    char* data = NULL;                                           \
+    int len = 0;                                                 \
+    Symbol* name = (clss)->name();                               \
+    if (name != NULL) {                                          \
+      data = (char*)name->bytes();                               \
+      len = name->utf8_length();                                 \
+    }                                                            \
+    HOTSPOT_CLASS_INITIALIZATION_##type(                         \
+      data, len, (clss)->class_loader(), thread_type, wait);     \
+  }
+#endif /* USDT2 */
 
 #else //  ndef DTRACE_ENABLED
 
diff -Nru openjdk.orig/hotspot/src/share/vm/opto/connode.cpp openjdk/hotspot/src/share/vm/opto/connode.cpp
--- openjdk.orig/hotspot/src/share/vm/opto/connode.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/opto/connode.cpp	2012-07-25 15:27:37.287649111 +0100
@@ -721,12 +721,7 @@
   if( t == Type::TOP ) return Type::TOP;
   if( t == Type::FLOAT ) return Type::DOUBLE;
   const TypeF *tf = t->is_float_constant();
-#ifndef IA64
   return TypeD::make( (double)tf->getf() );
-#else
-  float x = tf->getf();
-  return TypeD::make( (x == 0.0f) ? (double)x : (double)x + ia64_double_zero );
-#endif
 }
 
 //=============================================================================
diff -Nru openjdk.orig/hotspot/src/share/vm/prims/jni.cpp openjdk/hotspot/src/share/vm/prims/jni.cpp
--- openjdk.orig/hotspot/src/share/vm/prims/jni.cpp	2012-07-25 15:14:34.558187641 +0100
+++ openjdk/hotspot/src/share/vm/prims/jni.cpp	2012-07-25 15:29:05.953165893 +0100
@@ -110,6 +110,7 @@
 //   return_value = 5;
 //   return return_value;
 // JNI_END
+#ifndef USDT2
 #define DT_RETURN_MARK_DECL(name, type)                                    \
   HS_DTRACE_PROBE_DECL1(hotspot_jni, name##__return, type);                \
   DTRACE_ONLY(                                                             \
@@ -134,6 +135,30 @@
     }                                                                      \
   )
 
+#else /* USDT2 */
+
+#define DT_RETURN_MARK_DECL(name, type, probe)                             \
+  DTRACE_ONLY(                                                             \
+    class DTraceReturnProbeMark_##name {                                   \
+     public:                                                               \
+      const type& _ret_ref;                                                \
+      DTraceReturnProbeMark_##name(const type& v) : _ret_ref(v) {}         \
+      ~DTraceReturnProbeMark_##name() {                                    \
+        probe;                                                             \
+      }                                                                    \
+    }                                                                      \
+  )
+// Void functions are simpler since there's no return value
+#define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
+  DTRACE_ONLY(                                                             \
+    class DTraceReturnProbeMark_##name {                                   \
+     public:                                                               \
+      ~DTraceReturnProbeMark_##name() {                                    \
+        probe;                                                             \
+      }                                                                    \
+    }                                                                      \
+  )
+#endif /* USDT2 */
 
 // Place these macros in the function to mark the return.  Non-void
 // functions need the type and address of the return value.
@@ -162,9 +187,15 @@
 
 // Choose DT_RETURN_MARK macros  based on the type: float/double -> void
 // (dtrace doesn't do FP yet)
+#ifndef USDT2
 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type) \
   FP_SELECT(TypeName, \
     DT_RETURN_MARK_DECL(name, type), DT_VOID_RETURN_MARK_DECL(name) )
+#else /* USDT2 */
+#define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
+  FP_SELECT(TypeName, \
+    DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
+#endif /* USDT2 */
 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
   FP_SELECT(TypeName, \
     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
@@ -323,14 +354,24 @@
 
 // Implementation of JNI entries
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(DefineClass, jclass);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(DefineClass, jclass
+                    , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
                                   const jbyte *buf, jsize bufLen))
   JNIWrapper("DefineClass");
 
+#ifndef USDT2
   DTRACE_PROBE5(hotspot_jni, DefineClass__entry,
     env, name, loaderRef, buf, bufLen);
+#else /* USDT2 */
+  HOTSPOT_JNI_DEFINECLASS_ENTRY(
+    env, (char*) name, loaderRef, (char*) buf, bufLen);
+#endif /* USDT2 */
   jclass cls = NULL;
   DT_RETURN_MARK(DefineClass, jclass, (const jclass&)cls);
 
@@ -376,11 +417,21 @@
 
 static bool first_time_FindClass = true;
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(FindClass, jclass);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(FindClass, jclass
+                    , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
   JNIWrapper("FindClass");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, FindClass__entry, env, name);
+#else /* USDT2 */
+  HOTSPOT_JNI_FINDCLASS_ENTRY(
+                              env, (char *)name);
+#endif /* USDT2 */
 
   jclass result = NULL;
   DT_RETURN_MARK(FindClass, jclass, (const jclass&)result);
@@ -444,11 +495,21 @@
   return result;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
+                    , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
   JNIWrapper("FromReflectedMethod");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, FromReflectedMethod__entry, env, method);
+#else /* USDT2 */
+  HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(
+                                        env, method);
+#endif /* USDT2 */
   jmethodID ret = NULL;
   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&)ret);
 
@@ -475,11 +536,21 @@
   return ret;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
+                    , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
   JNIWrapper("FromReflectedField");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, FromReflectedField__entry, env, field);
+#else /* USDT2 */
+  HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(
+                                       env, field);
+#endif /* USDT2 */
   jfieldID ret = NULL;
   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&)ret);
 
@@ -514,11 +585,21 @@
   return ret;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
+                    , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
   JNIWrapper("ToReflectedMethod");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, ToReflectedMethod__entry, env, cls, method_id, isStatic);
+#else /* USDT2 */
+  HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(
+                                      env, cls, (uintptr_t) method_id, isStatic);
+#endif /* USDT2 */
   jobject ret = NULL;
   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&)ret);
 
@@ -534,11 +615,21 @@
   return ret;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(GetSuperclass, jclass);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(GetSuperclass, jclass
+                    , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
   JNIWrapper("GetSuperclass");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetSuperclass__entry, env, sub);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSUPERCLASS_ENTRY(
+                                  env, sub);
+#endif /* USDT2 */
   jclass obj = NULL;
   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&)obj);
 
@@ -567,13 +658,23 @@
 
 JNI_QUICK_ENTRY(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
   JNIWrapper("IsSubclassOf");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, IsAssignableFrom__entry, env, sub, super);
+#else /* USDT2 */
+  HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(
+                                     env, sub, super);
+#endif /* USDT2 */
   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
   oop super_mirror = JNIHandles::resolve_non_null(super);
   if (java_lang_Class::is_primitive(sub_mirror) ||
       java_lang_Class::is_primitive(super_mirror)) {
     jboolean ret = (sub_mirror == super_mirror);
+#ifndef USDT2
     DTRACE_PROBE1(hotspot_jni, IsAssignableFrom__return, ret);
+#else /* USDT2 */
+    HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(
+                                        ret);
+#endif /* USDT2 */
     return ret;
   }
   klassOop sub_klass   = java_lang_Class::as_klassOop(sub_mirror);
@@ -581,15 +682,30 @@
   assert(sub_klass != NULL && super_klass != NULL, "invalid arguments to jni_IsAssignableFrom");
   jboolean ret = Klass::cast(sub_klass)->is_subtype_of(super_klass) ?
                    JNI_TRUE : JNI_FALSE;
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, IsAssignableFrom__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(
+                                      ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(Throw, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(Throw, jint
+                    , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
   JNIWrapper("Throw");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, Throw__entry, env, obj);
+#else /* USDT2 */
+  HOTSPOT_JNI_THROW_ENTRY(
+ env, obj);
+#endif /* USDT2 */
   jint ret = JNI_OK;
   DT_RETURN_MARK(Throw, jint, (const jint&)ret);
 
@@ -597,11 +713,21 @@
   ShouldNotReachHere();
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(ThrowNew, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(ThrowNew, jint
+                    , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
   JNIWrapper("ThrowNew");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, ThrowNew__entry, env, clazz, message);
+#else /* USDT2 */
+  HOTSPOT_JNI_THROWNEW_ENTRY(
+                             env, clazz, (char *) message);
+#endif /* USDT2 */
   jint ret = JNI_OK;
   DT_RETURN_MARK(ThrowNew, jint, (const jint&)ret);
 
@@ -630,18 +756,33 @@
 
 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
   JNIWrapper("ExceptionOccurred");
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, ExceptionOccurred__entry, env);
+#else /* USDT2 */
+  HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(
+                                      env);
+#endif /* USDT2 */
   jni_check_async_exceptions(thread);
   oop exception = thread->pending_exception();
   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, ExceptionOccurred__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(
+                                       ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 
 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
   JNIWrapper("ExceptionDescribe");
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, ExceptionDescribe__entry, env);
+#else /* USDT2 */
+  HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(
+                                      env);
+#endif /* USDT2 */
   if (thread->has_pending_exception()) {
     Handle ex(thread, thread->pending_exception());
     thread->clear_pending_exception();
@@ -677,13 +818,23 @@
       }
     }
   }
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, ExceptionDescribe__return);
+#else /* USDT2 */
+  HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN(
+                                       );
+#endif /* USDT2 */
 JNI_END
 
 
 JNI_QUICK_ENTRY(void, jni_ExceptionClear(JNIEnv *env))
   JNIWrapper("ExceptionClear");
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, ExceptionClear__entry, env);
+#else /* USDT2 */
+  HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(
+                                   env);
+#endif /* USDT2 */
 
   // The jni code might be using this API to clear java thrown exception.
   // So just mark jvmti thread exception state as exception caught.
@@ -692,13 +843,23 @@
     state->set_exception_caught();
   }
   thread->clear_pending_exception();
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, ExceptionClear__return);
+#else /* USDT2 */
+  HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN(
+                                    );
+#endif /* USDT2 */
 JNI_END
 
 
 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
   JNIWrapper("FatalError");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, FatalError__entry, env, msg);
+#else /* USDT2 */
+  HOTSPOT_JNI_FATALERROR_ENTRY(
+                               env, (char *) msg);
+#endif /* USDT2 */
   tty->print_cr("FATAL ERROR in native method: %s", msg);
   thread->print_stack();
   os::abort(); // Dump core and abort
@@ -707,10 +868,20 @@
 
 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
   JNIWrapper("PushLocalFrame");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, PushLocalFrame__entry, env, capacity);
+#else /* USDT2 */
+  HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(
+                                   env, capacity);
+#endif /* USDT2 */
   //%note jni_11
   if (capacity < 0 && capacity > MAX_REASONABLE_LOCAL_CAPACITY) {
+#ifndef USDT2
     DTRACE_PROBE1(hotspot_jni, PushLocalFrame__return, JNI_ERR);
+#else /* USDT2 */
+    HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(
+                                      (uint32_t)JNI_ERR);
+#endif /* USDT2 */
     return JNI_ERR;
   }
   JNIHandleBlock* old_handles = thread->active_handles();
@@ -719,14 +890,24 @@
   new_handles->set_pop_frame_link(old_handles);
   thread->set_active_handles(new_handles);
   jint ret = JNI_OK;
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, PushLocalFrame__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(
+                                    ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 
 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
   JNIWrapper("PopLocalFrame");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, PopLocalFrame__entry, env, result);
+#else /* USDT2 */
+  HOTSPOT_JNI_POPLOCALFRAME_ENTRY(
+                                  env, result);
+#endif /* USDT2 */
   //%note jni_11
   Handle result_handle(thread, JNIHandles::resolve(result));
   JNIHandleBlock* old_handles = thread->active_handles();
@@ -741,71 +922,141 @@
     JNIHandleBlock::release_block(old_handles, thread); // may block
     result = JNIHandles::make_local(thread, result_handle());
   }
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, PopLocalFrame__return, result);
+#else /* USDT2 */
+  HOTSPOT_JNI_POPLOCALFRAME_RETURN(
+                                   result);
+#endif /* USDT2 */
   return result;
 JNI_END
 
 
 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
   JNIWrapper("NewGlobalRef");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, NewGlobalRef__entry, env, ref);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWGLOBALREF_ENTRY(
+                                 env, ref);
+#endif /* USDT2 */
   Handle ref_handle(thread, JNIHandles::resolve(ref));
   jobject ret = JNIHandles::make_global(ref_handle);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, NewGlobalRef__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWGLOBALREF_RETURN(
+                                  ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 // Must be JNI_ENTRY (with HandleMark)
 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
   JNIWrapper("DeleteGlobalRef");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, DeleteGlobalRef__entry, env, ref);
+#else /* USDT2 */
+  HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(
+                                    env, ref);
+#endif /* USDT2 */
   JNIHandles::destroy_global(ref);
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, DeleteGlobalRef__return);
+#else /* USDT2 */
+  HOTSPOT_JNI_DELETEGLOBALREF_RETURN(
+                                     );
+#endif /* USDT2 */
 JNI_END
 
 JNI_QUICK_ENTRY(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
   JNIWrapper("DeleteLocalRef");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, DeleteLocalRef__entry, env, obj);
+#else /* USDT2 */
+  HOTSPOT_JNI_DELETELOCALREF_ENTRY(
+                                   env, obj);
+#endif /* USDT2 */
   JNIHandles::destroy_local(obj);
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, DeleteLocalRef__return);
+#else /* USDT2 */
+  HOTSPOT_JNI_DELETELOCALREF_RETURN(
+                                    );
+#endif /* USDT2 */
 JNI_END
 
 JNI_QUICK_ENTRY(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
   JNIWrapper("IsSameObject");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, IsSameObject__entry, env, r1, r2);
+#else /* USDT2 */
+  HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(
+                                 env, r1, r2);
+#endif /* USDT2 */
   oop a = JNIHandles::resolve(r1);
   oop b = JNIHandles::resolve(r2);
   jboolean ret = (a == b) ? JNI_TRUE : JNI_FALSE;
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, IsSameObject__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_ISSAMEOBJECT_RETURN(
+                                  ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 
 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
   JNIWrapper("NewLocalRef");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, NewLocalRef__entry, env, ref);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWLOCALREF_ENTRY(
+                                env, ref);
+#endif /* USDT2 */
   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, NewLocalRef__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWLOCALREF_RETURN(
+                                 ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
   JNIWrapper("EnsureLocalCapacity");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, EnsureLocalCapacity__entry, env, capacity);
+#else /* USDT2 */
+  HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(
+                                        env, capacity);
+#endif /* USDT2 */
   jint ret;
   if (capacity >= 0 && capacity <= MAX_REASONABLE_LOCAL_CAPACITY) {
     ret = JNI_OK;
   } else {
     ret = JNI_ERR;
   }
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, EnsureLocalCapacity__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(
+                                         ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 // Return the Handle Type
 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
   JNIWrapper("GetObjectRefType");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetObjectRefType__entry, env, obj);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(
+                                     env, obj);
+#endif /* USDT2 */
   jobjectRefType ret;
   if (JNIHandles::is_local_handle(thread, obj) ||
       JNIHandles::is_frame_handle(thread, obj))
@@ -816,7 +1067,12 @@
     ret = JNIWeakGlobalRefType;
   else
     ret = JNIInvalidRefType;
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetObjectRefType__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN(
+                                      (void *) ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
@@ -1167,12 +1423,22 @@
   return ih;
 }
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(AllocObject, jobject);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(AllocObject, jobject
+                    , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
   JNIWrapper("AllocObject");
 
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, AllocObject__entry, env, clazz);
+#else /* USDT2 */
+  HOTSPOT_JNI_ALLOCOBJECT_ENTRY(
+                                env, clazz);
+#endif /* USDT2 */
   jobject ret = NULL;
   DT_RETURN_MARK(AllocObject, jobject, (const jobject&)ret);
 
@@ -1181,11 +1447,21 @@
   return ret;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(NewObjectA, jobject);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(NewObjectA, jobject
+                    , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
   JNIWrapper("NewObjectA");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, NewObjectA__entry, env, clazz, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWOBJECTA_ENTRY(
+                               env, clazz, (uintptr_t) methodID);
+#endif /* USDT2 */
   jobject obj = NULL;
   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
 
@@ -1197,11 +1473,21 @@
   return obj;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(NewObjectV, jobject);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(NewObjectV, jobject
+                    , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
   JNIWrapper("NewObjectV");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, NewObjectV__entry, env, clazz, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWOBJECTV_ENTRY(
+                               env, clazz, (uintptr_t) methodID);
+#endif /* USDT2 */
   jobject obj = NULL;
   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&)obj);
 
@@ -1213,11 +1499,21 @@
   return obj;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(NewObject, jobject);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(NewObject, jobject
+                    , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
   JNIWrapper("NewObject");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, NewObject__entry, env, clazz, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWOBJECT_ENTRY(
+                              env, clazz, (uintptr_t) methodID);
+#endif /* USDT2 */
   jobject obj = NULL;
   DT_RETURN_MARK(NewObject, jobject, (const jobject&)obj);
 
@@ -1235,17 +1531,32 @@
 
 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
   JNIWrapper("GetObjectClass");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetObjectClass__entry, env, obj);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(
+                                   env, obj);
+#endif /* USDT2 */
   klassOop k = JNIHandles::resolve_non_null(obj)->klass();
   jclass ret =
     (jclass) JNIHandles::make_local(env, Klass::cast(k)->java_mirror());
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetObjectClass__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETOBJECTCLASS_RETURN(
+                                    ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 JNI_QUICK_ENTRY(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
   JNIWrapper("IsInstanceOf");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, IsInstanceOf__entry, env, obj, clazz);
+#else /* USDT2 */
+  HOTSPOT_JNI_ISINSTANCEOF_ENTRY(
+                                 env, obj, clazz);
+#endif /* USDT2 */
   jboolean ret = JNI_TRUE;
   if (obj != NULL) {
     ret = JNI_FALSE;
@@ -1255,7 +1566,12 @@
       ret = JNIHandles::resolve_non_null(obj)->is_a(k) ? JNI_TRUE : JNI_FALSE;
     }
   }
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, IsInstanceOf__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_ISINSTANCEOF_RETURN(
+                                  ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
@@ -1317,9 +1633,19 @@
 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
           const char *name, const char *sig))
   JNIWrapper("GetMethodID");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, GetMethodID__entry, env, clazz, name, sig);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETMETHODID_ENTRY(
+                                env, clazz, (char *) name, (char *) sig);
+#endif /* USDT2 */
   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetMethodID__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETMETHODID_RETURN(
+                                 (uintptr_t) ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
@@ -1327,9 +1653,19 @@
 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
           const char *name, const char *sig))
   JNIWrapper("GetStaticMethodID");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, GetStaticMethodID__entry, env, clazz, name, sig);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(
+                                      env, (char *) clazz, (char *) name, (char *)sig);
+#endif /* USDT2 */
   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetStaticMethodID__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTATICMETHODID_RETURN(
+                                       (uintptr_t) ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
@@ -1339,7 +1675,7 @@
 // Calling Methods
 //
 
-
+#ifndef USDT2
 #define DEFINE_CALLMETHOD(ResultType, Result, Tag) \
 \
   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType);\
@@ -1350,7 +1686,7 @@
           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
   JNIWrapper("Call" XSTR(Result) "Method"); \
 \
-  DTRACE_PROBE3(hotspot_jni, Call##Result##Method__entry, env, obj, methodID);\
+  DTRACE_PROBE3(hotspot_jni, Call##Result##Method__entry, env, obj, methodID); \
   ResultType ret = 0;\
   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
                      (const ResultType&)ret);\
@@ -1370,7 +1706,7 @@
           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
   JNIWrapper("Call" XSTR(Result) "MethodV"); \
 \
-  DTRACE_PROBE3(hotspot_jni, Call##Result##MethodV__entry, env, obj, methodID);\
+  DTRACE_PROBE3(hotspot_jni, Call##Result##MethodV__entry, env, obj, methodID); \
   ResultType ret = 0;\
   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
                      (const ResultType&)ret);\
@@ -1386,7 +1722,7 @@
 JNI_ENTRY(ResultType, \
           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
   JNIWrapper("Call" XSTR(Result) "MethodA"); \
-  DTRACE_PROBE3(hotspot_jni, Call##Result##MethodA__entry, env, obj, methodID);\
+  DTRACE_PROBE3(hotspot_jni, Call##Result##MethodA__entry, env, obj, methodID); \
   ResultType ret = 0;\
   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
                      (const ResultType&)ret);\
@@ -1414,9 +1750,183 @@
 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV);
 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA);
 
+#else /* USDT2 */
+
+#define DEFINE_CALLMETHOD(ResultType, Result, Tag \
+                          , EntryProbe, ReturnProbe)    \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
+                          , ReturnProbe);                          \
+\
+JNI_ENTRY(ResultType, \
+          jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
+  JNIWrapper("Call" XSTR(Result) "Method"); \
+\
+  EntryProbe; \
+  ResultType ret = 0;\
+  DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
+                     (const ResultType&)ret);\
+\
+  va_list args; \
+  va_start(args, methodID); \
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherVaArg ap(methodID, args); \
+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \
+  va_end(args); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
+                  , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
+                  , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
+                  , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
+                  , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
+
+DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
+                  , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHOD(jint,     Int,     T_INT,
+                  HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
+                  , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
+                  , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
+DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
+                  , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
+
+#define DEFINE_CALLMETHODV(ResultType, Result, Tag \
+                          , EntryProbe, ReturnProbe)    \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
+                          , ReturnProbe);                          \
+\
+JNI_ENTRY(ResultType, \
+          jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
+  JNIWrapper("Call" XSTR(Result) "MethodV"); \
+\
+  EntryProbe;\
+  ResultType ret = 0;\
+  DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
+                     (const ResultType&)ret);\
+\
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherVaArg ap(methodID, args); \
+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
+                  , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
+                  , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
+                  , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
+                  , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
+
+DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
+                  , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODV(jint,     Int,     T_INT,
+                  HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
+                  , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
+                  , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
+DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
+                  , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
+
+#define DEFINE_CALLMETHODA(ResultType, Result, Tag \
+                          , EntryProbe, ReturnProbe)    \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
+                          , ReturnProbe);                          \
+\
+JNI_ENTRY(ResultType, \
+          jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
+  JNIWrapper("Call" XSTR(Result) "MethodA"); \
+  EntryProbe; \
+  ResultType ret = 0;\
+  DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
+                     (const ResultType&)ret);\
+\
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherArray ap(methodID, args); \
+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
+                  , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
+                  , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
+                  , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
+                  , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
+
+DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
+                  , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODA(jint,     Int,     T_INT,
+                  HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
+DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
+                  , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
+                  , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
+DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
+                  , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
+                  HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
+
+DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
+DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
+DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
+
+#endif /* USDT2 */
+
 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
   JNIWrapper("CallVoidMethod");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, CallVoidMethod__entry, env, obj, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(
+                                   env, obj, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallVoidMethod);
 
   va_list args;
@@ -1430,7 +1940,12 @@
 
 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
   JNIWrapper("CallVoidMethodV");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, CallVoidMethodV__entry, env, obj, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(
+                                    env, obj, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallVoidMethodV);
 
   JavaValue jvalue(T_VOID);
@@ -1441,7 +1956,12 @@
 
 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
   JNIWrapper("CallVoidMethodA");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, CallVoidMethodA__entry, env, obj, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(
+                                    env, obj, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallVoidMethodA);
 
   JavaValue jvalue(T_VOID);
@@ -1450,6 +1970,7 @@
 JNI_END
 
 
+#ifndef USDT2
 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag) \
 \
   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType);\
@@ -1522,11 +2043,188 @@
 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV);
 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA);
 
+#else /* USDT2 */
+
+#define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
+                                    , EntryProbe, ReturnProbe)      \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
+                          , ReturnProbe);\
+\
+JNI_ENTRY(ResultType, \
+          jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
+  JNIWrapper("CallNonvitual" XSTR(Result) "Method"); \
+\
+  EntryProbe;\
+  ResultType ret;\
+  DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
+                     (const ResultType&)ret);\
+\
+  va_list args; \
+  va_start(args, methodID); \
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherVaArg ap(methodID, args); \
+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \
+  va_end(args); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
+                            , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
+                            , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
+                            , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
+                            , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
+
+DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
+                            , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
+                            , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
+                            , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+// Float and double probes don't return value because dtrace doesn't currently support it
+                            HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
+                            , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
+DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
+                            , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
+
+#define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
+                                    , EntryProbe, ReturnProbe)      \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
+                          , ReturnProbe);\
+\
+JNI_ENTRY(ResultType, \
+          jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
+  JNIWrapper("CallNonvitual" XSTR(Result) "MethodV"); \
+\
+  EntryProbe;\
+  ResultType ret;\
+  DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
+                     (const ResultType&)ret);\
+\
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherVaArg ap(methodID, args); \
+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
+                            , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
+                            , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
+                            , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
+                            , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
+
+DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
+                            , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
+                            , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
+                            , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+// Float and double probes don't return value because dtrace doesn't currently support it
+                            HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
+                            , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
+DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
+                            , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
+
+#define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
+                                    , EntryProbe, ReturnProbe)      \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
+                          , ReturnProbe);\
+\
+JNI_ENTRY(ResultType, \
+          jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
+  JNIWrapper("CallNonvitual" XSTR(Result) "MethodA"); \
+\
+  EntryProbe;\
+  ResultType ret;\
+  DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
+                     (const ResultType&)ret);\
+\
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherArray ap(methodID, args); \
+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
+                            , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
+                            , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
+                            , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
+                            , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
+
+DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
+                            , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
+                            , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
+                            , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+// Float and double probes don't return value because dtrace doesn't currently support it
+                            HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
+DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
+                            , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
+DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
+                            , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
+                            HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
+
+DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
+                         , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
+DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
+                         , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
+DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
+                         , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
+#endif /* USDT2 */
+
 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
   JNIWrapper("CallNonvirtualVoidMethod");
 
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, CallNonvirtualVoidMethod__entry,
                env, obj, cls, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(
+               env, obj, cls, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
 
   va_list args;
@@ -1541,8 +2239,13 @@
 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
   JNIWrapper("CallNonvirtualVoidMethodV");
 
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, CallNonvirtualVoidMethodV__entry,
                env, obj, cls, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
+               env, obj, cls, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
 
   JavaValue jvalue(T_VOID);
@@ -1553,8 +2256,13 @@
 
 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
   JNIWrapper("CallNonvirtualVoidMethodA");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, CallNonvirtualVoidMethodA__entry,
                 env, obj, cls, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
+                env, obj, cls, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
   JavaValue jvalue(T_VOID);
   JNI_ArgumentPusherArray ap(methodID, args);
@@ -1562,6 +2270,7 @@
 JNI_END
 
 
+#ifndef USDT2
 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag) \
 \
   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType);\
@@ -1634,9 +2343,190 @@
 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV);
 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA);
 
+#else /* USDT2 */
+
+#define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
+                                , EntryProbe, ResultProbe) \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
+                          , ResultProbe);                               \
+\
+JNI_ENTRY(ResultType, \
+          jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
+  JNIWrapper("CallStatic" XSTR(Result) "Method"); \
+\
+  EntryProbe; \
+  ResultType ret = 0;\
+  DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
+                     (const ResultType&)ret);\
+\
+  va_list args; \
+  va_start(args, methodID); \
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherVaArg ap(methodID, args); \
+  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_0); \
+  va_end(args); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
+                        , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
+                        , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
+                        , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
+                        , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
+
+DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
+                        , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
+                        , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
+                        , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
+                        , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
+DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
+                        , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
+
+#define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
+                                , EntryProbe, ResultProbe) \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
+                          , ResultProbe);                               \
+\
+JNI_ENTRY(ResultType, \
+          jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
+  JNIWrapper("CallStatic" XSTR(Result) "MethodV"); \
+\
+  EntryProbe; \
+  ResultType ret = 0;\
+  DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
+                     (const ResultType&)ret);\
+\
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherVaArg ap(methodID, args); \
+  /* Make sure class is initialized before trying to invoke its method */ \
+  KlassHandle k(THREAD, java_lang_Class::as_klassOop(JNIHandles::resolve_non_null(cls))); \
+  Klass::cast(k())->initialize(CHECK_0); \
+  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_0); \
+  va_end(args); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
+                        , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
+                        , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
+                        , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
+                        , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
+
+DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
+                        , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
+                        , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
+                        , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
+                        , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
+DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
+                        , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
+
+#define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
+                                , EntryProbe, ResultProbe) \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
+                          , ResultProbe);                               \
+\
+JNI_ENTRY(ResultType, \
+          jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
+  JNIWrapper("CallStatic" XSTR(Result) "MethodA"); \
+\
+  EntryProbe; \
+  ResultType ret = 0;\
+  DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
+                     (const ResultType&)ret);\
+\
+  JavaValue jvalue(Tag); \
+  JNI_ArgumentPusherArray ap(methodID, args); \
+  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_0); \
+  ret = jvalue.get_##ResultType(); \
+  return ret;\
+JNI_END
+
+// the runtime type of subword integral basic types is integer
+DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
+                        , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
+                        , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
+                        , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
+                        , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
+
+DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
+                        , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
+                        , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
+DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
+                        , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
+                        , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
+DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
+                        , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
+                        HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
+
+DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
+                         , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
+DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
+                         , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
+DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
+                         , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
+#endif /* USDT2 */
+
 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
   JNIWrapper("CallStaticVoidMethod");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, CallStaticVoidMethod__entry, env, cls, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(
+                                         env, cls, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
 
   va_list args;
@@ -1650,7 +2540,12 @@
 
 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
   JNIWrapper("CallStaticVoidMethodV");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, CallStaticVoidMethodV__entry, env, cls, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(
+                                          env, cls, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
 
   JavaValue jvalue(T_VOID);
@@ -1661,7 +2556,12 @@
 
 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
   JNIWrapper("CallStaticVoidMethodA");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, CallStaticVoidMethodA__entry, env, cls, methodID);
+#else /* USDT2 */
+  HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(
+                                          env, cls, (uintptr_t) methodID);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
 
   JavaValue jvalue(T_VOID);
@@ -1675,12 +2575,22 @@
 //
 
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(GetFieldID, jfieldID);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(GetFieldID, jfieldID
+                    , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
           const char *name, const char *sig))
   JNIWrapper("GetFieldID");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, GetFieldID__entry, env, clazz, name, sig);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETFIELDID_ENTRY(
+                               env, clazz, (char *) name, (char *) sig);
+#endif /* USDT2 */
   jfieldID ret = 0;
   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&)ret);
 
@@ -1712,7 +2622,12 @@
 
 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
   JNIWrapper("GetObjectField");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, GetObjectField__entry, env, obj, fieldID);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(
+                                   env, obj, (uintptr_t) fieldID);
+#endif /* USDT2 */
   oop o = JNIHandles::resolve_non_null(obj);
   klassOop k = o->klass();
   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
@@ -1742,11 +2657,17 @@
     }
   }
 #endif // SERIALGC
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetObjectField__return, ret);
+#else /* USDT2 */
+HOTSPOT_JNI_GETOBJECTFIELD_RETURN(
+                                  ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 
+#ifndef USDT2
 #define DEFINE_GETFIELD(Return,Fieldname,Result) \
 \
   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return);\
@@ -1780,6 +2701,61 @@
 DEFINE_GETFIELD(jfloat,   float,  Float)
 DEFINE_GETFIELD(jdouble,  double, Double)
 
+#else /* USDT2 */
+
+#define DEFINE_GETFIELD(Return,Fieldname,Result \
+  , EntryProbe, ReturnProbe) \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
+  , ReturnProbe); \
+\
+JNI_QUICK_ENTRY(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
+  JNIWrapper("Get" XSTR(Result) "Field"); \
+\
+  EntryProbe; \
+  Return ret = 0;\
+  DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&)ret);\
+\
+  oop o = JNIHandles::resolve_non_null(obj); \
+  klassOop k = o->klass(); \
+  int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
+  /* Keep JVMTI addition small and only check enabled flag here.       */ \
+  /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
+  /* and creates a ResetNoHandleMark.                                   */ \
+  if (JvmtiExport::should_post_field_access()) { \
+    o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
+  } \
+  ret = o->Fieldname##_field(offset); \
+  return ret; \
+JNI_END
+
+DEFINE_GETFIELD(jboolean, bool,   Boolean
+                , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
+DEFINE_GETFIELD(jbyte,    byte,   Byte
+                , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
+DEFINE_GETFIELD(jchar,    char,   Char
+                , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
+DEFINE_GETFIELD(jshort,   short,  Short
+                , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
+DEFINE_GETFIELD(jint,     int,    Int
+                , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
+DEFINE_GETFIELD(jlong,    long,   Long
+                , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_GETFIELD(jfloat,   float,  Float
+                , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_GETFLOATFIELD_RETURN())
+DEFINE_GETFIELD(jdouble,  double, Double
+                , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
+#endif /* USDT2 */
+
 address jni_GetBooleanField_addr() {
   return (address)jni_GetBooleanField;
 }
@@ -1807,7 +2783,12 @@
 
 JNI_QUICK_ENTRY(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
   JNIWrapper("SetObjectField");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, SetObjectField__entry, env, obj, fieldID, value);
+#else /* USDT2 */
+  HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(
+                                   env, obj, (uintptr_t) fieldID, value);
+#endif /* USDT2 */
   oop o = JNIHandles::resolve_non_null(obj);
   klassOop k = o->klass();
   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
@@ -1820,9 +2801,15 @@
     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, 'L', (jvalue *)&field_value);
   }
   o->obj_field_put(offset, JNIHandles::resolve(value));
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, SetObjectField__return);
+#else /* USDT2 */
+  HOTSPOT_JNI_SETOBJECTFIELD_RETURN(
+);
+#endif /* USDT2 */
 JNI_END
 
+#ifndef USDT2
 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType) \
 \
 JNI_QUICK_ENTRY(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
@@ -1857,12 +2844,74 @@
 DEFINE_SETFIELD(jfloat,   float,  Float,   'F', f)
 DEFINE_SETFIELD(jdouble,  double, Double,  'D', d)
 
+#else /* USDT2 */
+
+#define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
+                        , EntryProbe, ReturnProbe) \
+\
+JNI_QUICK_ENTRY(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
+  JNIWrapper("Set" XSTR(Result) "Field"); \
+\
+  EntryProbe; \
+\
+  oop o = JNIHandles::resolve_non_null(obj); \
+  klassOop k = o->klass(); \
+  int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
+  /* Keep JVMTI addition small and only check enabled flag here.       */ \
+  /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
+  /* and creates a ResetNoHandleMark.                                   */ \
+  if (JvmtiExport::should_post_field_modification()) { \
+    jvalue field_value; \
+    field_value.unionType = value; \
+    o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&field_value); \
+  } \
+  o->Fieldname##_field_put(offset, value); \
+  ReturnProbe; \
+JNI_END
+
+DEFINE_SETFIELD(jboolean, bool,   Boolean, 'Z', z
+                , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
+                HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
+DEFINE_SETFIELD(jbyte,    byte,   Byte,    'B', b
+                , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
+                HOTSPOT_JNI_SETBYTEFIELD_RETURN())
+DEFINE_SETFIELD(jchar,    char,   Char,    'C', c
+                , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
+                HOTSPOT_JNI_SETCHARFIELD_RETURN())
+DEFINE_SETFIELD(jshort,   short,  Short,   'S', s
+                , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
+                HOTSPOT_JNI_SETSHORTFIELD_RETURN())
+DEFINE_SETFIELD(jint,     int,    Int,     'I', i
+                , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
+                HOTSPOT_JNI_SETINTFIELD_RETURN())
+DEFINE_SETFIELD(jlong,    long,   Long,    'J', j
+                , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
+                HOTSPOT_JNI_SETLONGFIELD_RETURN())
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_SETFIELD(jfloat,   float,  Float,   'F', f
+                , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_SETFLOATFIELD_RETURN())
+DEFINE_SETFIELD(jdouble,  double, Double,  'D', d
+                , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
+                HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
+#endif /* USDT2 */
+
+#ifndef USDT2
 DT_RETURN_MARK_DECL(ToReflectedField, jobject);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(ToReflectedField, jobject
+                    , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
   JNIWrapper("ToReflectedField");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, ToReflectedField__entry,
                 env, cls, fieldID, isStatic);
+#else /* USDT2 */
+  HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(
+                env, cls, (uintptr_t) fieldID, isStatic);
+#endif /* USDT2 */
   jobject ret = NULL;
   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&)ret);
 
@@ -1892,12 +2941,22 @@
 //
 // Accessing Static Fields
 //
+#ifndef USDT2
 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
+                    , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
           const char *name, const char *sig))
   JNIWrapper("GetStaticFieldID");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, GetStaticFieldID__entry, env, clazz, name, sig);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(
+                                     env, clazz, (char *) name, (char *) sig);
+#endif /* USDT2 */
   jfieldID ret = NULL;
   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&)ret);
 
@@ -1933,7 +2992,12 @@
 
 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
   JNIWrapper("GetStaticObjectField");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, GetStaticObjectField__entry, env, clazz, fieldID);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(
+                                         env, clazz, (uintptr_t) fieldID);
+#endif /* USDT2 */
 #ifndef JNICHECK_KERNEL
   DEBUG_ONLY(klassOop param_k = jniCheck::validate_class(thread, clazz);)
 #endif // JNICHECK_KERNEL
@@ -1945,10 +3009,16 @@
     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id->holder(), fieldID, true);
   }
   jobject ret = JNIHandles::make_local(id->holder()->java_mirror()->obj_field(id->offset()));
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetStaticObjectField__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(
+                                          ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
+#ifndef USDT2
 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result) \
 \
   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return);\
@@ -1979,10 +3049,58 @@
 DEFINE_GETSTATICFIELD(jfloat,   float,  Float)
 DEFINE_GETSTATICFIELD(jdouble,  double, Double)
 
+#else /* USDT2 */
+
+#define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
+                              , EntryProbe, ReturnProbe) \
+\
+  DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
+                          , ReturnProbe);                                          \
+\
+JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
+  JNIWrapper("GetStatic" XSTR(Result) "Field"); \
+  EntryProbe; \
+  Return ret = 0;\
+  DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
+                     (const Return&)ret);\
+  JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
+  assert(id->is_static_field_id(), "invalid static field id"); \
+  /* Keep JVMTI addition small and only check enabled flag here. */ \
+  /* jni_GetField_probe() assumes that is okay to create handles. */ \
+  if (JvmtiExport::should_post_field_access()) { \
+    JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id->holder(), fieldID, true); \
+  } \
+  ret = id->holder()->java_mirror()-> Fieldname##_field (id->offset()); \
+  return ret;\
+JNI_END
+
+DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
+                      , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
+DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
+                      , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
+DEFINE_GETSTATICFIELD(jchar,    char,   Char
+                      , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
+DEFINE_GETSTATICFIELD(jshort,   short,  Short
+                      , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
+DEFINE_GETSTATICFIELD(jint,     int,    Int
+                      , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
+DEFINE_GETSTATICFIELD(jlong,    long,   Long
+                      , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_GETSTATICFIELD(jfloat,   float,  Float
+                      , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
+DEFINE_GETSTATICFIELD(jdouble,  double, Double
+                      , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
+#endif /* USDT2 */
 
 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
   JNIWrapper("SetStaticObjectField");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, SetStaticObjectField__entry, env, clazz, fieldID, value);
+#else /* USDT2 */
+ HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(
+                                        env, clazz, (uintptr_t) fieldID, value);
+#endif /* USDT2 */
   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
   assert(id->is_static_field_id(), "invalid static field id");
   // Keep JVMTI addition small and only check enabled flag here.
@@ -1993,10 +3111,16 @@
     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id->holder(), fieldID, true, 'L', (jvalue *)&field_value);
   }
   id->holder()->java_mirror()->obj_field_put(id->offset(), JNIHandles::resolve(value));
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, SetStaticObjectField__return);
+#else /* USDT2 */
+  HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN(
+                                          );
+#endif /* USDT2 */
 JNI_END
 
 
+#ifndef USDT2
 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType) \
 \
 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
@@ -2028,6 +3152,54 @@
 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   'F', f)
 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  'D', d)
 
+#else /* USDT2 */
+
+#define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
+                              , EntryProbe, ReturnProbe) \
+\
+JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
+  JNIWrapper("SetStatic" XSTR(Result) "Field"); \
+  EntryProbe; \
+\
+  JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
+  assert(id->is_static_field_id(), "invalid static field id"); \
+  /* Keep JVMTI addition small and only check enabled flag here. */ \
+  /* jni_SetField_probe() assumes that is okay to create handles. */ \
+  if (JvmtiExport::should_post_field_modification()) { \
+    jvalue field_value; \
+    field_value.unionType = value; \
+    JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id->holder(), fieldID, true, SigType, (jvalue *)&field_value); \
+  } \
+  id->holder()->java_mirror()-> Fieldname##_field_put (id->offset(), value); \
+  ReturnProbe;\
+JNI_END
+
+DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, 'Z', z
+                      , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
+                      HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
+DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    'B', b
+                      , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
+                      HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
+DEFINE_SETSTATICFIELD(jchar,    char,   Char,    'C', c
+                      , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
+                      HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
+DEFINE_SETSTATICFIELD(jshort,   short,  Short,   'S', s
+                      , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
+                      HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
+DEFINE_SETSTATICFIELD(jint,     int,    Int,     'I', i
+                      , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
+                      HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
+DEFINE_SETSTATICFIELD(jlong,    long,   Long,    'J', j
+                      , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
+                      HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   'F', f
+                      , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
+                      HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
+DEFINE_SETSTATICFIELD(jdouble,  double, Double,  'D', d
+                      , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
+                      HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
+#endif /* USDT2 */
 
 //
 // String Operations
@@ -2035,11 +3207,21 @@
 
 // Unicode Interface
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(NewString, jstring);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(NewString, jstring
+                    , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
   JNIWrapper("NewString");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, NewString__entry, env, unicodeChars, len);
+#else /* USDT2 */
+ HOTSPOT_JNI_NEWSTRING_ENTRY(
+                             env, (uint16_t *) unicodeChars, len);
+#endif /* USDT2 */
   jstring ret = NULL;
   DT_RETURN_MARK(NewString, jstring, (const jstring&)ret);
   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
@@ -2050,9 +3232,19 @@
 
 JNI_QUICK_ENTRY(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
   JNIWrapper("GetStringLength");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetStringLength__entry, env, string);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(
+                                    env, string);
+#endif /* USDT2 */
   jsize ret = java_lang_String::length(JNIHandles::resolve_non_null(string));
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetStringLength__return, ret);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(
+                                    ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
@@ -2060,7 +3252,12 @@
 JNI_QUICK_ENTRY(const jchar*, jni_GetStringChars(
   JNIEnv *env, jstring string, jboolean *isCopy))
   JNIWrapper("GetStringChars");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, GetStringChars__entry, env, string, isCopy);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(
+                                  env, string, (uintptr_t *) isCopy);
+#endif /* USDT2 */
   //%note jni_5
   if (isCopy != NULL) {
     *isCopy = JNI_TRUE;
@@ -2074,31 +3271,56 @@
     memcpy(buf, s_value->char_at_addr(s_offset), sizeof(jchar)*s_len);
   }
   buf[s_len] = 0;
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetStringChars__return, buf);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTRINGCHARS_RETURN(
+                                    buf);
+#endif /* USDT2 */
   return buf;
 JNI_END
 
 
 JNI_QUICK_ENTRY(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
   JNIWrapper("ReleaseStringChars");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, ReleaseStringChars__entry, env, str, chars);
+#else /* USDT2 */
+  HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(
+                                       env, str, (uint16_t *) chars);
+#endif /* USDT2 */
   //%note jni_6
   if (chars != NULL) {
     // Since String objects are supposed to be immutable, don't copy any
     // new data back.  A bad user will have to go after the char array.
     FreeHeap((void*) chars);
   }
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, ReleaseStringChars__return);
+#else /* USDT2 */
+  HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN(
+);
+#endif /* USDT2 */
 JNI_END
 
 
 // UTF Interface
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(NewStringUTF, jstring);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(NewStringUTF, jstring
+                    , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
   JNIWrapper("NewStringUTF");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, NewStringUTF__entry, env, bytes);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(
+                                 env, (char *) bytes);
+#endif /* USDT2 */
   jstring ret;
   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&)ret);
 
@@ -2110,43 +3332,83 @@
 
 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
   JNIWrapper("GetStringUTFLength");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetStringUTFLength__entry, env, string);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(
+                                      env, string);
+#endif /* USDT2 */
   jsize ret = java_lang_String::utf8_length(JNIHandles::resolve_non_null(string));
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetStringUTFLength__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(
+                                        ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 
 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
   JNIWrapper("GetStringUTFChars");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, GetStringUTFChars__entry, env, string, isCopy);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(
+                                     env, string, (uintptr_t *) isCopy);
+#endif /* USDT2 */
   oop java_string = JNIHandles::resolve_non_null(string);
   size_t length = java_lang_String::utf8_length(java_string);
   char* result = AllocateHeap(length + 1, "GetStringUTFChars");
   java_lang_String::as_utf8_string(java_string, result, (int) length + 1);
   if (isCopy != NULL) *isCopy = JNI_TRUE;
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetStringUTFChars__return, result);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(
+                                      result);
+#endif /* USDT2 */
   return result;
 JNI_END
 
 
 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
   JNIWrapper("ReleaseStringUTFChars");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, ReleaseStringUTFChars__entry, env, str, chars);
+#else /* USDT2 */
+ HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(
+                                         env, str, (char *) chars);
+#endif /* USDT2 */
   if (chars != NULL) {
     FreeHeap((char*) chars);
   }
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, ReleaseStringUTFChars__return);
+#else /* USDT2 */
+HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN(
+);
+#endif /* USDT2 */
 JNI_END
 
 
 JNI_QUICK_ENTRY(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
   JNIWrapper("GetArrayLength");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetArrayLength__entry, env, array);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(
+                                  env, array);
+#endif /* USDT2 */
   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
   assert(a->is_array(), "must be array");
   jsize ret = a->length();
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetArrayLength__return, ret);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETARRAYLENGTH_RETURN(
+                                   ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
@@ -2155,11 +3417,21 @@
 // Object Array Operations
 //
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
+                    , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
   JNIWrapper("NewObjectArray");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, NewObjectArray__entry, env, length, elementClass, initialElement);
+#else /* USDT2 */
+ HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(
+                                  env, length, elementClass, initialElement);
+#endif /* USDT2 */
   jobjectArray ret = NULL;
   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&)ret);
   KlassHandle ek(THREAD, java_lang_Class::as_klassOop(JNIHandles::resolve_non_null(elementClass)));
@@ -2177,11 +3449,21 @@
   return ret;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
+                    , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
   JNIWrapper("GetObjectArrayElement");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, GetObjectArrayElement__entry, env, array, index);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(
+                                         env, array, index);
+#endif /* USDT2 */
   jobject ret = NULL;
   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&)ret);
   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
@@ -2195,11 +3477,21 @@
   }
 JNI_END
 
+#ifndef USDT2
 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement);
+#else /* USDT2 */
+DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
+                         , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
+#endif /* USDT2 */
 
 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
   JNIWrapper("SetObjectArrayElement");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, SetObjectArrayElement__entry, env, array, index, value);
+#else /* USDT2 */
+ HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(
+                                         env, array, index, value);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(SetObjectArrayElement);
 
   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
@@ -2218,9 +3510,10 @@
 JNI_END
 
 
+#ifndef USDT2
 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result) \
 \
-  DT_RETURN_MARK_DECL(New##Result##Array, Return);\
+  DT_RETURN_MARK_DECL(New##Result##Array, Return); \
 \
 JNI_ENTRY(Return, \
           jni_New##Result##Array(JNIEnv *env, jsize len)) \
@@ -2243,6 +3536,51 @@
 DEFINE_NEWSCALARARRAY(jfloatArray,   new_singleArray, Float)
 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double)
 
+#else /* USDT2 */
+
+#define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
+                              ,EntryProbe,ReturnProbe)  \
+\
+  DT_RETURN_MARK_DECL(New##Result##Array, Return \
+                      , ReturnProbe); \
+\
+JNI_ENTRY(Return, \
+          jni_New##Result##Array(JNIEnv *env, jsize len)) \
+  JNIWrapper("New" XSTR(Result) "Array"); \
+  EntryProbe; \
+  Return ret = NULL;\
+  DT_RETURN_MARK(New##Result##Array, Return, (const Return&)ret);\
+\
+  oop obj= oopFactory::Allocator(len, CHECK_0); \
+  ret = (Return) JNIHandles::make_local(env, obj); \
+  return ret;\
+JNI_END
+
+DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
+                      HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
+                      HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
+DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
+                      HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
+                      HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
+DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
+                      HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
+                      HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
+DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
+                      HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
+                      HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
+DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
+                      HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
+                      HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
+DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
+                      HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
+                      HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
+DEFINE_NEWSCALARARRAY(jfloatArray,   new_singleArray, Float,
+                      HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
+                      HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
+DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
+                      HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
+                      HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
+#endif /* USDT2 */
 
 // Return an address which will fault if the caller writes to it.
 
@@ -2260,6 +3598,7 @@
 }
 
 
+#ifndef USDT2
 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag) \
 \
 JNI_QUICK_ENTRY(ElementType*, \
@@ -2294,7 +3633,62 @@
 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float)
 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double)
 
+#else /* USDT2 */
+
+#define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
+                                      , EntryProbe, ReturnProbe) \
+\
+JNI_QUICK_ENTRY(ElementType*, \
+          jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
+  JNIWrapper("Get" XSTR(Result) "ArrayElements"); \
+  EntryProbe; \
+  /* allocate an chunk of memory in c land */ \
+  typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
+  ElementType* result; \
+  int len = a->length(); \
+  if (len == 0) { \
+    /* Empty array: legal but useless, can't return NULL. \
+     * Return a pointer to something useless. \
+     * Avoid asserts in typeArrayOop. */ \
+    result = (ElementType*)get_bad_address(); \
+  } else { \
+    result = NEW_C_HEAP_ARRAY(ElementType, len); \
+    /* copy the array to the c chunk */ \
+    memcpy(result, a->Tag##_at_addr(0), sizeof(ElementType)*len); \
+  } \
+  if (isCopy) *isCopy = JNI_TRUE; \
+  ReturnProbe; \
+  return result; \
+JNI_END
+
+DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
+                              , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
+                              HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
+DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
+                              , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
+                              HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
+DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
+                              , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
+                              HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
+DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
+                              , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
+                              HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
+DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
+                              , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
+                              HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
+DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
+                              , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
+                              HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
+// Float and double probes don't return value because dtrace doesn't currently support it
+DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
+                              , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
+                              HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
+DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
+                              , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
+                              HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
+#endif /* USDT2 */
 
+#ifndef USDT2
 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag) \
 \
 JNI_QUICK_ENTRY(void, \
@@ -2324,6 +3718,56 @@
 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float)
 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double)
 
+#else /* USDT2 */
+
+#define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
+                                          , EntryProbe, ReturnProbe);\
+\
+JNI_QUICK_ENTRY(void, \
+          jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
+                                             ElementType *buf, jint mode)) \
+  JNIWrapper("Release" XSTR(Result) "ArrayElements"); \
+  EntryProbe; \
+  typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
+  int len = a->length(); \
+  if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
+    if ((mode == 0) || (mode == JNI_COMMIT)) { \
+      memcpy(a->Tag##_at_addr(0), buf, sizeof(ElementType)*len); \
+    } \
+    if ((mode == 0) || (mode == JNI_ABORT)) { \
+      FreeHeap(buf); \
+    } \
+  } \
+  ReturnProbe; \
+JNI_END
+
+DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
+                                  , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
+                                  HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
+DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
+                                  , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
+                                  HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
+DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
+                                  ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
+                                  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
+DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
+                                  ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
+                                  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
+DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
+                                  , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
+                                  HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
+DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
+                                  , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
+                                  HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
+DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
+                                  , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
+                                  HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
+DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
+                                  , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
+                                  HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
+#endif /* USDT2 */
+
+#ifndef USDT2
 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag) \
   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion);\
 \
@@ -2355,6 +3799,59 @@
 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float)
 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double)
 
+#else /* USDT2 */
+
+#define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
+                                    , EntryProbe, ReturnProbe); \
+  DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
+                           , ReturnProbe); \
+\
+JNI_ENTRY(void, \
+jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
+             jsize len, ElementType *buf)) \
+  JNIWrapper("Get" XSTR(Result) "ArrayRegion"); \
+  EntryProbe; \
+  DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
+  typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
+  if (start < 0 || len < 0 || ((unsigned int)start + (unsigned int)len > (unsigned int)src->length())) { \
+    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException()); \
+  } else { \
+    if (len > 0) { \
+      int sc = typeArrayKlass::cast(src->klass())->log2_element_size(); \
+      memcpy((u_char*) buf, \
+             (u_char*) src->Tag##_at_addr(start), \
+             len << sc);                          \
+    } \
+  } \
+JNI_END
+
+DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
+                            , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
+                            HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
+DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
+                            ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
+                            HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
+DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
+                            , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
+                            HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
+DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
+                            ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
+                            HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
+DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
+                            , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
+                            HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
+DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
+                            ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
+                            HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
+DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
+                            , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
+                            HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
+DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
+                            , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
+                            HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
+#endif /* USDT2 */
+
+#ifndef USDT2
 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag) \
   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion);\
 \
@@ -2386,6 +3883,58 @@
 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float)
 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double)
 
+#else /* USDT2 */
+
+#define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
+                                    , EntryProbe, ReturnProbe); \
+  DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
+                           ,ReturnProbe);           \
+\
+JNI_ENTRY(void, \
+jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
+             jsize len, const ElementType *buf)) \
+  JNIWrapper("Set" XSTR(Result) "ArrayRegion"); \
+  EntryProbe; \
+  DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
+  typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
+  if (start < 0 || len < 0 || ((unsigned int)start + (unsigned int)len > (unsigned int)dst->length())) { \
+    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException()); \
+  } else { \
+    if (len > 0) { \
+      int sc = typeArrayKlass::cast(dst->klass())->log2_element_size(); \
+      memcpy((u_char*) dst->Tag##_at_addr(start), \
+             (u_char*) buf, \
+             len << sc);    \
+    } \
+  } \
+JNI_END
+
+DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
+                            , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
+                            HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
+DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
+                            , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
+                            HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
+DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
+                            , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
+                            HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
+DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
+                            , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
+                            HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
+DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
+                            , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
+                            HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
+DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
+                            , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
+                            HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
+DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
+                            , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
+                            HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
+DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
+                            , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
+                            HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
+#endif /* USDT2 */
+
 
 //
 // Interception of natives
@@ -2467,13 +4016,23 @@
   return true;
 }
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(RegisterNatives, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(RegisterNatives, jint
+                    , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
                                     const JNINativeMethod *methods,
                                     jint nMethods))
   JNIWrapper("RegisterNatives");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, RegisterNatives__entry, env, clazz, methods, nMethods);
+#else /* USDT2 */
+  HOTSPOT_JNI_REGISTERNATIVES_ENTRY(
+                                    env, clazz, (void *) methods, nMethods);
+#endif /* USDT2 */
   jint ret = 0;
   DT_RETURN_MARK(RegisterNatives, jint, (const jint&)ret);
 
@@ -2511,7 +4070,12 @@
 
 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
   JNIWrapper("UnregisterNatives");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, UnregisterNatives__entry, env, clazz);
+#else /* USDT2 */
+ HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(
+                                     env, clazz);
+#endif /* USDT2 */
   klassOop k   = java_lang_Class::as_klassOop(JNIHandles::resolve_non_null(clazz));
   //%note jni_2
   if (Klass::cast(k)->oop_is_instance()) {
@@ -2523,7 +4087,12 @@
       }
     }
   }
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, UnregisterNatives__return, 0);
+#else /* USDT2 */
+ HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(
+                                      0);
+#endif /* USDT2 */
   return 0;
 JNI_END
 
@@ -2531,10 +4100,20 @@
 // Monitor functions
 //
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(MonitorEnter, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(MonitorEnter, jint
+                    , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, MonitorEnter__entry, env, jobj);
+#else /* USDT2 */
+ HOTSPOT_JNI_MONITORENTER_ENTRY(
+                                env, jobj);
+#endif /* USDT2 */
   jint ret = JNI_ERR;
   DT_RETURN_MARK(MonitorEnter, jint, (const jint&)ret);
 
@@ -2549,10 +4128,20 @@
   return ret;
 JNI_END
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(MonitorExit, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(MonitorExit, jint
+                    , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, MonitorExit__entry, env, jobj);
+#else /* USDT2 */
+ HOTSPOT_JNI_MONITOREXIT_ENTRY(
+                               env, jobj);
+#endif /* USDT2 */
   jint ret = JNI_ERR;
   DT_RETURN_MARK(MonitorExit, jint, (const jint&)ret);
 
@@ -2572,11 +4161,21 @@
 // Extensions
 //
 
+#ifndef USDT2
 DT_VOID_RETURN_MARK_DECL(GetStringRegion);
+#else /* USDT2 */
+DT_VOID_RETURN_MARK_DECL(GetStringRegion
+                         , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
+#endif /* USDT2 */
 
 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
   JNIWrapper("GetStringRegion");
+#ifndef USDT2
   DTRACE_PROBE5(hotspot_jni, GetStringRegion__entry, env, string, start, len, buf);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETSTRINGREGION_ENTRY(
+                                   env, string, start, len, buf);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(GetStringRegion);
   oop s = JNIHandles::resolve_non_null(string);
   int s_len = java_lang_String::length(s);
@@ -2591,11 +4190,21 @@
   }
 JNI_END
 
+#ifndef USDT2
 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion);
+#else /* USDT2 */
+DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
+                         , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
+#endif /* USDT2 */
 
 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
   JNIWrapper("GetStringUTFRegion");
+#ifndef USDT2
   DTRACE_PROBE5(hotspot_jni, GetStringUTFRegion__entry, env, string, start, len, buf);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(
+                                      env, string, start, len, buf);
+#endif /* USDT2 */
   DT_VOID_RETURN_MARK(GetStringUTFRegion);
   oop s = JNIHandles::resolve_non_null(string);
   int s_len = java_lang_String::length(s);
@@ -2621,7 +4230,12 @@
 
 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
   JNIWrapper("GetPrimitiveArrayCritical");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, GetPrimitiveArrayCritical__entry, env, array, isCopy);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(
+                                             env, array, (uintptr_t *) isCopy);
+#endif /* USDT2 */
   GC_locker::lock_critical(thread);
   if (isCopy != NULL) {
     *isCopy = JNI_FALSE;
@@ -2635,23 +4249,43 @@
     type = typeArrayKlass::cast(a->klass())->element_type();
   }
   void* ret = arrayOop(a)->base(type);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetPrimitiveArrayCritical__return, ret);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(
+                                              ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 
 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
   JNIWrapper("ReleasePrimitiveArrayCritical");
+#ifndef USDT2
   DTRACE_PROBE4(hotspot_jni, ReleasePrimitiveArrayCritical__entry, env, array, carray, mode);
+#else /* USDT2 */
+  HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(
+                                                  env, array, carray, mode);
+#endif /* USDT2 */
   // The array, carray and mode arguments are ignored
   GC_locker::unlock_critical(thread);
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, ReleasePrimitiveArrayCritical__return);
+#else /* USDT2 */
+HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN(
+);
+#endif /* USDT2 */
 JNI_END
 
 
 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
   JNIWrapper("GetStringCritical");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, GetStringCritical__entry, env, string, isCopy);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(
+                                      env, string, (uintptr_t *) isCopy);
+#endif /* USDT2 */
   GC_locker::lock_critical(thread);
   if (isCopy != NULL) {
     *isCopy = JNI_FALSE;
@@ -2666,44 +4300,89 @@
   } else {
     ret = (jchar*) s_value->base(T_CHAR);
   }
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetStringCritical__return, ret);
+#else /* USDT2 */
+ HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN(
+                                      (uint16_t *) ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 
 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
   JNIWrapper("ReleaseStringCritical");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, ReleaseStringCritical__entry, env, str, chars);
+#else /* USDT2 */
+  HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(
+                                          env, str, (uint16_t *) chars);
+#endif /* USDT2 */
   // The str and chars arguments are ignored
   GC_locker::unlock_critical(thread);
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, ReleaseStringCritical__return);
+#else /* USDT2 */
+HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN(
+);
+#endif /* USDT2 */
 JNI_END
 
 
 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
   JNIWrapper("jni_NewWeakGlobalRef");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, NewWeakGlobalRef__entry, env, ref);
+#else /* USDT2 */
+ HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(
+                                    env, ref);
+#endif /* USDT2 */
   Handle ref_handle(thread, JNIHandles::resolve(ref));
   jweak ret = JNIHandles::make_weak_global(ref_handle);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, NewWeakGlobalRef__return, ret);
+#else /* USDT2 */
+ HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(
+                                     ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
 // Must be JNI_ENTRY (with HandleMark)
 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
   JNIWrapper("jni_DeleteWeakGlobalRef");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, DeleteWeakGlobalRef__entry, env, ref);
+#else /* USDT2 */
+  HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(
+                                        env, ref);
+#endif /* USDT2 */
   JNIHandles::destroy_weak_global(ref);
+#ifndef USDT2
   DTRACE_PROBE(hotspot_jni, DeleteWeakGlobalRef__return);
+#else /* USDT2 */
+  HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN(
+                                         );
+#endif /* USDT2 */
 JNI_END
 
 
 JNI_QUICK_ENTRY(jboolean, jni_ExceptionCheck(JNIEnv *env))
   JNIWrapper("jni_ExceptionCheck");
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, ExceptionCheck__entry, env);
+#else /* USDT2 */
+ HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(
+                                  env);
+#endif /* USDT2 */
   jni_check_async_exceptions(thread);
   jboolean ret = (thread->has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, ExceptionCheck__return, ret);
+#else /* USDT2 */
+ HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(
+                                   ret);
+#endif /* USDT2 */
   return ret;
 JNI_END
 
@@ -2795,11 +4474,21 @@
   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
 
   JNIWrapper("jni_NewDirectByteBuffer");
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, NewDirectByteBuffer__entry, env, address, capacity);
+#else /* USDT2 */
+ HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(
+                                       env, address, capacity);
+#endif /* USDT2 */
 
   if (!directBufferSupportInitializeEnded) {
     if (!initializeDirectBufferSupport(env, thread)) {
+#ifndef USDT2
       DTRACE_PROBE1(hotspot_jni, NewDirectByteBuffer__return, (uintptr_t) NULL);
+#else /* USDT2 */
+      HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(
+                                             NULL);
+#endif /* USDT2 */
       return NULL;
     }
   }
@@ -2810,11 +4499,21 @@
   // takes int capacity
   jint  cap  = (jint)  capacity;
   jobject ret = env->NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, NewDirectByteBuffer__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(
+                                         ret);
+#endif /* USDT2 */
   return ret;
 }
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
+                    , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
+#endif /* USDT2 */
 
 extern "C" void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
 {
@@ -2822,7 +4521,12 @@
   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
 
   JNIWrapper("jni_GetDirectBufferAddress");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetDirectBufferAddress__entry, env, buf);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(
+                                           env, buf);
+#endif /* USDT2 */
   void* ret = NULL;
   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&)ret);
 
@@ -2840,7 +4544,12 @@
   return ret;
 }
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
+                    , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 extern "C" jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
 {
@@ -2848,7 +4557,12 @@
   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
 
   JNIWrapper("jni_GetDirectBufferCapacity");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetDirectBufferCapacity__entry, env, buf);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(
+                                            env, buf);
+#endif /* USDT2 */
   jlong ret = -1;
   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&)ret);
 
@@ -2875,8 +4589,18 @@
 
 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
   JNIWrapper("GetVersion");
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetVersion__entry, env);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETVERSION_ENTRY(
+                               env);
+#endif /* USDT2 */
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetVersion__return, CurrentVersion);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETVERSION_RETURN(
+                                CurrentVersion);
+#endif /* USDT2 */
   return CurrentVersion;
 JNI_END
 
@@ -2884,9 +4608,19 @@
 
 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
   JNIWrapper("jni_GetJavaVM");
+#ifndef USDT2
   DTRACE_PROBE2(hotspot_jni, GetJavaVM__entry, env, vm);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETJAVAVM_ENTRY(
+                              env, (void **) vm);
+#endif /* USDT2 */
   *vm  = (JavaVM *)(&main_vm);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, GetJavaVM__return, JNI_OK);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETJAVAVM_RETURN(
+                               JNI_OK);
+#endif /* USDT2 */
   return JNI_OK;
 JNI_END
 
@@ -3266,11 +5000,21 @@
 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL1(hotspot_jni, GetDefaultJavaVMInitArgs__entry, void*);
 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
+                    , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
+#ifndef USDT2
   HS_DTRACE_PROBE1(hotspot_jni, GetDefaultJavaVMInitArgs__entry, args_);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(
+                                             args_);
+#endif /* USDT2 */
   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
   jint ret = JNI_ERR;
   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&)ret);
@@ -3304,11 +5048,21 @@
 
 #endif
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL3(hotspot_jni, CreateJavaVM__entry, vm, penv, args);
 DT_RETURN_MARK_DECL(CreateJavaVM, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(CreateJavaVM, jint
+                    , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
+#ifndef USDT2
   HS_DTRACE_PROBE3(hotspot_jni, CreateJavaVM__entry, vm, penv, args);
+#else /* USDT2 */
+  HOTSPOT_JNI_CREATEJAVAVM_ENTRY(
+                                 (void **) vm, penv, args);
+#endif /* USDT2 */
 
   jint result = JNI_ERR;
   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&)result);
@@ -3398,31 +5152,53 @@
   return result;
 }
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL3(hotspot_jni, GetCreatedJavaVMs__entry, \
   JavaVM**, jsize, jsize*);
 HS_DTRACE_PROBE_DECL1(hotspot_jni, GetCreatedJavaVMs__return, jint);
+#endif /* !USDT2 */
 
 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
   // See bug 4367188, the wrapper can sometimes cause VM crashes
   // JNIWrapper("GetCreatedJavaVMs");
+#ifndef USDT2
   HS_DTRACE_PROBE3(hotspot_jni, GetCreatedJavaVMs__entry, \
     vm_buf, bufLen, numVMs);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY(
+                                      (void **) vm_buf, bufLen, (uintptr_t *) numVMs);
+#endif /* USDT2 */
   if (vm_created) {
     if (numVMs != NULL) *numVMs = 1;
     if (bufLen > 0)     *vm_buf = (JavaVM *)(&main_vm);
   } else {
     if (numVMs != NULL) *numVMs = 0;
   }
+#ifndef USDT2
   HS_DTRACE_PROBE1(hotspot_jni, GetCreatedJavaVMs__return, JNI_OK);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(
+                                    JNI_OK);
+#endif /* USDT2 */
   return JNI_OK;
 }
 
 extern "C" {
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(DestroyJavaVM, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(DestroyJavaVM, jint
+                    , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, DestroyJavaVM__entry, vm);
+#else /* USDT2 */
+  HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(
+                                  vm);
+#endif /* USDT2 */
   jint res = JNI_ERR;
   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&)res);
 
@@ -3540,7 +5316,7 @@
   // mark the thread as no longer attaching
   // this uses a fence to push the change through so we don't have
   // to regrab the threads_lock
-  thread->set_attached();
+  thread->set_done_attaching_via_jni();
 
   // Set java thread status.
   java_lang_Thread::set_thread_status(thread->threadObj(),
@@ -3568,34 +5344,64 @@
 
 
 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, AttachCurrentThread__entry, vm, penv, _args);
+#else /* USDT2 */
+  HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(
+                                        vm, penv, _args);
+#endif /* USDT2 */
   if (!vm_created) {
+#ifndef USDT2
     DTRACE_PROBE1(hotspot_jni, AttachCurrentThread__return, JNI_ERR);
+#else /* USDT2 */
+  HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(
+                                         (uint32_t) JNI_ERR);
+#endif /* USDT2 */
     return JNI_ERR;
   }
 
   JNIWrapper("AttachCurrentThread");
   jint ret = attach_current_thread(vm, penv, _args, false);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, AttachCurrentThread__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(
+                                         ret);
+#endif /* USDT2 */
   return ret;
 }
 
 
 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, DetachCurrentThread__entry, vm);
+#else /* USDT2 */
+  HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(
+                                        vm);
+#endif /* USDT2 */
   VM_Exit::block_if_vm_exited();
 
   JNIWrapper("DetachCurrentThread");
 
   // If the thread has been deattacted the operations is a no-op
   if (ThreadLocalStorage::thread() == NULL) {
+#ifndef USDT2
     DTRACE_PROBE1(hotspot_jni, DetachCurrentThread__return, JNI_OK);
+#else /* USDT2 */
+  HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(
+                                         JNI_OK);
+#endif /* USDT2 */
     return JNI_OK;
   }
 
   JavaThread* thread = JavaThread::current();
   if (thread->has_last_Java_frame()) {
+#ifndef USDT2
     DTRACE_PROBE1(hotspot_jni, DetachCurrentThread__return, JNI_ERR);
+#else /* USDT2 */
+  HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(
+                                         (uint32_t) JNI_ERR);
+#endif /* USDT2 */
     // Can't detach a thread that's running java, that can't work.
     return JNI_ERR;
   }
@@ -3616,14 +5422,29 @@
   thread->exit(false, JavaThread::jni_detach);
   delete thread;
 
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, DetachCurrentThread__return, JNI_OK);
+#else /* USDT2 */
+  HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(
+                                         JNI_OK);
+#endif /* USDT2 */
   return JNI_OK;
 }
 
+#ifndef USDT2
 DT_RETURN_MARK_DECL(GetEnv, jint);
+#else /* USDT2 */
+DT_RETURN_MARK_DECL(GetEnv, jint
+                    , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
+#endif /* USDT2 */
 
 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, GetEnv__entry, vm, penv, version);
+#else /* USDT2 */
+  HOTSPOT_JNI_GETENV_ENTRY(
+                           vm, penv, version);
+#endif /* USDT2 */
   jint ret = JNI_ERR;
   DT_RETURN_MARK(GetEnv, jint, (const jint&)ret);
 
@@ -3678,15 +5499,30 @@
 
 
 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
+#ifndef USDT2
   DTRACE_PROBE3(hotspot_jni, AttachCurrentThreadAsDaemon__entry, vm, penv, _args);
+#else /* USDT2 */
+  HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(
+                                                vm, penv, _args);
+#endif /* USDT2 */
   if (!vm_created) {
+#ifndef USDT2
     DTRACE_PROBE1(hotspot_jni, AttachCurrentThreadAsDaemon__return, JNI_ERR);
+#else /* USDT2 */
+  HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(
+                                                 (uint32_t) JNI_ERR);
+#endif /* USDT2 */
     return JNI_ERR;
   }
 
   JNIWrapper("AttachCurrentThreadAsDaemon");
   jint ret = attach_current_thread(vm, penv, _args, true);
+#ifndef USDT2
   DTRACE_PROBE1(hotspot_jni, AttachCurrentThreadAsDaemon__return, ret);
+#else /* USDT2 */
+  HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(
+                                                 ret);
+#endif /* USDT2 */
   return ret;
 }
 
diff -Nru openjdk.orig/hotspot/src/share/vm/prims/jvm.cpp openjdk/hotspot/src/share/vm/prims/jvm.cpp
--- openjdk.orig/hotspot/src/share/vm/prims/jvm.cpp	2012-07-25 15:14:34.562187710 +0100
+++ openjdk/hotspot/src/share/vm/prims/jvm.cpp	2012-07-25 15:27:37.291649179 +0100
@@ -79,9 +79,11 @@
 
 #include <errno.h>
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL1(hotspot, thread__sleep__begin, long long);
 HS_DTRACE_PROBE_DECL1(hotspot, thread__sleep__end, int);
 HS_DTRACE_PROBE_DECL0(hotspot, thread__yield);
+#endif /* !USDT2 */
 
 /*
   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
@@ -2816,7 +2818,11 @@
 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
   JVMWrapper("JVM_Yield");
   if (os::dont_yield()) return;
+#ifndef USDT2
   HS_DTRACE_PROBE0(hotspot, thread__yield);
+#else /* USDT2 */
+  HOTSPOT_THREAD_YIELD();
+#endif /* USDT2 */
   // When ConvertYieldToSleep is off (default), this matches the classic VM use of yield.
   // Critical for similar threading behaviour
   if (ConvertYieldToSleep) {
@@ -2842,7 +2848,12 @@
   // And set new thread state to SLEEPING.
   JavaThreadSleepState jtss(thread);
 
+#ifndef USDT2
   HS_DTRACE_PROBE1(hotspot, thread__sleep__begin, millis);
+#else /* USDT2 */
+  HOTSPOT_THREAD_SLEEP_BEGIN(
+                             millis);
+#endif /* USDT2 */
 
   if (millis == 0) {
     // When ConvertSleepToYield is on, this matches the classic VM implementation of
@@ -2864,7 +2875,12 @@
       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
       // us while we were sleeping. We do not overwrite those.
       if (!HAS_PENDING_EXCEPTION) {
+#ifndef USDT2
         HS_DTRACE_PROBE1(hotspot, thread__sleep__end,1);
+#else /* USDT2 */
+        HOTSPOT_THREAD_SLEEP_END(
+                                 1);
+#endif /* USDT2 */
         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
         // to properly restore the thread state.  That's likely wrong.
         THROW_MSG(vmSymbols::java_lang_InterruptedException(), "sleep interrupted");
@@ -2872,7 +2888,12 @@
     }
     thread->osthread()->set_state(old_state);
   }
+#ifndef USDT2
   HS_DTRACE_PROBE1(hotspot, thread__sleep__end,0);
+#else /* USDT2 */
+  HOTSPOT_THREAD_SLEEP_END(
+                           0);
+#endif /* USDT2 */
 JVM_END
 
 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
@@ -2990,6 +3011,20 @@
   }
 JVM_END
 
+JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
+  JVMWrapper("JVM_SetNativeThreadName");
+  ResourceMark rm(THREAD);
+  oop java_thread = JNIHandles::resolve_non_null(jthread);
+  JavaThread* thr = java_lang_Thread::thread(java_thread);
+  // Thread naming only supported for the current thread, doesn't work for
+  // target threads.
+  if (Thread::current() == thr && !thr->has_attached_via_jni()) {
+    // we don't set the name of an attached thread to avoid stepping
+    // on other programs
+    const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
+    os::set_native_thread_name(thread_name);
+  }
+JVM_END
 
 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
 
diff -Nru openjdk.orig/hotspot/src/share/vm/prims/jvm.h openjdk/hotspot/src/share/vm/prims/jvm.h
--- openjdk.orig/hotspot/src/share/vm/prims/jvm.h	2012-07-25 15:14:34.562187710 +0100
+++ openjdk/hotspot/src/share/vm/prims/jvm.h	2012-07-25 15:27:37.291649179 +0100
@@ -291,6 +291,9 @@
 JNIEXPORT jobjectArray JNICALL
 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 
+JNIEXPORT void JNICALL
+JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
+
 /* getStackTrace() and getAllStackTraces() method */
 JNIEXPORT jobjectArray JNICALL
 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
diff -Nru openjdk.orig/hotspot/src/share/vm/prims/unsafe.cpp openjdk/hotspot/src/share/vm/prims/unsafe.cpp
--- openjdk.orig/hotspot/src/share/vm/prims/unsafe.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/prims/unsafe.cpp	2012-07-25 15:27:37.291649179 +0100
@@ -42,9 +42,11 @@
  *      Implementation of class sun.misc.Unsafe
  */
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL3(hotspot, thread__park__begin, uintptr_t, int, long long);
 HS_DTRACE_PROBE_DECL1(hotspot, thread__park__end, uintptr_t);
 HS_DTRACE_PROBE_DECL1(hotspot, thread__unpark, uintptr_t);
+#endif /* !USDT2 */
 
 #define MAX_OBJECT_SIZE \
   ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \
@@ -1187,10 +1189,20 @@
 
 UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))
   UnsafeWrapper("Unsafe_Park");
+#ifndef USDT2
   HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread->parker(), (int) isAbsolute, time);
+#else /* USDT2 */
+   HOTSPOT_THREAD_PARK_BEGIN(
+                             (uintptr_t) thread->parker(), (int) isAbsolute, time);
+#endif /* USDT2 */
   JavaThreadParkedState jtps(thread, time != 0);
   thread->parker()->park(isAbsolute != 0, time);
+#ifndef USDT2
   HS_DTRACE_PROBE1(hotspot, thread__park__end, thread->parker());
+#else /* USDT2 */
+  HOTSPOT_THREAD_PARK_END(
+                          (uintptr_t) thread->parker());
+#endif /* USDT2 */
 UNSAFE_END
 
 UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread))
@@ -1222,7 +1234,12 @@
     }
   }
   if (p != NULL) {
+#ifndef USDT2
     HS_DTRACE_PROBE1(hotspot, thread__unpark, p);
+#else /* USDT2 */
+    HOTSPOT_THREAD_UNPARK(
+                          (uintptr_t) p);
+#endif /* USDT2 */
     p->unpark();
   }
 UNSAFE_END
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/arguments.cpp openjdk/hotspot/src/share/vm/runtime/arguments.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/arguments.cpp	2012-07-25 15:14:34.566187778 +0100
+++ openjdk/hotspot/src/share/vm/runtime/arguments.cpp	2012-07-25 15:27:37.291649179 +0100
@@ -2601,16 +2601,16 @@
       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, false);
       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, true);
     } else if (match_option(option, "-XX:+ExtendedDTraceProbes", &tail)) {
-#ifdef SOLARIS
+#if defined(DTRACE_ENABLED)
       FLAG_SET_CMDLINE(bool, ExtendedDTraceProbes, true);
       FLAG_SET_CMDLINE(bool, DTraceMethodProbes, true);
       FLAG_SET_CMDLINE(bool, DTraceAllocProbes, true);
       FLAG_SET_CMDLINE(bool, DTraceMonitorProbes, true);
-#else // ndef SOLARIS
+#else // defined(DTRACE_ENABLED)
       jio_fprintf(defaultStream::error_stream(),
-                  "ExtendedDTraceProbes flag is only applicable on Solaris\n");
+                  "ExtendedDTraceProbes flag is not applicable for this configuration\n");
       return JNI_EINVAL;
-#endif // ndef SOLARIS
+#endif // defined(DTRACE_ENABLED)
 #ifdef ASSERT
     } else if (match_option(option, "-XX:+FullGCALot", &tail)) {
       FLAG_SET_CMDLINE(bool, FullGCALot, true);
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/globals.hpp openjdk/hotspot/src/share/vm/runtime/globals.hpp
--- openjdk.orig/hotspot/src/share/vm/runtime/globals.hpp	2012-07-25 15:14:34.570187848 +0100
+++ openjdk/hotspot/src/share/vm/runtime/globals.hpp	2012-07-25 15:27:37.291649179 +0100
@@ -677,7 +677,7 @@
   notproduct(bool, WalkStackALot, false,                                    \
           "trace stack (no print) at every exit from the runtime system")   \
                                                                             \
-  develop(bool, Debugging, false,                                           \
+  product(bool, Debugging, false,                                           \
           "set when executing debug methods in debug.ccp "                  \
           "(to prevent triggering assertions)")                             \
                                                                             \
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/java.cpp openjdk/hotspot/src/share/vm/runtime/java.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/java.cpp	2012-07-25 15:14:34.578187987 +0100
+++ openjdk/hotspot/src/share/vm/runtime/java.cpp	2012-07-25 15:27:37.291649179 +0100
@@ -105,7 +105,9 @@
 #include "opto/runtime.hpp"
 #endif
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL(hotspot, vm__shutdown);
+#endif /* !USDT2 */
 
 #ifndef PRODUCT
 
@@ -547,8 +549,12 @@
 
 void notify_vm_shutdown() {
   // For now, just a dtrace probe.
+#ifndef USDT2
   HS_DTRACE_PROBE(hotspot, vm__shutdown);
   HS_DTRACE_WORKAROUND_TAIL_CALL_BUG();
+#else /* USDT2 */
+  HOTSPOT_VM_SHUTDOWN();
+#endif /* USDT2 */
 }
 
 void vm_direct_exit(int code) {
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/objectMonitor.cpp openjdk/hotspot/src/share/vm/runtime/objectMonitor.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/objectMonitor.cpp	2012-07-25 15:14:34.582188056 +0100
+++ openjdk/hotspot/src/share/vm/runtime/objectMonitor.cpp	2012-07-25 15:27:37.295649247 +0100
@@ -68,16 +68,6 @@
 // Only bother with this argument setup if dtrace is available
 // TODO-FIXME: probes should not fire when caller is _blocked.  assert() accordingly.
 
-HS_DTRACE_PROBE_DECL4(hotspot, monitor__notify,
-  jlong, uintptr_t, char*, int);
-HS_DTRACE_PROBE_DECL4(hotspot, monitor__notifyAll,
-  jlong, uintptr_t, char*, int);
-HS_DTRACE_PROBE_DECL4(hotspot, monitor__contended__enter,
-  jlong, uintptr_t, char*, int);
-HS_DTRACE_PROBE_DECL4(hotspot, monitor__contended__entered,
-  jlong, uintptr_t, char*, int);
-HS_DTRACE_PROBE_DECL4(hotspot, monitor__contended__exit,
-  jlong, uintptr_t, char*, int);
 
 #define DTRACE_MONITOR_PROBE_COMMON(klassOop, thread)                      \
   char* bytes = NULL;                                                      \
@@ -89,6 +79,19 @@
     len = klassname->utf8_length();                                        \
   }
 
+#ifndef USDT2
+
+HS_DTRACE_PROBE_DECL4(hotspot, monitor__notify,
+  jlong, uintptr_t, char*, int);
+HS_DTRACE_PROBE_DECL4(hotspot, monitor__notifyAll,
+  jlong, uintptr_t, char*, int);
+HS_DTRACE_PROBE_DECL4(hotspot, monitor__contended__enter,
+  jlong, uintptr_t, char*, int);
+HS_DTRACE_PROBE_DECL4(hotspot, monitor__contended__entered,
+  jlong, uintptr_t, char*, int);
+HS_DTRACE_PROBE_DECL4(hotspot, monitor__contended__exit,
+  jlong, uintptr_t, char*, int);
+
 #define DTRACE_MONITOR_WAIT_PROBE(monitor, klassOop, thread, millis)       \
   {                                                                        \
     if (DTraceMonitorProbes) {                                            \
@@ -107,6 +110,33 @@
     }                                                                      \
   }
 
+#else /* USDT2 */
+
+#define DTRACE_MONITOR_WAIT_PROBE(monitor, klassOop, thread, millis)       \
+  {                                                                        \
+    if (DTraceMonitorProbes) {                                            \
+      DTRACE_MONITOR_PROBE_COMMON(klassOop, thread);                       \
+      HOTSPOT_MONITOR_WAIT(jtid,                                           \
+                       (monitor), bytes, len, (millis));                   \
+    }                                                                      \
+  }
+
+#define HOTSPOT_MONITOR_contended__enter HOTSPOT_MONITOR_CONTENDED_ENTER
+#define HOTSPOT_MONITOR_contended__entered HOTSPOT_MONITOR_CONTENDED_ENTERED
+#define HOTSPOT_MONITOR_contended__exit HOTSPOT_MONITOR_CONTENDED_EXIT
+#define HOTSPOT_MONITOR_notify HOTSPOT_MONITOR_NOTIFY
+#define HOTSPOT_MONITOR_notifyAll HOTSPOT_MONITOR_NOTIFYALL
+
+#define DTRACE_MONITOR_PROBE(probe, monitor, klassOop, thread)             \
+  {                                                                        \
+    if (DTraceMonitorProbes) {                                            \
+      DTRACE_MONITOR_PROBE_COMMON(klassOop, thread);                       \
+      HOTSPOT_MONITOR_##probe(jtid,                                               \
+                       (uintptr_t)(monitor), bytes, len);                  \
+    }                                                                      \
+  }
+
+#endif /* USDT2 */
 #else //  ndef DTRACE_ENABLED
 
 #define DTRACE_MONITOR_WAIT_PROBE(klassOop, thread, millis, mon)    {;}
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/os.cpp openjdk/hotspot/src/share/vm/runtime/os.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/os.cpp	2012-07-25 15:14:34.586188125 +0100
+++ openjdk/hotspot/src/share/vm/runtime/os.cpp	2012-07-25 15:28:15.208297999 +0100
@@ -1098,6 +1098,9 @@
         "%/lib/netx.jar:"
         "%/lib/plugin.jar:"
         "%/lib/rhino.jar:"
+#ifdef __APPLE__
+        "%/lib/JObjC.jar:"
+#endif
         "%/classes";
     char* sysclasspath = format_boot_path(classpath_format, home, home_len, fileSep, pathSep);
     if (sysclasspath == NULL) return false;
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/os.hpp openjdk/hotspot/src/share/vm/runtime/os.hpp
--- openjdk.orig/hotspot/src/share/vm/runtime/os.hpp	2012-07-25 15:14:34.586188125 +0100
+++ openjdk/hotspot/src/share/vm/runtime/os.hpp	2012-07-25 15:27:37.295649247 +0100
@@ -184,6 +184,9 @@
   //    Returns true if it worked, false if it didn't.
   static bool bind_to_processor(uint processor_id);
 
+  // Give a name to the current thread.
+  static void set_native_thread_name(const char *name);
+
   // Interface for stack banging (predetect possible stack overflow for
   // exception processing)  There are guard pages, and above that shadow
   // pages for stack overflow checking.
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/sharedRuntime.cpp openjdk/hotspot/src/share/vm/runtime/sharedRuntime.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/sharedRuntime.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/sharedRuntime.cpp	2012-07-25 15:27:37.295649247 +0100
@@ -148,11 +148,13 @@
 
 #include <math.h>
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL4(hotspot, object__alloc, Thread*, char*, int, size_t);
 HS_DTRACE_PROBE_DECL7(hotspot, method__entry, int,
                       char*, int, char*, int, char*, int);
 HS_DTRACE_PROBE_DECL7(hotspot, method__return, int,
                       char*, int, char*, int, char*, int);
+#endif /* !USDT2 */
 
 // Implementation of SharedRuntime
 
@@ -954,8 +956,14 @@
   Klass* klass = o->blueprint();
   int size = o->size();
   Symbol* name = klass->name();
+#ifndef USDT2
   HS_DTRACE_PROBE4(hotspot, object__alloc, get_java_tid(thread),
                    name->bytes(), name->utf8_length(), size * HeapWordSize);
+#else /* USDT2 */
+  HOTSPOT_OBJECT_ALLOC(
+                   get_java_tid(thread),
+                   (char *) name->bytes(), name->utf8_length(), size * HeapWordSize);
+#endif /* USDT2 */
   return 0;
 }
 
@@ -965,10 +973,18 @@
   Symbol* kname = method->klass_name();
   Symbol* name = method->name();
   Symbol* sig = method->signature();
+#ifndef USDT2
   HS_DTRACE_PROBE7(hotspot, method__entry, get_java_tid(thread),
       kname->bytes(), kname->utf8_length(),
       name->bytes(), name->utf8_length(),
       sig->bytes(), sig->utf8_length());
+#else /* USDT2 */
+  HOTSPOT_METHOD_ENTRY(
+      get_java_tid(thread),
+      (char *) kname->bytes(), kname->utf8_length(),
+      (char *) name->bytes(), name->utf8_length(),
+      (char *) sig->bytes(), sig->utf8_length());
+#endif /* USDT2 */
   return 0;
 JRT_END
 
@@ -978,10 +994,18 @@
   Symbol* kname = method->klass_name();
   Symbol* name = method->name();
   Symbol* sig = method->signature();
+#ifndef USDT2
   HS_DTRACE_PROBE7(hotspot, method__return, get_java_tid(thread),
       kname->bytes(), kname->utf8_length(),
       name->bytes(), name->utf8_length(),
       sig->bytes(), sig->utf8_length());
+#else /* USDT2 */
+  HOTSPOT_METHOD_RETURN(
+      get_java_tid(thread),
+      (char *) kname->bytes(), kname->utf8_length(),
+      (char *) name->bytes(), name->utf8_length(),
+      (char *) sig->bytes(), sig->utf8_length());
+#endif /* USDT2 */
   return 0;
 JRT_END
 
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/synchronizer.cpp openjdk/hotspot/src/share/vm/runtime/synchronizer.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/synchronizer.cpp	2012-07-25 15:14:34.590188194 +0100
+++ openjdk/hotspot/src/share/vm/runtime/synchronizer.cpp	2012-07-25 15:27:37.295649247 +0100
@@ -77,11 +77,6 @@
 // Only bother with this argument setup if dtrace is available
 // TODO-FIXME: probes should not fire when caller is _blocked.  assert() accordingly.
 
-HS_DTRACE_PROBE_DECL5(hotspot, monitor__wait,
-  jlong, uintptr_t, char*, int, long);
-HS_DTRACE_PROBE_DECL4(hotspot, monitor__waited,
-  jlong, uintptr_t, char*, int);
-
 #define DTRACE_MONITOR_PROBE_COMMON(klassOop, thread)                      \
   char* bytes = NULL;                                                      \
   int len = 0;                                                             \
@@ -92,6 +87,12 @@
     len = klassname->utf8_length();                                        \
   }
 
+#ifndef USDT2
+HS_DTRACE_PROBE_DECL5(hotspot, monitor__wait,
+  jlong, uintptr_t, char*, int, long);
+HS_DTRACE_PROBE_DECL4(hotspot, monitor__waited,
+  jlong, uintptr_t, char*, int);
+
 #define DTRACE_MONITOR_WAIT_PROBE(monitor, klassOop, thread, millis)       \
   {                                                                        \
     if (DTraceMonitorProbes) {                                            \
@@ -110,6 +111,29 @@
     }                                                                      \
   }
 
+#else /* USDT2 */
+
+#define DTRACE_MONITOR_WAIT_PROBE(monitor, klassOop, thread, millis)       \
+  {                                                                        \
+    if (DTraceMonitorProbes) {                                            \
+      DTRACE_MONITOR_PROBE_COMMON(klassOop, thread);                       \
+      HOTSPOT_MONITOR_WAIT(jtid,                                           \
+                           (uintptr_t)(monitor), bytes, len, (millis));  \
+    }                                                                      \
+  }
+
+#define HOTSPOT_MONITOR_PROBE_waited HOTSPOT_MONITOR_PROBE_WAITED
+
+#define DTRACE_MONITOR_PROBE(probe, monitor, klassOop, thread)             \
+  {                                                                        \
+    if (DTraceMonitorProbes) {                                            \
+      DTRACE_MONITOR_PROBE_COMMON(klassOop, thread);                       \
+      HOTSPOT_MONITOR_PROBE_##probe(jtid, /* probe = waited */             \
+                       (uintptr_t)(monitor), bytes, len);                  \
+    }                                                                      \
+  }
+
+#endif /* USDT2 */
 #else //  ndef DTRACE_ENABLED
 
 #define DTRACE_MONITOR_WAIT_PROBE(klassOop, thread, millis, mon)    {;}
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/thread.cpp openjdk/hotspot/src/share/vm/runtime/thread.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/thread.cpp	2012-07-25 15:14:34.590188194 +0100
+++ openjdk/hotspot/src/share/vm/runtime/thread.cpp	2012-07-25 15:27:37.295649247 +0100
@@ -110,6 +110,7 @@
 
 // Only bother with this argument setup if dtrace is available
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL(hotspot, vm__init__begin);
 HS_DTRACE_PROBE_DECL(hotspot, vm__init__end);
 HS_DTRACE_PROBE_DECL5(hotspot, thread__start, char*, intptr_t,
@@ -130,6 +131,26 @@
       java_lang_Thread::is_daemon((javathread)->threadObj()));             \
   }
 
+#else /* USDT2 */
+
+#define HOTSPOT_THREAD_PROBE_start HOTSPOT_THREAD_PROBE_START
+#define HOTSPOT_THREAD_PROBE_stop HOTSPOT_THREAD_PROBE_STOP
+
+#define DTRACE_THREAD_PROBE(probe, javathread)                             \
+  {                                                                        \
+    ResourceMark rm(this);                                                 \
+    int len = 0;                                                           \
+    const char* name = (javathread)->get_thread_name();                    \
+    len = strlen(name);                                                    \
+    HOTSPOT_THREAD_PROBE_##probe(  /* probe = start, stop */               \
+      (char *) name, len,                                                           \
+      java_lang_Thread::thread_id((javathread)->threadObj()),              \
+      (uintptr_t) (javathread)->osthread()->thread_id(),                               \
+      java_lang_Thread::is_daemon((javathread)->threadObj()));             \
+  }
+
+#endif /* USDT2 */
+
 #else //  ndef DTRACE_ENABLED
 
 #define DTRACE_THREAD_PROBE(probe, javathread)
@@ -1328,7 +1349,7 @@
 DirtyCardQueueSet JavaThread::_dirty_card_queue_set;
 #endif // !SERIALGC
 
-JavaThread::JavaThread(bool is_attaching) :
+JavaThread::JavaThread(bool is_attaching_via_jni) :
   Thread()
 #ifndef SERIALGC
   , _satb_mark_queue(&_satb_mark_queue_set),
@@ -1336,7 +1357,11 @@
 #endif // !SERIALGC
 {
   initialize();
-  _is_attaching = is_attaching;
+  if (is_attaching_via_jni) {
+    _jni_attach_state = _attaching_via_jni;
+  } else {
+    _jni_attach_state = _not_attaching_via_jni;
+  }
   assert(_deferred_card_mark.is_empty(), "Default MemRegion ctor");
 }
 
@@ -1392,7 +1417,7 @@
     tty->print_cr("creating thread %p", this);
   }
   initialize();
-  _is_attaching = false;
+  _jni_attach_state = _not_attaching_via_jni;
   set_entry_point(entry_point);
   // Create the native thread itself.
   // %note runtime_23
@@ -1504,6 +1529,10 @@
   // Note: Due to JVM_StopThread we can have pending exceptions already!
   if (!this->has_pending_exception() &&
       !java_lang_Thread::is_stillborn(this->threadObj())) {
+    {
+      ResourceMark rm(this);
+      this->set_native_thread_name(this->get_thread_name());
+    }
     HandleMark hm(this);
     this->entry_point()(this, this);
   }
@@ -2683,7 +2712,7 @@
         name_str = UNICODE::as_utf8((jchar*) name->base(T_CHAR), name->length(), buf, buflen);
       }
     }
-    else if (is_attaching()) { // workaround for 6412693 - see 6404306
+    else if (is_attaching_via_jni()) { // workaround for 6412693 - see 6404306
       name_str = "<no-name - thread is attaching>";
     }
     else {
@@ -3079,7 +3108,11 @@
     os::pause();
   }
 
+#ifndef USDT2
   HS_DTRACE_PROBE(hotspot, vm__init__begin);
+#else /* USDT2 */
+  HOTSPOT_VM_INIT_BEGIN();
+#endif /* USDT2 */
 
   // Record VM creation timing statistics
   TraceVmCreationTime create_vm_timer;
@@ -3334,7 +3367,11 @@
   // debug stuff, that does not work until all basic classes have been initialized.
   set_init_completed();
 
+#ifndef USDT2
   HS_DTRACE_PROBE(hotspot, vm__init__end);
+#else /* USDT2 */
+  HOTSPOT_VM_INIT_END();
+#endif /* USDT2 */
 
   // record VM initialization completion time
   Management::record_vm_init_completed();
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/thread.hpp openjdk/hotspot/src/share/vm/runtime/thread.hpp
--- openjdk.orig/hotspot/src/share/vm/runtime/thread.hpp	2012-07-25 15:14:34.594188262 +0100
+++ openjdk/hotspot/src/share/vm/runtime/thread.hpp	2012-07-25 15:27:37.295649247 +0100
@@ -309,6 +309,11 @@
   static void interrupt(Thread* thr);
   static bool is_interrupted(Thread* thr, bool clear_interrupted);
 
+  void set_native_thread_name(const char *name) {
+    assert(Thread::current() == this, "set_native_thread_name can only be called on the current thread");
+    os::set_native_thread_name(name);
+  }
+
   ObjectMonitor** omInUseList_addr()             { return (ObjectMonitor **)&omInUseList; }
   Monitor* SR_lock() const                       { return _SR_lock; }
 
@@ -818,10 +823,17 @@
   bool                  _do_not_unlock_if_synchronized; // Do not unlock the receiver of a synchronized method (since it was
                                                  // never locked) when throwing an exception. Used by interpreter only.
 
-  //  Flag to mark a JNI thread in the process of attaching - See CR 6404306
-  //  This flag is never set true other than at construction, and in that case
-  //  is shortly thereafter set false
-  volatile bool _is_attaching;
+  // JNI attach states:
+  enum JNIAttachStates {
+    _not_attaching_via_jni = 1,  // thread is not attaching via JNI
+    _attaching_via_jni,          // thread is attaching via JNI
+    _attached_via_jni            // thread has attached via JNI
+  };
+
+  // A regular JavaThread's _jni_attach_state is _not_attaching_via_jni.
+  // A native thread that is attaching via JNI starts with a value
+  // of _attaching_via_jni and transitions to _attached_via_jni.
+  volatile JNIAttachStates _jni_attach_state;
 
  public:
   // State of the stack guard pages for this thread.
@@ -889,7 +901,7 @@
 
  public:
   // Constructor
-  JavaThread(bool is_attaching = false); // for main thread and JNI attached threads
+  JavaThread(bool is_attaching_via_jni = false); // for main thread and JNI attached threads
   JavaThread(ThreadFunction entry_point, size_t stack_size = 0);
   ~JavaThread();
 
@@ -1641,8 +1653,9 @@
   void set_cached_monitor_info(GrowableArray<MonitorInfo*>* info) { _cached_monitor_info = info; }
 
   // clearing/querying jni attach status
-  bool is_attaching() const { return _is_attaching; }
-  void set_attached() { _is_attaching = false; OrderAccess::fence(); }
+  bool is_attaching_via_jni() const { return _jni_attach_state == _attaching_via_jni; }
+  bool has_attached_via_jni() const { return is_attaching_via_jni() || _jni_attach_state == _attached_via_jni; }
+  void set_done_attaching_via_jni() { _jni_attach_state = _attached_via_jni; OrderAccess::fence(); }
 private:
   // This field is used to determine if a thread has claimed
   // a par_id: it is -1 if the thread has not claimed a par_id;
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/vmThread.cpp openjdk/hotspot/src/share/vm/runtime/vmThread.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/vmThread.cpp	2012-07-25 15:14:34.598188332 +0100
+++ openjdk/hotspot/src/share/vm/runtime/vmThread.cpp	2012-07-25 15:27:37.295649247 +0100
@@ -50,9 +50,11 @@
 # include "thread_bsd.inline.hpp"
 #endif
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL3(hotspot, vmops__request, char *, uintptr_t, int);
 HS_DTRACE_PROBE_DECL3(hotspot, vmops__begin, char *, uintptr_t, int);
 HS_DTRACE_PROBE_DECL3(hotspot, vmops__end, char *, uintptr_t, int);
+#endif /* !USDT2 */
 
 // Dummy VM operation to act as first element in our circular double-linked list
 class VM_Dummy: public VM_Operation {
@@ -162,8 +164,14 @@
 // High-level interface
 bool VMOperationQueue::add(VM_Operation *op) {
 
+#ifndef USDT2
   HS_DTRACE_PROBE3(hotspot, vmops__request, op->name(), strlen(op->name()),
                    op->evaluation_mode());
+#else /* USDT2 */
+  HOTSPOT_VMOPS_REQUEST(
+                   (char *) op->name(), strlen(op->name()),
+                   op->evaluation_mode());
+#endif /* USDT2 */
 
   // Encapsulates VM queue policy. Currently, that
   // only involves putting them on the right list
@@ -360,11 +368,23 @@
 
   {
     PerfTraceTime vm_op_timer(perf_accumulated_vm_operation_time());
+#ifndef USDT2
     HS_DTRACE_PROBE3(hotspot, vmops__begin, op->name(), strlen(op->name()),
                      op->evaluation_mode());
+#else /* USDT2 */
+    HOTSPOT_VMOPS_BEGIN(
+                     (char *) op->name(), strlen(op->name()),
+                     op->evaluation_mode());
+#endif /* USDT2 */
     op->evaluate();
+#ifndef USDT2
     HS_DTRACE_PROBE3(hotspot, vmops__end, op->name(), strlen(op->name()),
                      op->evaluation_mode());
+#else /* USDT2 */
+    HOTSPOT_VMOPS_END(
+                     (char *) op->name(), strlen(op->name()),
+                     op->evaluation_mode());
+#endif /* USDT2 */
   }
 
   // Last access of info in _cur_vm_operation!
diff -Nru openjdk.orig/hotspot/src/share/vm/services/classLoadingService.cpp openjdk/hotspot/src/share/vm/services/classLoadingService.cpp
--- openjdk.orig/hotspot/src/share/vm/services/classLoadingService.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/services/classLoadingService.cpp	2012-07-25 15:27:37.295649247 +0100
@@ -36,6 +36,8 @@
 
 // Only bother with this argument setup if dtrace is available
 
+#ifndef USDT2
+
 HS_DTRACE_PROBE_DECL4(hotspot, class__loaded, char*, int, oop, bool);
 HS_DTRACE_PROBE_DECL4(hotspot, class__unloaded, char*, int, oop, bool);
 
@@ -52,6 +54,24 @@
       data, len, (clss)->class_loader(), (shared)); \
   }
 
+#else /* USDT2 */
+
+#define HOTSPOT_CLASS_unloaded HOTSPOT_CLASS_UNLOADED
+#define HOTSPOT_CLASS_loaded HOTSPOT_CLASS_LOADED
+#define DTRACE_CLASSLOAD_PROBE(type, clss, shared)  \
+  {                                                 \
+    char* data = NULL;                              \
+    int len = 0;                                    \
+    Symbol* name = (clss)->name();                  \
+    if (name != NULL) {                             \
+      data = (char*)name->bytes();                  \
+      len = name->utf8_length();                    \
+    }                                               \
+    HOTSPOT_CLASS_##type( /* type = unloaded, loaded */ \
+      data, len, (clss)->class_loader(), (shared)); \
+  }
+
+#endif /* USDT2 */
 #else //  ndef DTRACE_ENABLED
 
 #define DTRACE_CLASSLOAD_PROBE(type, clss, shared)
diff -Nru openjdk.orig/hotspot/src/share/vm/services/memoryManager.cpp openjdk/hotspot/src/share/vm/services/memoryManager.cpp
--- openjdk.orig/hotspot/src/share/vm/services/memoryManager.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/services/memoryManager.cpp	2012-07-25 15:27:37.295649247 +0100
@@ -36,10 +36,12 @@
 #include "services/gcNotifier.hpp"
 #include "utilities/dtrace.hpp"
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL8(hotspot, mem__pool__gc__begin, char*, int, char*, int,
   size_t, size_t, size_t, size_t);
 HS_DTRACE_PROBE_DECL8(hotspot, mem__pool__gc__end, char*, int, char*, int,
   size_t, size_t, size_t, size_t);
+#endif /* !USDT2 */
 
 MemoryManager::MemoryManager() {
   _num_pools = 0;
@@ -238,11 +240,19 @@
       MemoryPool* pool = MemoryService::get_memory_pool(i);
       MemoryUsage usage = pool->get_memory_usage();
       _current_gc_stat->set_before_gc_usage(i, usage);
+#ifndef USDT2
       HS_DTRACE_PROBE8(hotspot, mem__pool__gc__begin,
         name(), strlen(name()),
         pool->name(), strlen(pool->name()),
         usage.init_size(), usage.used(),
         usage.committed(), usage.max_size());
+#else /* USDT2 */
+      HOTSPOT_MEM_POOL_GC_BEGIN(
+        (char *) name(), strlen(name()),
+        (char *) pool->name(), strlen(pool->name()),
+        usage.init_size(), usage.used(),
+        usage.committed(), usage.max_size());
+#endif /* USDT2 */
     }
   }
 }
@@ -268,11 +278,19 @@
       MemoryPool* pool = MemoryService::get_memory_pool(i);
       MemoryUsage usage = pool->get_memory_usage();
 
+#ifndef USDT2
       HS_DTRACE_PROBE8(hotspot, mem__pool__gc__end,
         name(), strlen(name()),
         pool->name(), strlen(pool->name()),
         usage.init_size(), usage.used(),
         usage.committed(), usage.max_size());
+#else /* USDT2 */
+      HOTSPOT_MEM_POOL_GC_END(
+        (char *) name(), strlen(name()),
+        (char *) pool->name(), strlen(pool->name()),
+        usage.init_size(), usage.used(),
+        usage.committed(), usage.max_size());
+#endif /* USDT2 */
 
       _current_gc_stat->set_after_gc_usage(i, usage);
     }
diff -Nru openjdk.orig/hotspot/src/share/vm/services/runtimeService.cpp openjdk/hotspot/src/share/vm/services/runtimeService.cpp
--- openjdk.orig/hotspot/src/share/vm/services/runtimeService.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/services/runtimeService.cpp	2012-07-25 15:27:37.299649316 +0100
@@ -30,8 +30,10 @@
 #include "utilities/dtrace.hpp"
 #include "utilities/exceptions.hpp"
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL(hs_private, safepoint__begin);
 HS_DTRACE_PROBE_DECL(hs_private, safepoint__end);
+#endif /* !USDT2 */
 
 TimeStamp RuntimeService::_app_timer;
 TimeStamp RuntimeService::_safepoint_timer;
@@ -108,7 +110,11 @@
 }
 
 void RuntimeService::record_safepoint_begin() {
+#ifndef USDT2
   HS_DTRACE_PROBE(hs_private, safepoint__begin);
+#else /* USDT2 */
+  HS_PRIVATE_SAFEPOINT_BEGIN();
+#endif /* USDT2 */
 
   // Print the time interval in which the app was executing
   if (PrintGCApplicationConcurrentTime) {
@@ -133,7 +139,11 @@
 }
 
 void RuntimeService::record_safepoint_end() {
+#ifndef USDT2
   HS_DTRACE_PROBE(hs_private, safepoint__end);
+#else /* USDT2 */
+  HS_PRIVATE_SAFEPOINT_END();
+#endif /* USDT2 */
 
   // Print the time interval for which the app was stopped
   // during the current safepoint operation.
diff -Nru openjdk.orig/hotspot/src/share/vm/services/threadService.cpp openjdk/hotspot/src/share/vm/services/threadService.cpp
--- openjdk.orig/hotspot/src/share/vm/services/threadService.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/services/threadService.cpp	2012-07-25 15:27:37.299649316 +0100
@@ -751,7 +751,7 @@
       _blocker_object = obj();
       JavaThread* owner = ObjectSynchronizer::get_lock_owner(obj, false);
       if ((owner == NULL && _thread_status == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER)
-          || (owner != NULL && owner->is_attaching())) {
+          || (owner != NULL && owner->is_attaching_via_jni())) {
         // ownership information of the monitor is not available
         // (may no longer be owned or releasing to some other thread)
         // make this thread in RUNNABLE state.
@@ -899,7 +899,7 @@
     }
 
     // skip jni threads in the process of attaching
-    if (!include_jni_attaching_threads && jt->is_attaching()) {
+    if (!include_jni_attaching_threads && jt->is_attaching_via_jni()) {
       continue;
     }
 
diff -Nru openjdk.orig/hotspot/src/share/vm/utilities/debug.cpp openjdk/hotspot/src/share/vm/utilities/debug.cpp
--- openjdk.orig/hotspot/src/share/vm/utilities/debug.cpp	2012-07-25 15:14:34.606188471 +0100
+++ openjdk/hotspot/src/share/vm/utilities/debug.cpp	2012-07-25 15:27:37.299649316 +0100
@@ -209,7 +209,7 @@
 // Place-holder for non-existent suppression check:
 #define error_is_suppressed(file_name, line_no) (false)
 
-#endif //PRODUCT
+#endif // !PRODUCT
 
 void report_vm_error(const char* file, int line, const char* error_msg,
                      const char* detail_msg)
@@ -264,7 +264,7 @@
 void report_untested(const char* file, int line, const char* message) {
 #ifndef PRODUCT
   warning("Untested: %s in %s: %d\n", message, file, line);
-#endif // PRODUCT
+#endif // !PRODUCT
 }
 
 void report_out_of_shared_space(SharedSpaceType shared_space) {
@@ -309,9 +309,6 @@
   }
 }
 
-
-extern "C" void ps();
-
 static bool error_reported = false;
 
 // call this when the VM is dying--it might loosen some asserts
@@ -366,11 +363,10 @@
     default: ShouldNotReachHere();
   }
 }
-#endif // #ifndef PRODUCT
+#endif // !PRODUCT
 
 // ------ helper functions for debugging go here ------------
 
-#ifndef PRODUCT
 // All debug entries should be wrapped with a stack allocated
 // Command object. It makes sure a resource mark is set and
 // flushes the logfile to prevent file sharing problems.
@@ -391,11 +387,17 @@
     tty->print_cr("\"Executing %s\"", str);
   }
 
-  ~Command() { tty->flush(); Debugging = debug_save; level--; }
+  ~Command() {
+        tty->flush();
+        Debugging = debug_save;
+        level--;
+  }
 };
 
 int Command::level = 0;
 
+#ifndef PRODUCT
+
 extern "C" void blob(CodeBlob* cb) {
   Command c("blob");
   cb->print();
@@ -478,7 +480,7 @@
     oop obj = oop(p);
     obj->print();
   } else {
-    tty->print("%#p", p);
+    tty->print(PTR_FORMAT, p);
   }
 }
 
@@ -487,7 +489,10 @@
 extern "C" void pa(intptr_t p)   { ((AllocatedObj*) p)->print(); }
 extern "C" void findpc(intptr_t x);
 
+#endif // !PRODUCT
+
 extern "C" void ps() { // print stack
+  if (Thread::current() == NULL) return;
   Command c("ps");
 
 
@@ -500,6 +505,11 @@
   if (p->has_last_Java_frame()) {
     // If the last_Java_fp is set we are in C land and
     // can call the standard stack_trace function.
+#ifdef PRODUCT
+    p->print_stack();
+  } else {
+    tty->print_cr("Cannot find the last Java frame, printing stack disabled.");
+#else // !PRODUCT
     p->trace_stack();
   } else {
     frame f = os::current_frame();
@@ -508,6 +518,7 @@
     tty->print("(guessing starting frame id=%#p based on current fp)\n", f.id());
     p->trace_stack_from(vframe::new_vframe(&f, &reg_map, p));
   pd_ps(f);
+#endif // PRODUCT
   }
 
 }
@@ -524,6 +535,8 @@
   }
 }
 
+#ifndef PRODUCT
+
 extern "C" void psf() { // print stack frames
   {
     Command c("psf");
@@ -555,12 +568,15 @@
   SafepointSynchronize::print_state();
 }
 
+#endif // !PRODUCT
 
 extern "C" void pss() { // print all stacks
+  if (Thread::current() == NULL) return;
   Command c("pss");
-  Threads::print(true, true);
+  Threads::print(true, PRODUCT_ONLY(false) NOT_PRODUCT(true));
 }
 
+#ifndef PRODUCT
 
 extern "C" void debug() {               // to set things up for compiler debugging
   Command c("debug");
@@ -911,4 +927,4 @@
 }
 #endif
 
-#endif // PRODUCT
+#endif // !PRODUCT
diff -Nru openjdk.orig/hotspot/src/share/vm/utilities/dtrace.hpp openjdk/hotspot/src/share/vm/utilities/dtrace.hpp
--- openjdk.orig/hotspot/src/share/vm/utilities/dtrace.hpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/utilities/dtrace.hpp	2012-07-25 15:27:37.299649316 +0100
@@ -25,7 +25,7 @@
 #ifndef SHARE_VM_UTILITIES_DTRACE_HPP
 #define SHARE_VM_UTILITIES_DTRACE_HPP
 
-#if defined(SOLARIS) && defined(DTRACE_ENABLED)
+#if defined(DTRACE_ENABLED)
 
 #include <sys/sdt.h>
 
@@ -36,11 +36,27 @@
 #define HS_DTRACE_WORKAROUND_TAIL_CALL_BUG() \
   do { volatile size_t dtrace_workaround_tail_call_bug = 1; } while (0)
 
-#else // ndef SOLARIS || ndef DTRACE_ENABLED
+#if defined(SOLARIS)
+#define USDT1 1
+#elif defined(__APPLE__)
+#define USDT2 1
+#include <sys/types.h>
+#include "dtracefiles/hotspot.h"
+#include "dtracefiles/hotspot_jni.h"
+#include "dtracefiles/hs_private.h"
+#else
+#error "dtrace enabled for unknown os"
+#endif /* defined(SOLARIS) */
+
+#else /* defined(DTRACE_ENABLED) */
 
 #define DTRACE_ONLY(x)
 #define NOT_DTRACE(x) x
 
+#define HS_DTRACE_WORKAROUND_TAIL_CALL_BUG()
+
+#ifndef USDT2
+
 #define DTRACE_PROBE(a,b) {;}
 #define DTRACE_PROBE1(a,b,c) {;}
 #define DTRACE_PROBE2(a,b,c,d) {;}
@@ -48,9 +64,14 @@
 #define DTRACE_PROBE4(a,b,c,d,e,f) {;}
 #define DTRACE_PROBE5(a,b,c,d,e,f,g) {;}
 
-#define HS_DTRACE_WORKAROUND_TAIL_CALL_BUG()
+#else /* USDT2 */
+
+#include "dtrace_usdt2_disabled.hpp"
+#endif /* USDT2 */
 
-#endif
+#endif /* defined(DTRACE_ENABLED) */
+
+#ifndef USDT2
 
 #define HS_DTRACE_PROBE_FN(provider,name)\
   __dtrace_##provider##___##name
@@ -133,4 +154,6 @@
     (uintptr_t)a3,(uintptr_t)a4,(uintptr_t)a5,(uintptr_t)a6,(uintptr_t)a7,\
     (uintptr_t)a8,(uintptr_t)a9))
 
+#endif /* !USDT2 */
+
 #endif // SHARE_VM_UTILITIES_DTRACE_HPP
diff -Nru openjdk.orig/hotspot/src/share/vm/utilities/dtrace_usdt2_disabled.hpp openjdk/hotspot/src/share/vm/utilities/dtrace_usdt2_disabled.hpp
--- openjdk.orig/hotspot/src/share/vm/utilities/dtrace_usdt2_disabled.hpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/share/vm/utilities/dtrace_usdt2_disabled.hpp	2012-07-25 15:27:37.299649316 +0100
@@ -0,0 +1,1097 @@
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_UTILITIES_DTRACE_USDT2_DISABLED_HPP
+#define SHARE_VM_UTILITIES_DTRACE_USDT2_DISABLED_HPP
+
+/* This file contains dummy provider probes needed when compiling a hotspot
+ * that does not support dtrace probes. This could be because we're building
+ * on a system that doesn't suuport dtrace or because we're bulding a variant
+ * of hotspot (like core) where we do not support dtrace
+ */
+#if !defined(DTRACE_ENABLED)
+
+#ifdef USDT2
+
+/* hotspot provider probes */
+#define HOTSPOT_CLASS_LOADED(arg0, arg1, arg2, arg3)
+#define HOTSPOT_CLASS_LOADED_ENABLED()  0
+#define HOTSPOT_CLASS_UNLOADED(arg0, arg1, arg2, arg3)
+#define HOTSPOT_CLASS_UNLOADED_ENABLED()  0
+#define HOTSPOT_CLASS_INITIALIZATION_REQUIRED(arg0, arg1, arg2, arg3)
+#define HOTSPOT_CLASS_INITIALIZATION_REQUIRED_ENABLED() 0
+#define HOTSPOT_CLASS_INITIALIZATION_RECURSIVE(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_CLASS_INITIALIZATION_RECURSIVE_ENABLED() 0
+#define HOTSPOT_CLASS_INITIALIZATION_CONCURRENT(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_CLASS_INITIALIZATION_CONCURRENT_ENABLED() 0
+#define HOTSPOT_CLASS_INITIALIZATION_ERRONEOUS(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_CLASS_INITIALIZATION_ERRONEOUS_ENABLED() 0
+#define HOTSPOT_CLASS_INITIALIZATION_SUPER_FAILED(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_CLASS_INITIALIZATION_SUPER_FAILED_ENABLED() 0
+#define HOTSPOT_CLASS_INITIALIZATION_CLINIT(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_CLASS_INITIALIZATION_CLINIT_ENABLED() 0
+#define HOTSPOT_CLASS_INITIALIZATION_ERROR(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_CLASS_INITIALIZATION_ERROR_ENABLED() 0
+#define HOTSPOT_CLASS_INITIALIZATION_END(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_CLASS_INITIALIZATION_END_ENABLED() 0
+#define HOTSPOT_COMPILED_METHOD_LOAD(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
+#define HOTSPOT_COMPILED_METHOD_LOAD_ENABLED()  0
+#define HOTSPOT_COMPILED_METHOD_UNLOAD(arg0, arg1, arg2, arg3, arg4, arg5)
+#define HOTSPOT_COMPILED_METHOD_UNLOAD_ENABLED() 0
+#define HOTSPOT_GC_BEGIN(arg0)
+#define HOTSPOT_GC_BEGIN_ENABLED() 0
+#define HOTSPOT_GC_END()
+#define HOTSPOT_GC_END_ENABLED() 0
+#define HOTSPOT_MEM_POOL_GC_BEGIN(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
+#define HOTSPOT_MEM_POOL_GC_BEGIN_ENABLED() 0
+#define HOTSPOT_MEM_POOL_GC_END(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
+#define HOTSPOT_MEM_POOL_GC_END_ENABLED() 0
+#define HOTSPOT_METHOD_COMPILE_BEGIN(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
+#define HOTSPOT_METHOD_COMPILE_BEGIN_ENABLED() 0
+#define HOTSPOT_METHOD_COMPILE_END(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
+#define HOTSPOT_METHOD_COMPILE_END_ENABLED() 0
+#define HOTSPOT_METHOD_ENTRY(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
+#define HOTSPOT_METHOD_ENTRY_ENABLED() 0
+#define HOTSPOT_METHOD_RETURN(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
+#define HOTSPOT_METHOD_RETURN_ENABLED() 0
+#define HOTSPOT_MONITOR_CONTENDED_ENTER(arg0, arg1, arg2, arg3)
+#define HOTSPOT_MONITOR_CONTENDED_ENTER_ENABLED() 0
+#define HOTSPOT_MONITOR_CONTENDED_ENTERED(arg0, arg1, arg2, arg3)
+#define HOTSPOT_MONITOR_CONTENDED_ENTERED_ENABLED() 0
+#define HOTSPOT_MONITOR_CONTENDED_EXIT(arg0, arg1, arg2, arg3)
+#define HOTSPOT_MONITOR_CONTENDED_EXIT_ENABLED() 0
+#define HOTSPOT_MONITOR_NOTIFY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_MONITOR_NOTIFY_ENABLED() 0
+#define HOTSPOT_MONITOR_NOTIFYALL(arg0, arg1, arg2, arg3)
+#define HOTSPOT_MONITOR_NOTIFYALL_ENABLED() 0
+#define HOTSPOT_MONITOR_WAIT(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_MONITOR_WAIT_ENABLED() 0
+#define HOTSPOT_MONITOR_WAIT_PROBE(arg0, arg1, arg2, arg3)
+#define HOTSPOT_MONITOR_WAIT_PROBE_ENABLED() 0
+#define HOTSPOT_MONITOR_WAITED(arg0, arg1, arg2, arg3)
+#define HOTSPOT_MONITOR_WAITED_ENABLED() 0
+#define HOTSPOT_OBJECT_ALLOC(arg0, arg1, arg2, arg3)
+#define HOTSPOT_OBJECT_ALLOC_ENABLED() 0
+#define HOTSPOT_THREAD_START(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_THREAD_START_ENABLED() 0
+#define HOTSPOT_THREAD_STOP(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_THREAD_STOP_ENABLED() 0
+#define HOTSPOT_THREAD_SLEEP_BEGIN(arg0)
+#define HOTSPOT_THREAD_SLEEP_BEGIN_ENABLED() 0
+#define HOTSPOT_THREAD_SLEEP_END(arg0)
+#define HOTSPOT_THREAD_SLEEP_END_ENABLED() 0
+#define HOTSPOT_THREAD_YIELD()
+#define HOTSPOT_THREAD_YIELD_ENABLED() 0
+#define HOTSPOT_THREAD_PARK_BEGIN(arg0, arg1, arg2)
+#define HOTSPOT_THREAD_PARK_BEGIN_ENABLED() 0
+#define HOTSPOT_THREAD_PARK_END(arg0)
+#define HOTSPOT_THREAD_PARK_END_ENABLED() 0
+#define HOTSPOT_THREAD_UNPARK()
+#define HOTSPOT_THREAD_UNPARK_ENABLED() 0
+#define HOTSPOT_VM_INIT_BEGIN()
+#define HOTSPOT_VM_INIT_BEGIN_ENABLED() 0
+#define HOTSPOT_VM_INIT_END()
+#define HOTSPOT_VM_INIT_END_ENABLED() 0
+#define HOTSPOT_VM_SHUTDOWN()
+#define HOTSPOT_VM_SHUTDOWN_ENABLED() 0
+#define HOTSPOT_VMOPS_REQUEST(arg0, arg1, arg2)
+#define HOTSPOT_VMOPS_REQUEST_ENABLED() 0
+#define HOTSPOT_VMOPS_BEGIN(arg0, arg1, arg2)
+#define HOTSPOT_VMOPS_BEGIN_ENABLED() 0
+#define HOTSPOT_VMOPS_END(arg0, arg1, arg2)
+#define HOTSPOT_VMOPS_END_ENABLED() 0
+
+/* hs_private provider probes */
+#define HS_PRIVATE_CMS_INITMARK_BEGIN()
+#define HS_PRIVATE_CMS_INITMARK_BEGIN_ENABLED() 0
+#define HS_PRIVATE_CMS_INITMARK_END()
+#define HS_PRIVATE_CMS_INITMARK_END_ENABLED() 0
+#define HS_PRIVATE_CMS_REMARK_BEGIN()
+#define HS_PRIVATE_CMS_REMARK_BEGIN_ENABLED() 0
+#define HS_PRIVATE_CMS_REMARK_END()
+#define HS_PRIVATE_CMS_REMARK_END_ENABLED() 0
+#define HS_PRIVATE_HASHTABLE_NEW_ENTRY(arg0, arg1, arg2, arg3)
+#define HS_PRIVATE_HASHTABLE_NEW_ENTRY_ENABLED() 0
+#define HS_PRIVATE_SAFEPOINT_BEGIN()
+#define HS_PRIVATE_SAFEPOINT_BEGIN_ENABLED() 0
+#define HS_PRIVATE_SAFEPOINT_END()
+#define HS_PRIVATE_SAFEPOINT_END_ENABLED() 0
+
+/* hotspot_jni provider probes */
+#define HOTSPOT_JNI_ALLOCOBJECT_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_ALLOCOBJECT_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_ALLOCOBJECT_RETURN(arg0)
+#define HOTSPOT_JNI_ALLOCOBJECT_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(arg0)
+#define HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(arg0)
+#define HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLBYTEMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLBYTEMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLBYTEMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLCHARMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLCHARMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLCHARMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLCHARMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLCHARMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLCHARMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLCHARMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLCHARMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLCHARMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLFLOATMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLFLOATMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLFLOATMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLFLOATMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLFLOATMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLFLOATMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLINTMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLINTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLINTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLINTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLINTMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLINTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLINTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLINTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLINTMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLINTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLINTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLINTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLLONGMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLLONGMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLLONGMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLLONGMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLLONGMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLLONGMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLLONGMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLLONGMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLLONGMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSHORTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSHORTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSHORTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(arg0)
+#define HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLVOIDMETHOD_RETURN()
+#define HOTSPOT_JNI_CALLVOIDMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLVOIDMETHODA_RETURN()
+#define HOTSPOT_JNI_CALLVOIDMETHODA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CALLVOIDMETHODV_RETURN()
+#define HOTSPOT_JNI_CALLVOIDMETHODV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_CREATEJAVAVM_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_CREATEJAVAVM_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_CREATEJAVAVM_RETURN(arg0)
+#define HOTSPOT_JNI_CREATEJAVAVM_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_DEFINECLASS_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_DEFINECLASS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_DEFINECLASS_RETURN(arg0)
+#define HOTSPOT_JNI_DEFINECLASS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_DELETEGLOBALREF_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_DELETEGLOBALREF_RETURN()
+#define HOTSPOT_JNI_DELETEGLOBALREF_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_DELETELOCALREF_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_DELETELOCALREF_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_DELETELOCALREF_RETURN()
+#define HOTSPOT_JNI_DELETELOCALREF_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN()
+#define HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(arg0)
+#define HOTSPOT_JNI_DESTROYJAVAVM_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_DESTROYJAVAVM_RETURN(arg0)
+#define HOTSPOT_JNI_DESTROYJAVAVM_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(arg0)
+#define HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(arg0)
+#define HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(arg0)
+#define HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(arg0)
+#define HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(arg0)
+#define HOTSPOT_JNI_EXCEPTIONCHECK_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(arg0)
+#define HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN()
+#define HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(arg0)
+#define HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN()
+#define HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(arg0)
+#define HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(arg0)
+#define HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_FATALERROR_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_FATALERROR_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_FINDCLASS_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_FINDCLASS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_FINDCLASS_RETURN(arg0)
+#define HOTSPOT_JNI_FINDCLASS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETARRAYLENGTH_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETARRAYLENGTH_RETURN(arg0)
+#define HOTSPOT_JNI_GETARRAYLENGTH_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN(arg0)
+#define HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN()
+#define HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETBOOLEANFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN(arg0)
+#define HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN()
+#define HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETBYTEFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETBYTEFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETBYTEFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETBYTEFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(arg0)
+#define HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETCHARARRAYREGION_RETURN()
+#define HOTSPOT_JNI_GETCHARARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETCHARFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETCHARFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETCHARFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETCHARFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(arg0)
+#define HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(arg0)
+#define HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(arg0)
+#define HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN(arg0)
+#define HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(arg0)
+#define HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(arg0)
+#define HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN()
+#define HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETDOUBLEFIELD_RETURN()
+#define HOTSPOT_JNI_GETDOUBLEFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETENV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETENV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETENV_RETURN(arg0)
+#define HOTSPOT_JNI_GETENV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETFIELDID_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_GETFIELDID_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETFIELDID_RETURN(arg0)
+#define HOTSPOT_JNI_GETFIELDID_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(arg0)
+#define HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN()
+#define HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETFLOATFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETFLOATFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETFLOATFIELD_RETURN()
+#define HOTSPOT_JNI_GETFLOATFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN(arg0)
+#define HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETINTARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETINTARRAYREGION_RETURN()
+#define HOTSPOT_JNI_GETINTARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETINTFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETINTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETINTFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETINTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETJAVAVM_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETJAVAVM_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETJAVAVM_RETURN(arg0)
+#define HOTSPOT_JNI_GETJAVAVM_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(arg0)
+#define HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETLONGARRAYREGION_RETURN()
+#define HOTSPOT_JNI_GETLONGARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETLONGFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETLONGFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETLONGFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETLONGFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETMETHODID_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_GETMETHODID_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETMETHODID_RETURN(arg0)
+#define HOTSPOT_JNI_GETMETHODID_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(arg0)
+#define HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETOBJECTCLASS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETOBJECTCLASS_RETURN(arg0)
+#define HOTSPOT_JNI_GETOBJECTCLASS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETOBJECTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETOBJECTFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETOBJECTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN(arg0)
+#define HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(arg0)
+#define HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN(arg0)
+#define HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN()
+#define HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSHORTFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSHORTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSHORTFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETSHORTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()
+#define HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_GETSTATICFIELDID_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICFIELDID_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICFIELDID_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()
+#define HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICINTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_GETSTATICMETHODID_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICMETHODID_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICMETHODID_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTRINGCHARS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGCHARS_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTRINGCHARS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTRINGLENGTH_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETSTRINGREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGREGION_RETURN()
+#define HOTSPOT_JNI_GETSTRINGREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(arg0)
+#define HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN()
+#define HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETSUPERCLASS_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_GETSUPERCLASS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETSUPERCLASS_RETURN(arg0)
+#define HOTSPOT_JNI_GETSUPERCLASS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_GETVERSION_ENTRY(arg0)
+#define HOTSPOT_JNI_GETVERSION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_GETVERSION_RETURN(arg0)
+#define HOTSPOT_JNI_GETVERSION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(arg0)
+#define HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_ISINSTANCEOF_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_ISINSTANCEOF_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_ISINSTANCEOF_RETURN(arg0)
+#define HOTSPOT_JNI_ISINSTANCEOF_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_ISSAMEOBJECT_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_ISSAMEOBJECT_RETURN(arg0)
+#define HOTSPOT_JNI_ISSAMEOBJECT_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_MONITORENTER_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_MONITORENTER_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_MONITORENTER_RETURN(arg0)
+#define HOTSPOT_JNI_MONITORENTER_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_MONITOREXIT_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_MONITOREXIT_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_MONITOREXIT_RETURN(arg0)
+#define HOTSPOT_JNI_MONITOREXIT_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWBYTEARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWBYTEARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWBYTEARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWCHARARRAY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWCHARARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWCHARARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWCHARARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(arg0)
+#define HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWFLOATARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWFLOATARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWFLOATARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWGLOBALREF_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWGLOBALREF_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWGLOBALREF_RETURN(arg0)
+#define HOTSPOT_JNI_NEWGLOBALREF_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWINTARRAY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWINTARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWINTARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWINTARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWLOCALREF_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWLOCALREF_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWLOCALREF_RETURN(arg0)
+#define HOTSPOT_JNI_NEWLOCALREF_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWLONGARRAY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWLONGARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWLONGARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWLONGARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWOBJECT_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_NEWOBJECT_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWOBJECT_RETURN(arg0)
+#define HOTSPOT_JNI_NEWOBJECT_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWOBJECTA_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_NEWOBJECTA_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWOBJECTA_RETURN(arg0)
+#define HOTSPOT_JNI_NEWOBJECTA_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWOBJECTARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWOBJECTV_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_NEWOBJECTV_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWOBJECTV_RETURN(arg0)
+#define HOTSPOT_JNI_NEWOBJECTV_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWSHORTARRAY_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWSHORTARRAY_RETURN(arg0)
+#define HOTSPOT_JNI_NEWSHORTARRAY_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWSTRING_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_NEWSTRING_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWSTRING_RETURN(arg0)
+#define HOTSPOT_JNI_NEWSTRING_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWSTRINGUTF_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWSTRINGUTF_RETURN(arg0)
+#define HOTSPOT_JNI_NEWSTRINGUTF_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(arg0)
+#define HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_POPLOCALFRAME_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_POPLOCALFRAME_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_POPLOCALFRAME_RETURN(arg0)
+#define HOTSPOT_JNI_POPLOCALFRAME_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(arg0)
+#define HOTSPOT_JNI_PUSHLOCALFRAME_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_REGISTERNATIVES_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_REGISTERNATIVES_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_REGISTERNATIVES_RETURN(arg0)
+#define HOTSPOT_JNI_REGISTERNATIVES_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN()
+#define HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN()
+#define HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN()
+#define HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN()
+#define HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN()
+#define HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN()
+#define HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN()
+#define HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN()
+#define HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN()
+#define HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN()
+#define HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN()
+#define HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN()
+#define HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN()
+#define HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETBOOLEANFIELD_RETURN()
+#define HOTSPOT_JNI_SETBOOLEANFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN()
+#define HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETBYTEFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETBYTEFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETBYTEFIELD_RETURN()
+#define HOTSPOT_JNI_SETBYTEFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETCHARARRAYREGION_RETURN()
+#define HOTSPOT_JNI_SETCHARARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETCHARFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETCHARFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETCHARFIELD_RETURN()
+#define HOTSPOT_JNI_SETCHARFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN()
+#define HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETDOUBLEFIELD_RETURN()
+#define HOTSPOT_JNI_SETDOUBLEFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN()
+#define HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETFLOATFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_SETFLOATFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETFLOATFIELD_RETURN()
+#define HOTSPOT_JNI_SETFLOATFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_SETINTARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETINTARRAYREGION_RETURN()
+#define HOTSPOT_JNI_SETINTARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETINTFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETINTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETINTFIELD_RETURN()
+#define HOTSPOT_JNI_SETINTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETLONGARRAYREGION_RETURN()
+#define HOTSPOT_JNI_SETLONGARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETLONGFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETLONGFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETLONGFIELD_RETURN()
+#define HOTSPOT_JNI_SETLONGFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN()
+#define HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETOBJECTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETOBJECTFIELD_RETURN()
+#define HOTSPOT_JNI_SETOBJECTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(arg0, arg1, arg2, arg3, arg4)
+#define HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN()
+#define HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSHORTFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETSHORTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSHORTFIELD_RETURN()
+#define HOTSPOT_JNI_SETSHORTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICINTFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICINTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN()
+#define HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_THROW_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_THROW_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_THROW_RETURN(arg0)
+#define HOTSPOT_JNI_THROW_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_THROWNEW_ENTRY(arg0, arg1, arg2)
+#define HOTSPOT_JNI_THROWNEW_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_THROWNEW_RETURN(arg0)
+#define HOTSPOT_JNI_THROWNEW_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(arg0)
+#define HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(arg0, arg1, arg2, arg3)
+#define HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(arg0)
+#define HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN_ENABLED()  0
+#define HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(arg0, arg1)
+#define HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY_ENABLED()  0
+#define HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(arg0)
+#define HOTSPOT_JNI_UNREGISTERNATIVES_RETURN_ENABLED()  0
+
+#else /* USDT2 */
+#error This file should only be included for USDT2
+#endif /* USDT2 */
+
+#else /* !defined(DTRACE_ENABLED) */
+#error This file should only be included when dtrace is not enabled
+#end /* !defined(DTRACE_ENABLED) */
+
+#endif // SHARE_VM_UTILITIES_DTRACE_USDT2_DISABLED_HPP
diff -Nru openjdk.orig/hotspot/src/share/vm/utilities/globalDefinitions.hpp openjdk/hotspot/src/share/vm/utilities/globalDefinitions.hpp
--- openjdk.orig/hotspot/src/share/vm/utilities/globalDefinitions.hpp	2012-07-25 15:14:34.614188609 +0100
+++ openjdk/hotspot/src/share/vm/utilities/globalDefinitions.hpp	2012-07-25 15:27:37.299649316 +0100
@@ -25,7 +25,9 @@
 #ifndef SHARE_VM_UTILITIES_GLOBALDEFINITIONS_HPP
 #define SHARE_VM_UTILITIES_GLOBALDEFINITIONS_HPP
 
+#ifndef __STDC_FORMAT_MACROS
 #define __STDC_FORMAT_MACROS
+#endif
 
 #ifdef TARGET_COMPILER_gcc
 # include "utilities/globalDefinitions_gcc.hpp"
diff -Nru openjdk.orig/hotspot/src/share/vm/utilities/hashtable.cpp openjdk/hotspot/src/share/vm/utilities/hashtable.cpp
--- openjdk.orig/hotspot/src/share/vm/utilities/hashtable.cpp	2012-06-07 19:21:17.000000000 +0100
+++ openjdk/hotspot/src/share/vm/utilities/hashtable.cpp	2012-07-25 15:27:37.299649316 +0100
@@ -32,8 +32,10 @@
 #include "utilities/hashtable.inline.hpp"
 
 
+#ifndef USDT2
 HS_DTRACE_PROBE_DECL4(hs_private, hashtable__new_entry,
   void*, unsigned int, void*, void*);
+#endif /* !USDT2 */
 
 // This is a generic hashtable, designed to be used for the symbol
 // and string tables.
@@ -73,8 +75,13 @@
 
   entry = (HashtableEntry<T>*)BasicHashtable::new_entry(hashValue);
   entry->set_literal(obj);
+#ifndef USDT2
   HS_DTRACE_PROBE4(hs_private, hashtable__new_entry,
     this, hashValue, obj, entry);
+#else /* USDT2 */
+  HS_PRIVATE_HASHTABLE_NEW_ENTRY(
+    this, hashValue, (uintptr_t) obj, entry);
+#endif /* USDT2 */
   return entry;
 }
 
