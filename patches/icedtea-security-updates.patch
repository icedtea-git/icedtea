No differences encountered
--- old/src/share/classes/com/sun/org/apache/xerces/internal/impl/XMLDocumentScannerImpl.java	Fri May 30 16:49:25 2008
+++ openjdk/jaxp/src/share/classes/com/sun/org/apache/xerces/internal/impl/XMLDocumentScannerImpl.java	Fri May 30 16:49:25 2008
@@ -185,9 +188,6 @@
     /** Load external DTD. */
     protected boolean fLoadExternalDTD = true;
 
-    /** Disallow doctype declaration. */
-    protected boolean fDisallowDoctype = false;
-
     // state
 
     /** Seen doctype declaration. */
@@ -227,8 +227,8 @@
     /** String. */
     private XMLString fString = new XMLString();
 
-    public static final char [] DOCTYPE = {'D','O','C','T','Y','P','E'};
-    public static final char [] COMMENTSTRING = {'-','-'};
+    private static final char [] DOCTYPE = {'D','O','C','T','Y','P','E'};
+    private static final char [] COMMENTSTRING = {'-','-'};
 
     //
     // Constructors
@@ -708,6 +708,12 @@
     //
     // Private methods
     //
+    /** Set the scanner state after scanning DTD */
+    protected void setEndDTDScanState() {
+        setScannerState(SCANNER_STATE_PROLOG);
+        setDriver(fPrologDriver);
+        fEntityManager.setEntityHandler(XMLDocumentScannerImpl.this);
+    }
 
     /** Returns the scanner state name. */
     protected String getScannerStateName(int state) {
@@ -930,19 +936,21 @@
                             reportFatalError("AlreadySeenDoctype", null);
                         }
                         fSeenDoctypeDecl = true;
-                        if(fDTDDriver == null){
-                            fDTDDriver = new DTDDriver();
-                        }
 
                         // scanDoctypeDecl() sends XNI doctypeDecl event that
                         // in SAX is converted to startDTD() event.
                         if (scanDoctypeDecl(fDisallowDoctype)) {
+                            //allow parsing of entity decls to continue in order to stay well-formed
                             setScannerState(SCANNER_STATE_DTD_INTERNAL_DECLS);
                             fSeenInternalSubset = true;
+                            if(fDTDDriver == null){
+                                fDTDDriver = new DTDDriver();
+                            }
                             setDriver(fContentDriver);
-                            int dtdEvent = fDTDDriver.next();
+                            //always return DTD event, the event however, will not contain any entities
+                            return fDTDDriver.next();
                             // If no DTD support, ignore and continue parsing
-                            return fDisallowDoctype ? next() : dtdEvent;
+                            //return fDisallowDoctype ? next() : dtdEvent;
                         }
 
                         /** xxx:check this part again
@@ -955,17 +963,18 @@
                         }
                          */
 
-                        if (fDisallowDoctype) {
-                            setScannerState(SCANNER_STATE_PROLOG);
-                            return next();
-                        }
-
                         // handle external subset
                         if (fDoctypeSystemId != null) {
                             if (((fValidation || fLoadExternalDTD)
                                 && (fValidationManager == null || !fValidationManager.isCachedDTD()))) {
-                                setScannerState(SCANNER_STATE_DTD_EXTERNAL);
+                                if (!fDisallowDoctype) {
+                                    setScannerState(SCANNER_STATE_DTD_EXTERNAL);
+                                } else {
+                                    setScannerState(SCANNER_STATE_PROLOG);
+                                }
                                 setDriver(fContentDriver);
+                                if(fDTDDriver == null)
+                                    fDTDDriver = new DTDDriver();
                                 return fDTDDriver.next();
 
                             }
@@ -976,8 +985,14 @@
                                 // This handles the case of a DOCTYPE that had neither an internal subset or an external subset.
                                 fDTDScanner.setInputSource(fExternalSubsetSource);
                                 fExternalSubsetSource = null;
-                                setScannerState(SCANNER_STATE_DTD_EXTERNAL_DECLS);
+                                if (!fDisallowDoctype) {
+                                    setScannerState(SCANNER_STATE_DTD_EXTERNAL_DECLS);
+                                } else {
+                                    setScannerState(SCANNER_STATE_PROLOG);
+                                }
                                 setDriver(fContentDriver);
+                                if(fDTDDriver == null)
+                                    fDTDDriver = new DTDDriver();
                                 return fDTDDriver.next();
                             }
                         }
@@ -1117,19 +1132,21 @@
                                 }
                                 fMarkupDepth--;
 
-                                // scan external subset next
-                                if (!XMLDocumentScannerImpl.this.fDisallowDoctype &&
-                                        fDoctypeSystemId != null && (fValidation || fLoadExternalDTD)) {
-                                    setScannerState(SCANNER_STATE_DTD_EXTERNAL);
+                                if (fDisallowDoctype) {
+                                    //simply reset the entity store without having to mess around
+                                    //with the DTD Scanner code
+                                    fEntityStore = fEntityManager.getEntityStore();
+                                    fEntityStore.reset();
+                                } else {
+                                    // scan external subset next unless we are ignoring DTDs
+                                    if (fDoctypeSystemId != null && (fValidation || fLoadExternalDTD)) {
+                                        setScannerState(SCANNER_STATE_DTD_EXTERNAL);
+                                        break;
+                                    }
                                 }
+                                setEndDTDScanState();
 
-                                // break out of here
-                                else {
-                                    setScannerState(SCANNER_STATE_PROLOG);
-                                    setDriver(fPrologDriver);
-                                    fEntityManager.setEntityHandler(XMLDocumentScannerImpl.this);
-                                    return true;
-                                }
+                                return true;
                             }
                             break;
                         }
@@ -1160,13 +1177,16 @@
                             boolean completeDTD = true;
                             boolean moreToScan = fDTDScanner.scanDTDExternalSubset(completeDTD);
                             if (!moreToScan) {
-                                setScannerState(SCANNER_STATE_PROLOG);
-                                setDriver(fPrologDriver);
-                                fEntityManager.setEntityHandler(XMLDocumentScannerImpl.this);
+                                setEndDTDScanState();
                                 return true;
                             }
                             break;
                         }
+                        case SCANNER_STATE_PROLOG : {
+                            // skip entity decls
+                            setEndDTDScanState();
+                            return true;
+                        }
                         default: {
                             throw new XNIException("DTDDriver#dispatch: scanner state="+fScannerState+" ("+getScannerStateName(fScannerState)+')');
                         }
--- old/src/share/classes/com/sun/org/apache/xerces/internal/impl/XMLDocumentFragmentScannerImpl.java	Fri May 30 16:49:29 2008
+++ openjdk/jaxp/src/share/classes/com/sun/org/apache/xerces/internal/impl/XMLDocumentFragmentScannerImpl.java	Fri May 30 16:49:29 2008
@@ -289,6 +289,8 @@
     protected boolean fReportCdataEvent = false ;
     protected boolean fIsCoalesce = false ;
     protected String fDeclaredEncoding =  null;
+    /** Disallow doctype declaration. */
+    protected boolean fDisallowDoctype = false;
 
     // drivers
 
@@ -1852,6 +1854,11 @@
         }
         // start general entity
         if (!fEntityStore.isDeclaredEntity(name)) {
+            //SUPPORT_DTD=false && ReplaceEntityReferences should throw exception
+            if (fDisallowDoctype && fReplaceEntityReferences) {
+                reportFatalError("EntityNotDeclared", new Object[]{name});
+                return;
+            }
             //REVISIT: one more case needs to be included: external PE and standalone is no
             if ( fHasExternalDTD && !fStandalone) {
                 if (fValidation)
--- /dev/null	Mon Jun  2 16:07:10 2008
+++ openjdk/jaxws/test/closed/javax/xml/stream/XMLStreamReaderTest/SupportDTD.java	Mon Jun  2 16:07:26 2008
@@ -0,0 +1,296 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
+ *
+ * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved.
+ *
+ * The contents of this file are subject to the terms of either the GNU
+ * General Public License Version 2 only ("GPL") or the Common Development
+ * and Distribution License("CDDL") (collectively, the "License").  You
+ * may not use this file except in compliance with the License. You can obtain
+ * a copy of the License at https://glassfish.dev.java.net/public/CDDL+GPL.html
+ * or glassfish/bootstrap/legal/LICENSE.txt.  See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ * When distributing the software, include this License Header Notice in each
+ * file and include the License file at glassfish/bootstrap/legal/LICENSE.txt.
+ * Sun designates this particular file as subject to the "Classpath" exception
+ * as provided by Sun in the GPL Version 2 section of the License file that
+ * accompanied this code.  If applicable, add the following below the License
+ * Header, with the fields enclosed by brackets [] replaced by your own
+ * identifying information: "Portions Copyrighted [year]
+ * [name of copyright owner]"
+ *
+ * Contributor(s):
+ *
+ * If you wish your version of this file to be governed by only the CDDL or
+ * only the GPL Version 2, indicate your decision by adding "[Contributor]
+ * elects to include this software in this distribution under the [CDDL or GPL
+ * Version 2] license."  If you don't indicate a single choice of license, a
+ * recipient has the option to distribute your version of this file under
+ * either the CDDL, the GPL Version 2 or to extend the choice of license to
+ * its licensees as provided above.  However, if you add GPL Version 2 code
+ * and therefore, elected the GPL Version 2 license, then the option applies
+ * only if the new code is made subject to such option by the copyright
+ * holder.
+ */
+
+/*
+ * @test @(#)SupportDTD.java	1.1 08/03/28
+ * @bug 6542088
+ * @key cte_test
+ * @summary JAX-WS server allows XXE attacks
+ *          Fixed in JDK6u7
+ * @run main SupportDTD
+*/
+
+import java.io.StringReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.util.List;
+
+import javax.xml.stream.XMLEventReader;
+
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamConstants;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.events.*;
+import javax.xml.stream.events.Characters;
+
+/**
+ *
+ * SUPPORT_DTD behavior:
+ * Regardless of supportDTD, always report a DTD event () and throw an
+ * exception if an entity reference is found when supportDTD is false
+ *
+ * The behavior is related to property IS_REPLACING_ENTITY_REFERENCES.
+ *
+ * SUPPORT_DTD      Replace Entity   DTD                    ENTITY_REFERENCE
+ * true (default)   true (default)   yes, has entities      no, return Characters
+ * true (default)   false            yes, has entities      yes, can print entity name
+ * false            true (default)   yes, but no entity     Exception: Undeclared general entity
+ * false            false            yes, but no entity     yes, can print entity name
+ *
+ * Two patches related:
+ * sjsxp issue 9: XMLDocumentScannerImpl.java rev 1.6
+ * If the supportDTD property is set to FALSE, external and internal subsets
+ * are now ignored, rather than an error being reported. In particular, with
+ * this property set to FALSE, no error is reported if an external subset cannot
+ * be found. Note that the internal subset is still parsed (and errors could be
+ * reported here) but no events are returned by the parser. This fixes SJSXP
+ * issue 9 from Java.net.
+ * Note: SAX and DOM report fatal errors:
+ *       If either SAX or DOM is used, turning on http://apache.org/xml/features/disallow-doctype-decl [1] effectively disables DTD,
+ *       according to the spec: A fatal error is thrown if the incoming document contains a DOCTYPE declaration.
+ *       The current jaxp implementation actually throws a nullpointexception. A better error message could be used.
+ *
+ * This change is required by CR 6542088.
+ * @author joe.wang@sun.com
+ */
+public class SupportDTD  {
+    static final boolean DEBUG = false;
+    static final String _file = "./tests/XMLStreamReader/ExternalDTD.xml";
+    static final String XML = "<?xml version='1.0' ?>"
+            +"<!DOCTYPE root [\n"
+            +"<!ENTITY intEnt 'internal entity'>\n"
+            +"<!ENTITY extParsedEnt SYSTEM 'url:dummy'>\n"
+            +"<!NOTATION notation PUBLIC 'notation-public-id'>\n"
+            +"<!NOTATION notation2 SYSTEM 'url:dummy'>\n"
+            +"<!ENTITY extUnparsedEnt SYSTEM 'url:dummy2' NDATA notation>\n"
+            +"]>"
+            +"<root>&intEnt;</root>";
+    static final String XML1 = "<?xml version='1.0' encoding ='utf-8'?>"
+            +"<!DOCTYPE document SYSTEM \"tests/XMLStreamReader/ExternalDTD.dtd\">"
+            +"<document>"
+            +       "<name>&mkm;</name>"
+            +"</document>";
+    
+    static final int ENTITY_INTERNAL_ONLY = 1;
+    static final int ENTITY_EXTERNAL_ONLY = 2;
+    static final int ENTITY_BOTH = 3;
+    
+    static boolean _DTDReturned = false;
+    static boolean _EntityEventReturned = false;
+    static boolean _hasEntityDelaration = false;
+    static boolean _exceptionThrown = false;
+
+    public static void reset() {
+        _DTDReturned = false;
+        _EntityEventReturned = false;
+        _hasEntityDelaration = false;
+        _exceptionThrown = false;
+    }
+
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String[] args) {
+        test1();
+        test2();
+        test3();
+        test4();
+        test5();
+        test6();
+        test7();
+        test8();
+        test9();
+        test10();
+        test11();
+        test12();
+    }
+    
+    //tests 1-4 test internal entities only
+    public static void test1() {
+        supportDTD(true, true, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(true, _hasEntityDelaration);
+        assertEquals(false, _EntityEventReturned);
+    }
+    public static void test2() {
+        supportDTD(true, false, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(true, _hasEntityDelaration);
+        assertEquals(true, _EntityEventReturned);
+    }
+    public static void test3() {
+        supportDTD(false, true, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(false, _hasEntityDelaration);
+        assertEquals(true, _exceptionThrown);
+    }
+    public static void test4() {
+        supportDTD(false, false, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(false, _hasEntityDelaration);
+        assertEquals(true, _EntityEventReturned);
+    }
+    //tests 5-8 test external entities only
+    public static void test5() {
+        supportDTD(true, true, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(true, _hasEntityDelaration);
+        assertEquals(false, _EntityEventReturned);
+    }
+    public static void test6() {
+        supportDTD(true, false, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(true, _hasEntityDelaration);
+        assertEquals(true, _EntityEventReturned);
+    }
+    public static void test7() {
+        supportDTD(false, true, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(false, _hasEntityDelaration);
+        assertEquals(true, _exceptionThrown);
+    }
+    public static void test8() {
+        supportDTD(false, false, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(false, _hasEntityDelaration);
+        assertEquals(true, _EntityEventReturned);
+    }    
+    //tests 9-12 test both internal and external entities
+    public static void test9() {
+        supportDTD(true, true, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(true, _hasEntityDelaration);
+        assertEquals(false, _EntityEventReturned);
+    }
+    public static void test10() {
+        supportDTD(true, false, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(true, _hasEntityDelaration);
+        assertEquals(true, _EntityEventReturned);
+    }
+    public static void test11() {
+        supportDTD(false, true, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(false, _hasEntityDelaration);
+        assertEquals(true, _exceptionThrown);
+    }
+    public static void test12() {
+        supportDTD(false, false, ENTITY_INTERNAL_ONLY);
+        assertEquals(true, _DTDReturned);
+        assertEquals(false, _hasEntityDelaration);
+        assertEquals(true, _EntityEventReturned);
+    }    
+    
+    public static void assertEquals(boolean bExpected, boolean bActual) {
+        if (bExpected != bActual) {
+            throw new RuntimeException("Test Failed");
+        }
+    }    
+
+    public static void supportDTD(boolean supportDTD, boolean replaceEntity, int inputType) {
+        reset();
+        print("\n");
+        print((supportDTD?"SupportDTD=true":"SupportDTD=false") + ", " + (replaceEntity?"replaceEntity=true":"replaceEntity=false"));
+        try {
+            XMLInputFactory xif = getFactory(supportDTD, replaceEntity);
+            XMLEventReader r = getEventReader(xif, inputType);
+            int eventType = 0;
+            int count = 0;
+            while (r.hasNext()) {
+                XMLEvent event = r.nextEvent();
+                eventType = event.getEventType();
+                print("Event " + ++count +": " + eventType);
+                switch (eventType) {
+                    case XMLStreamConstants.DTD :
+                        DisplayEntities((DTD)event);
+                        _DTDReturned = true;
+                        break;
+                    case XMLStreamConstants.ENTITY_REFERENCE :
+                        print("Entity Name: " + ((EntityReference)event).getName());
+                        _EntityEventReturned = true;
+                        break;
+                    case XMLStreamConstants.CHARACTERS :
+                        print("Text: " + ((Characters)event).getData());
+                }
+            }
+            
+        } catch (Exception e) {
+            _exceptionThrown = true;
+            if (DEBUG) e.printStackTrace();
+        }
+    }
+    
+    static XMLInputFactory getFactory(boolean supportDTD, boolean replaceEntity) {
+        XMLInputFactory xif = XMLInputFactory.newInstance();
+        xif.setProperty(XMLInputFactory.SUPPORT_DTD, (supportDTD)?Boolean.TRUE:Boolean.FALSE);
+        xif.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, (replaceEntity)?Boolean.TRUE:Boolean.FALSE);
+        //xif.setProperty(XMLInputFactory.IS_VALIDATING, Boolean.TRUE);
+        return xif;
+    }
+    static private XMLEventReader getEventReader(XMLInputFactory inputFactory, int input)
+    throws Exception {
+        XMLEventReader er = null;
+        if (input == ENTITY_INTERNAL_ONLY) {
+            er = inputFactory.createXMLEventReader(new StringReader(XML));
+        } else if (input == ENTITY_EXTERNAL_ONLY) {
+            er = inputFactory.createXMLEventReader(new StringReader(XML1));
+        } else {
+            File file = new File(_file);
+            FileInputStream inputStream = new FileInputStream(file);
+            //XMLStreamReader r = xif.createXMLStreamReader(inputStream);
+            er = inputFactory.createXMLEventReader(inputStream);
+        }
+        return er;
+    }
+    static void DisplayEntities(DTD event) {
+        List entities = event.getEntities();
+        if (entities == null) {
+            _hasEntityDelaration = false;
+            print("No entity found.");
+        } else {
+            _hasEntityDelaration = true;
+            for (int i=0; i<entities.size(); i++) {
+                EntityDeclaration entity = (EntityDeclaration)entities.get(i);
+                print(entity.getName());
+            }
+        }
+        
+    }
+    static void print(String s) {
+        if (DEBUG) System.out.println(s);
+    }
+    
+}
--- oldXMLStreamReaderFactory.java	2008-07-03 15:12:48.000000000 -0400
+++ openjdk/jaxws/src/share/classes/com/sun/xml/internal/ws/streaming/XMLStreamReaderFactory.java	2008-07-03 15:13:27.000000000 -0400
@@ -67,6 +67,7 @@
         // Use StAX pluggability layer to get factory instance
         xmlInputFactory = XMLInputFactory.newInstance();
         xmlInputFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.TRUE);
+	xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);
 
         try {
             // Turn OFF internal factory caching in Zephyr -- not thread safe
--- old/src/share/classes/com/sun/org/apache/xml/internal/utils/ThreadControllerWrapper.java	Fri May 30 17:01:31 2008
+++ openjdk/jaxp/src/share/classes/com/sun/org/apache/xml/internal/utils/ThreadControllerWrapper.java	Fri May 30 17:01:31 2008
@@ -53,7 +53,35 @@
   {
 
     /**
-     * Will get a thread from the pool, execute the task
+      * This class was introduced as a fix for CR 6607339.
+      */
+     final class SafeThread extends Thread {
+          private volatile boolean ran = false;
+                  
+          public SafeThread(Runnable target) {
+              super(target);
+          }
+                  
+          public final void run() {
+              if (Thread.currentThread() != this) {
+                  throw new IllegalStateException("The run() method in a"
+                      + " SafeThread cannot be called from another thread.");
+              }
+              synchronized (this) {
+                 if (!ran) {
+                     ran = true;
+                 }
+                 else {
+                  throw new IllegalStateException("The run() method in a"
+                      + " SafeThread cannot be called more than once.");
+                 }                 
+              }             
+              super.run();
+          }
+     }
+ 
+     /**
+     *  Will get a thread from the pool, execute the task
      *  and return the thread to the pool.
      *
      *  The return value is used only to wait for completion
@@ -68,7 +96,7 @@
     public Thread run(Runnable task, int priority)
     {
 
-      Thread t = new Thread(task);
+      Thread t = new SafeThread(task);
 
       t.start();
 
--- /dev/null	Mon Jun  2 16:57:20 2008
+++ openjdk/jdk/test/closed/com/sun/org/apache/xml/internal/utils/Test.java	Mon Jun  2 16:57:36 2008
@@ -0,0 +1,110 @@
+/*
+ * @test @(#)Test.java	1.2 08/04/23
+ * @bug 6607339
+ * @key cte_test
+ * @summary IncrementalSAXSource_Filter still allows reading of local files
+ * @compile Test.java
+ * @run shell Test6607339.sh
+*/
+/*
+ * Test.java
+ *
+ * Created on February 20, 2007, 10:42 AM
+ *
+ * To change this template, choose Tools | Template Manager
+ * and open the template in the editor.
+ */
+
+import java.lang.reflect.*;
+
+import com.sun.org.apache.xml.internal.dtm.ref.DTMManagerDefault;
+import java.awt.EventQueue;
+import java.io.File;
+
+/**
+ * Test for CR 6607339. Note that this isn't a unit test, but a
+ * standalone test instead. Correct termination is based on the 
+ * exact number of remaining threads and requires calling System.exit(). 
+ * Thus, it cannot be executed as a unit test
+ *
+ * @author Santiago.PericasGeertsen@sun.com
+ */
+public class Test {
+    
+    public static void main(String[] args) throws Exception {
+        new Test().test();
+    }
+    
+    public void test() throws Exception {
+        // The GNOME Accessibility JavaBridge will not initialise
+        // from an untrusted context.
+        // So we need to load the toolkit before the security manager is set.
+        java.awt.Toolkit.getDefaultToolkit();
+
+        // Target XML filewe should not be able to access.
+        // Requires full path name.
+        java.io.File target = 
+                new File(getClass().getResource("target.xml").getFile());
+        String systemID = target.toURI().toURL().toString();
+
+        System.setSecurityManager(new SecurityManager());
+
+        DTMManagerDefault manager = new DTMManagerDefault() {
+            // We need a SAXParser that does the job of SAXParser
+            //   without quite being SAXParser itself.
+            // So we return an instance of an (anonymous) subclass.
+            public org.xml.sax.XMLReader getXMLReader(
+                javax.xml.transform.Source inputSource
+            ) {
+                org.xml.sax.XMLReader reader =
+                    super.getXMLReader(inputSource);
+                return
+                   new
+                       com.sun.org.apache.xerces.internal.parsers.
+                       SAXParser() { };
+            }
+        };
+        // Enable incremental parsing.
+        manager.setIncremental(true);
+
+        // Grab old threads, so we can detect the new one.
+        java.util.Set oldThreads = getThreads();
+
+        com.sun.org.apache.xml.internal.dtm.DTM dtm =
+            manager.getDTM(
+                new javax.xml.transform.stream.StreamSource(systemID),
+                true, // unique
+                null, // DTMWSFilter
+                true, // incremental
+                false // doIndexing
+            );
+
+        // Should be exactly one new thread.
+        java.util.Set threads = getThreads();
+        threads.removeAll(oldThreads);
+        if (threads.size() != 1) {
+            throw new Error(threads.toString());
+        }
+        Thread thread = (Thread) threads.iterator().next();
+        // Suspend the thread.
+        thread.suspend();
+        // Run the Thread as a Runnable
+        //   without user code on the stack.
+        java.awt.EventQueue.invokeLater(thread);
+
+        // Ensure correct termination by counting number of threads
+        Thread.sleep(100);
+        assert getThreads().size() == 5;
+
+        // Call exit to kill all remaining threads
+        System.exit(0);
+    }
+    
+    private static java.util.Set getThreads() {
+        Thread[] threads = new Thread[Thread.activeCount()*2+10];
+        Thread.enumerate(threads);
+        return new java.util.HashSet(
+            java.util.Arrays.asList(threads)
+        );
+    }
+}
--- /dev/null	Mon Jun  2 16:57:21 2008
+++ openjdk/jdk/test/closed/com/sun/org/apache/xml/internal/utils/target.xml	Mon Jun  2 16:57:37 2008
@@ -0,0 +1,2 @@
+<?xml version="1.0"?>
+<doc>this is a secret</doc>
--- /dev/null	Mon Jun  2 09:19:39 2008
+++ openjdk/jdk/test/sun/management/jmxremote/bootstrap/LocalOnlyTest.java	Mon Jun  2 09:19:39 2008
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6685178
+ * @summary Sanity check for local only option. In order to fully test this
+ *          new local only option two different machines would be required.
+ * @author Luis-Miguel Alventosa
+ * @run main/othervm LocalOnlyTest
+ * @run main/othervm -Dcom.sun.management.jmxremote.local.only=true LocalOnlyTest
+ * @run main/othervm -Dcom.sun.management.jmxremote.local.only=false LocalOnlyTest
+ * @run main/othervm -Dcom.sun.management.jmxremote LocalOnlyTest
+ * @run main/othervm -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=true LocalOnlyTest
+ * @run main/othervm -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=false LocalOnlyTest
+ * @run main/othervm -Dcom.sun.management.jmxremote.port=0 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false LocalOnlyTest
+ * @run main/othervm -Dcom.sun.management.jmxremote.port=0 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.local.only=true LocalOnlyTest
+ * @run main/othervm -Dcom.sun.management.jmxremote.port=0 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.local.only=false LocalOnlyTest
+ */
+
+import java.io.*;
+import java.lang.management.*;
+import java.util.*;
+import javax.management.*;
+import javax.management.remote.*;
+import com.sun.tools.attach.*;
+
+public class LocalOnlyTest {
+
+    public static void main(String args[]) throws Exception {
+        RuntimeMXBean rt = ManagementFactory.getRuntimeMXBean();
+        String name = rt.getName();
+        System.out.println("name = " + name);
+        String vmid = name.substring(0, name.indexOf("@"));
+        System.out.println("vmid = " + vmid);
+        VirtualMachine vm = VirtualMachine.attach(vmid);
+        String addr = vm.getAgentProperties().getProperty(
+                "com.sun.management.jmxremote.localConnectorAddress");
+        System.out.println("connectorAddress = " + addr);
+        if (addr == null) {
+            // Normally in ${java.home}/jre/lib/management-agent.jar
+            // but might be in ${java.home}/lib in build environments.
+            String javaHome = System.getProperty("java.home");
+            String agent = javaHome + File.separator + "jre" + File.separator +
+                    "lib" + File.separator + "management-agent.jar";
+            File f = new File(agent);
+            if (!f.exists()) {
+                agent = javaHome + File.separator + "lib" + File.separator +
+                        "management-agent.jar";
+                f = new File(agent);
+                if (!f.exists()) {
+                    throw new IOException("Management agent not found");
+                }
+            }
+            agent = f.getCanonicalPath();
+            try {
+                vm.loadAgent(agent, "com.sun.management.jmxremote");
+            } catch (AgentLoadException x) {
+                IOException ioe = new IOException(x.getMessage());
+                ioe.initCause(x);
+                throw ioe;
+            } catch (AgentInitializationException x) {
+                IOException ioe = new IOException(x.getMessage());
+                ioe.initCause(x);
+                throw ioe;
+            }
+            addr = vm.getAgentProperties().getProperty(
+                    "com.sun.management.jmxremote.localConnectorAddress");
+            System.out.println("connectorAddress (after loading agent) = " + addr);
+        }
+        vm.detach();
+        JMXServiceURL url = new JMXServiceURL(addr);
+        JMXConnector c = JMXConnectorFactory.connect(url);
+        System.out.println("connectionId  = " + c.getConnectionId());
+        System.out.println("Bye! Bye!");
+    }
+}

