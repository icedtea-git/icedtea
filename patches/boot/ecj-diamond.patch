diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Attribute.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Attribute.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Attribute.java	2011-04-14 01:29:58.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Attribute.java	2011-07-12 16:56:06.686259706 +0100
@@ -104,9 +104,9 @@
         return this.def.compareTo(that.def);
     }
 
-    private static final Map<List<Attribute>, List<Attribute>> canonLists = new HashMap<>();
-    private static final Map<Layout, Attribute> attributes = new HashMap<>();
-    private static final Map<Layout, Attribute> standardDefs = new HashMap<>();
+    private static final Map<List<Attribute>, List<Attribute>> canonLists = new HashMap<List<Attribute>, List<Attribute>>();
+    private static final Map<Layout, Attribute> attributes = new HashMap<Layout, Attribute>();
+    private static final Map<Layout, Attribute> standardDefs = new HashMap<Layout, Attribute>();
 
     // Canonicalized lists of trivial attrs (Deprecated, etc.)
     // are used by trimToSize, in order to reduce footprint
@@ -116,7 +116,7 @@
         synchronized (canonLists) {
             List<Attribute> cl = canonLists.get(al);
             if (cl == null) {
-                cl = new ArrayList<>(al.size());
+                cl = new ArrayList<Attribute>(al.size());
                 cl.addAll(al);
                 cl = Collections.unmodifiableList(cl);
                 canonLists.put(al, cl);
@@ -337,9 +337,9 @@
 
         public void addAttribute(Attribute a) {
             if (attributes == null)
-                attributes = new ArrayList<>(3);
+                attributes = new ArrayList<Attribute>(3);
             else if (!(attributes instanceof ArrayList))
-                attributes = new ArrayList<>(attributes);  // unfreeze it
+                attributes = new ArrayList<Attribute>(attributes);  // unfreeze it
             attributes.add(a);
         }
 
@@ -347,7 +347,7 @@
             if (attributes == null)       return null;
             if (!attributes.contains(a))  return null;
             if (!(attributes instanceof ArrayList))
-                attributes = new ArrayList<>(attributes);  // unfreeze it
+                attributes = new ArrayList<Attribute>(attributes);  // unfreeze it
             attributes.remove(a);
             return a;
         }
@@ -838,7 +838,7 @@
     */
     static //private
     Layout.Element[] tokenizeLayout(Layout self, int curCble, String layout) {
-        List<Layout.Element> col = new ArrayList<>(layout.length());
+        List<Layout.Element> col = new ArrayList<Layout.Element>(layout.length());
         tokenizeLayout(self, curCble, layout, col);
         Layout.Element[] res = new Layout.Element[col.size()];
         col.toArray(res);
@@ -903,7 +903,7 @@
             case 'T': // union: 'T' any_int union_case* '(' ')' '[' body ']'
                 kind = EK_UN;
                 i = tokenizeSInt(e, layout, i);
-                List<Layout.Element> cases = new ArrayList<>();
+                List<Layout.Element> cases = new ArrayList<Layout.Element>();
                 for (;;) {
                     // Keep parsing cases until we hit the default case.
                     if (layout.charAt(i++) != '(')
@@ -1057,7 +1057,7 @@
     }
     static //private
     String[] splitBodies(String layout) {
-        List<String> bodies = new ArrayList<>();
+        List<String> bodies = new ArrayList<String>();
         // Parse several independent layout bodies:  "[foo][bar]...[baz]"
         for (int i = 0; i < layout.length(); i++) {
             if (layout.charAt(i++) != '[')
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java	2011-07-12 16:56:06.702259970 +0100
@@ -257,7 +257,7 @@
         assert(basicCodings[_meta_default] == null);
         assert(basicCodings[_meta_canon_min] != null);
         assert(basicCodings[_meta_canon_max] != null);
-        Map<Coding, Integer> map = new HashMap<>();
+        Map<Coding, Integer> map = new HashMap<Coding, Integer>();
         for (int i = 0; i < basicCodings.length; i++) {
             Coding c = basicCodings[i];
             if (c == null)  continue;
@@ -1068,8 +1068,8 @@
 
     // Bootstrap support for CPRefBands.  These are needed to record
     // intended CP indexes, before the CP has been created.
-    private final List<CPRefBand> allKQBands = new ArrayList<>();
-    private List<Object[]> needPredefIndex = new ArrayList<>();
+    private final List<CPRefBand> allKQBands = new ArrayList<CPRefBand>();
+    private List<Object[]> needPredefIndex = new ArrayList<Object[]>();
 
 
     int encodeRef(Entry e, Index ix) {
@@ -1704,7 +1704,7 @@
     protected int attrClassFileVersionMask;
 
     // Mapping from Attribute.Layout to Band[] (layout element bands).
-    protected Map<Attribute.Layout, Band[]> attrBandTable = new HashMap<>();
+    protected Map<Attribute.Layout, Band[]> attrBandTable = new HashMap<Attribute.Layout, Band[]>();
 
     // Well-known attributes:
     protected final Attribute.Layout attrCodeEmpty;
@@ -1713,11 +1713,11 @@
     protected final Attribute.Layout attrConstantValue;
 
     // Mapping from Attribute.Layout to Integer (inverse of attrDefs)
-    Map<Attribute.Layout, Integer> attrIndexTable = new HashMap<>();
+    Map<Attribute.Layout, Integer> attrIndexTable = new HashMap<Attribute.Layout, Integer>();
 
     // Mapping from attribute index (<32 are flag bits) to attributes.
     protected List<List<Attribute.Layout>> attrDefs =
-            new FixedList<>(ATTR_CONTEXT_LIMIT);
+            new FixedList<List<Attribute.Layout>>(ATTR_CONTEXT_LIMIT);
     {
         for (int i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
             assert(attrIndexLimit[i] == 0);
@@ -1912,7 +1912,7 @@
 
     protected List getPredefinedAttrs(int ctype) {
         assert(attrIndexLimit[ctype] != 0);
-        List<Attribute.Layout> res = new ArrayList<>(attrIndexLimit[ctype]);
+        List<Attribute.Layout> res = new ArrayList<Attribute.Layout>(attrIndexLimit[ctype]);
         // Remove nulls and non-predefs.
         for (int ai = 0; ai < attrIndexLimit[ctype]; ai++) {
             if (testBit(attrDefSeen[ctype], 1L<<ai))  continue;
@@ -2536,7 +2536,7 @@
     // DEBUG ONLY:  Record something about the band order.
     boolean notePrevForAssert(Band b, Band p) {
         if (prevForAssertMap == null)
-            prevForAssertMap = new HashMap<>();
+            prevForAssertMap = new HashMap<Band, Band>();
         prevForAssertMap.put(b, p);
         return true;
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/ClassReader.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/ClassReader.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/ClassReader.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/ClassReader.java	2011-07-12 16:56:06.702259970 +0100
@@ -466,7 +466,7 @@
 
     void readInnerClasses(Class cls) throws IOException {
         int nc = readUnsignedShort();
-        ArrayList<InnerClass> ics = new ArrayList<>(nc);
+        ArrayList<InnerClass> ics = new ArrayList<InnerClass>(nc);
         for (int i = 0; i < nc; i++) {
             InnerClass ic =
                 new InnerClass(readClassRef(),
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/CodingChooser.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/CodingChooser.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/CodingChooser.java	2011-04-14 01:29:58.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/CodingChooser.java	2011-07-12 16:56:06.702259970 +0100
@@ -743,9 +743,9 @@
         // Steps 1/2/3 are interdependent, and may be iterated.
         // Steps 4 and 5 may be decided independently afterward.
         int[] LValuesCoded = PopulationCoding.LValuesCoded;
-        List<Coding> bestFits = new ArrayList<>();
-        List<Coding> fullFits = new ArrayList<>();
-        List<Coding> longFits = new ArrayList<>();
+        List<Coding> bestFits = new ArrayList<Coding>();
+        List<Coding> fullFits = new ArrayList<Coding>();
+        List<Coding> longFits = new ArrayList<Coding>();
         final int PACK_TO_MAX_S = 1;
         if (bestPopFVC <= 255) {
             bestFits.add(BandStructure.BYTE1);
@@ -785,7 +785,7 @@
                 }
             }
         }
-        List<Coding> allFits = new ArrayList<>();
+        List<Coding> allFits = new ArrayList<Coding>();
         for (Iterator<Coding> i = bestFits.iterator(),
                       j = fullFits.iterator(),
                       k = longFits.iterator();
@@ -1230,10 +1230,10 @@
         Histogram hist = getValueHistogram();
         int fVlen = stressLen(hist.getTotalLength());
         if (fVlen == 0)  return coding;
-        List<Integer> popvals = new ArrayList<>();
+        List<Integer> popvals = new ArrayList<Integer>();
         if (stress.nextBoolean()) {
             // Build the population from the value list.
-            Set<Integer> popset = new HashSet<>();
+            Set<Integer> popset = new HashSet<Integer>();
             for (int i = start; i < end; i++) {
                 if (popset.add(values[i]))  popvals.add(values[i]);
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Coding.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Coding.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Coding.java	2011-04-14 01:29:58.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Coding.java	2011-07-12 16:56:06.702259970 +0100
@@ -402,7 +402,7 @@
     private static Map<Coding, Coding> codeMap;
 
     private static synchronized Coding of(int B, int H, int S, int del) {
-        if (codeMap == null)  codeMap = new HashMap<>();
+        if (codeMap == null)  codeMap = new HashMap<Coding, Coding>();
         Coding x0 = new Coding(B, H, S, del);
         Coding x1 = codeMap.get(x0);
         if (x1 == null)  codeMap.put(x0, x1 = x0);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java	2011-04-14 01:29:58.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java	2011-07-12 16:56:06.702259970 +0100
@@ -919,7 +919,7 @@
     public static
     Index[] partition(Index ix, int[] keys) {
         // %%% Should move this into class Index.
-        List<List<Entry>> parts = new ArrayList<>();
+        List<List<Entry>> parts = new ArrayList<List<Entry>>();
         Entry[] cpMap = ix.cpMap;
         assert(keys.length == cpMap.length);
         for (int i = 0; i < keys.length; i++) {
@@ -930,7 +930,7 @@
             }
             List<Entry> part = parts.get(key);
             if (part == null) {
-                parts.set(key, part = new ArrayList<>());
+                parts.set(key, part = new ArrayList<Entry>());
             }
             part.add(cpMap[i]);
         }
@@ -1137,7 +1137,7 @@
     void completeReferencesIn(Set<Entry> cpRefs, boolean flattenSigs) {
         cpRefs.remove(null);
         for (ListIterator<Entry> work =
-                 new ArrayList<>(cpRefs).listIterator(cpRefs.size());
+                 new ArrayList<Entry>(cpRefs).listIterator(cpRefs.size());
              work.hasPrevious(); ) {
             Entry e = work.previous();
             work.remove();          // pop stack
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Driver.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Driver.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Driver.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Driver.java	2011-07-12 16:56:06.702259970 +0100
@@ -59,7 +59,7 @@
                 ResourceBundle.getBundle("com.sun.java.util.jar.pack.DriverResource");
 
     public static void main(String[] ava) throws IOException {
-        List<String> av = new ArrayList<>(Arrays.asList(ava));
+        List<String> av = new ArrayList<String>(Arrays.asList(ava));
 
         boolean doPack   = true;
         boolean doUnpack = false;
@@ -82,7 +82,7 @@
         }
 
         // Collect engine properties here:
-        Map<String,String> engProps = new HashMap<>();
+        Map<String,String> engProps = new HashMap<String, String>();
         engProps.put(verboseProp, System.getProperty(verboseProp));
 
         String optionMap;
@@ -96,7 +96,7 @@
         }
 
         // Collect argument properties here:
-        Map<String,String> avProps = new HashMap<>();
+        Map<String,String> avProps = new HashMap<String, String>();
         try {
             for (;;) {
                 String state = parseCommandOptions(av, optionMap, avProps);
@@ -530,7 +530,7 @@
         String resultString = null;
 
         // Convert options string into optLines dictionary.
-        TreeMap<String,String[]> optmap = new TreeMap<>();
+        TreeMap<String,String[]> optmap = new TreeMap<String,String[]>();
     loadOptmap:
         for (String optline : options.split("\n")) {
             String[] words = optline.split("\\p{Space}+");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/FixedList.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/FixedList.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/FixedList.java	2011-04-14 01:29:58.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/FixedList.java	2011-07-12 16:56:06.702259970 +0100
@@ -45,7 +45,7 @@
     private final ArrayList<E> flist;
 
     protected FixedList(int capacity) {
-        flist = new ArrayList<>(capacity);
+        flist = new ArrayList<E>(capacity);
         // initialize the list to null
         for (int i = 0 ; i < capacity ; i++) {
             flist.add(null);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Package.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Package.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Package.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Package.java	2011-07-12 16:56:06.702259970 +0100
@@ -112,7 +112,7 @@
     public static final Attribute.Layout attrSourceFileSpecial;
     public static final Map<Attribute.Layout, Attribute> attrDefs;
     static {
-        Map<Layout, Attribute> ad = new HashMap<>(3);
+        Map<Layout, Attribute> ad = new HashMap<Layout, Attribute>(3);
         attrCodeEmpty = Attribute.define(ad, ATTR_CONTEXT_METHOD,
                                          "Code", "").layout();
         attrInnerClassesEmpty = Attribute.define(ad, ATTR_CONTEXT_CLASS,
@@ -181,7 +181,7 @@
         }
     }
 
-    ArrayList<Package.Class> classes = new ArrayList<>();
+    ArrayList<Package.Class> classes = new ArrayList<Package.Class>();
 
     public List<Package.Class> getClasses() {
         return classes;
@@ -264,7 +264,7 @@
             if (olda == null)
                 return;  // no SourceFile attr.
             String obvious = getObviousSourceFile();
-            List<Entry> ref = new ArrayList<>(1);
+            List<Entry> ref = new ArrayList<Entry>(1);
             olda.visitRefs(this, VRM_PACKAGE, ref);
             Utf8Entry sfName = (Utf8Entry) ref.get(0);
             Attribute a = olda;
@@ -292,7 +292,7 @@
             if (a != olda) {
                 if (verbose > 2)
                     Utils.log.fine("recoding obvious SourceFile="+obvious);
-                List<Attribute> newAttrs = new ArrayList<>(getAttributes());
+                List<Attribute> newAttrs = new ArrayList<Attribute>(getAttributes());
                 int where = newAttrs.indexOf(olda);
                 newAttrs.set(where, a);
                 setAttributes(newAttrs);
@@ -322,7 +322,7 @@
         }
 
         public void setInnerClasses(Collection<InnerClass> ics) {
-            innerClasses = (ics == null) ? null : new ArrayList<>(ics);
+            innerClasses = (ics == null) ? null : new ArrayList<InnerClass>(ics);
             // Edit the attribute list, if necessary.
             Attribute a = getAttribute(attrInnerClassesEmpty);
             if (innerClasses != null && a == null)
@@ -341,7 +341,7 @@
          *  with that of Package.this.allInnerClasses.
          */
         public List<InnerClass> computeGloballyImpliedICs() {
-            Set<Entry> cpRefs = new HashSet<>();
+            Set<Entry> cpRefs = new HashSet<Entry>();
             {   // This block temporarily displaces this.innerClasses.
                 ArrayList<InnerClass> innerClassesSaved = innerClasses;
                 innerClasses = null;  // ignore for the moment
@@ -350,7 +350,7 @@
             }
             ConstantPool.completeReferencesIn(cpRefs, true);
 
-            Set<Entry> icRefs = new HashSet<>();
+            Set<Entry> icRefs = new HashSet<Entry>();
             for (Entry e : cpRefs) {
                 // Restrict cpRefs to InnerClasses entries only.
                 if (!(e instanceof ClassEntry))  continue;
@@ -366,7 +366,7 @@
             // This loop is structured this way so as to accumulate
             // entries into impliedICs in an order which reflects
             // the order of allInnerClasses.
-            ArrayList<InnerClass> impliedICs = new ArrayList<>();
+            ArrayList<InnerClass> impliedICs = new ArrayList<InnerClass>();
             for (InnerClass ic : allInnerClasses) {
                 // This one is locally relevant if it describes
                 // a member of the current class, or if the current
@@ -409,8 +409,8 @@
                 // Diff is A since I is empty.
             }
             // (I*A) is non-trivial
-            Set<InnerClass> center = new HashSet<>(actualICs);
-            center.retainAll(new HashSet<>(impliedICs));
+            Set<InnerClass> center = new HashSet<InnerClass>(actualICs);
+            center.retainAll(new HashSet<InnerClass>(impliedICs));
             impliedICs.addAll(actualICs);
             impliedICs.removeAll(center);
             // Diff is now I^A = (I+A)-(I*A).
@@ -539,7 +539,7 @@
                 super(flags, descriptor);
                 assert(!descriptor.isMethod());
                 if (fields == null)
-                    fields = new ArrayList<>();
+                    fields = new ArrayList<Field>();
                 boolean added = fields.add(this);
                 assert(added);
                 order = fields.size();
@@ -564,7 +564,7 @@
                 super(flags, descriptor);
                 assert(descriptor.isMethod());
                 if (methods == null)
-                    methods = new ArrayList<>();
+                    methods = new ArrayList<Method>();
                 boolean added = methods.add(this);
                 assert(added);
             }
@@ -732,14 +732,14 @@
     }
 
     // What non-class files are in this unit?
-    ArrayList<File> files = new ArrayList<>();
+    ArrayList<File> files = new ArrayList<File>();
 
     public List<File> getFiles() {
         return files;
     }
 
     public List<File> getClassStubs() {
-        List<File> classStubs = new ArrayList<>(classes.size());
+        List<File> classStubs = new ArrayList<File>(classes.size());
         for (Class cls : classes) {
             assert(cls.file.isClassStub());
             classStubs.add(cls.file);
@@ -859,7 +859,7 @@
         public InputStream getInputStream() {
             InputStream in = new ByteArrayInputStream(append.toByteArray());
             if (prepend.isEmpty())  return in;
-            List<InputStream> isa = new ArrayList<>(prepend.size()+1);
+            List<InputStream> isa = new ArrayList<InputStream>(prepend.size()+1);
             for (Iterator i = prepend.iterator(); i.hasNext(); ) {
                 byte[] bytes = (byte[]) i.next();
                 isa.add(new ByteArrayInputStream(bytes));
@@ -896,7 +896,7 @@
     }
 
     // Is there a globally declared table of inner classes?
-    List<InnerClass> allInnerClasses = new ArrayList<>();
+    List<InnerClass> allInnerClasses = new ArrayList<InnerClass>();
     Map<ClassEntry, InnerClass>   allInnerClassesByThis;
 
     public
@@ -911,7 +911,7 @@
         allInnerClasses.addAll(ics);
 
         // Make an index:
-        allInnerClassesByThis = new HashMap<>(allInnerClasses.size());
+        allInnerClassesByThis = new HashMap<ClassEntry,InnerClass>(allInnerClasses.size());
         for (InnerClass ic : allInnerClasses) {
             Object pic = allInnerClassesByThis.put(ic.thisClass, ic);
             assert(pic == null);  // caller must ensure key uniqueness!
@@ -1302,7 +1302,7 @@
 
     // Use this before writing the class files.
     void ensureAllClassFiles() {
-        Set<File> fileSet = new HashSet<>(files);
+        Set<File> fileSet = new HashSet<File>(files);
         for (Class cls : classes) {
             // Add to the end of ths list:
             if (!fileSet.contains(cls.file))
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageReader.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageReader.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageReader.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageReader.java	2011-07-12 16:56:06.702259970 +0100
@@ -686,7 +686,7 @@
         cp_Signature_classes.expectLength(getIntTotal(numSigClasses));
         cp_Signature_classes.readFrom(in);
         cp_Signature_classes.setIndex(getCPIndex(CONSTANT_Class));
-        utf8Signatures = new HashMap<>();
+        utf8Signatures = new HashMap<Utf8Entry, SignatureEntry>();
         for (int i = 0; i < cpMap.length; i++) {
             Utf8Entry formRef = (Utf8Entry) cp_Signature_form.getRef();
             ClassEntry[] classRefs = new ClassEntry[numSigClasses[i]];
@@ -892,7 +892,7 @@
         ic_name.expectLength(longICCount);
         ic_name.readFrom(in);
         ic_flags.resetForSecondPass();
-        List<InnerClass> icList = new ArrayList<>(numInnerClasses);
+        List<InnerClass> icList = new ArrayList<InnerClass>(numInnerClasses);
         for (int i = 0; i < numInnerClasses; i++) {
             int flags = ic_flags.getInt();
             boolean longForm = (flags & ACC_IC_LONG_FORM) != 0;
@@ -934,7 +934,7 @@
 
     void readLocalInnerClasses(Class cls) throws IOException {
         int nc = class_InnerClasses_N.getInt();
-        List<InnerClass> localICs = new ArrayList<>(nc);
+        List<InnerClass> localICs = new ArrayList<InnerClass>(nc);
         for (int i = 0; i < nc; i++) {
             ClassEntry thisClass = (ClassEntry) class_InnerClasses_RC.getRef();
             int        flags     =              class_InnerClasses_F.getInt();
@@ -1062,7 +1062,7 @@
 
     Entry[] reconstructLocalCPMap(Class cls) {
         Set<Entry> ldcRefs = ldcRefMap.get(cls);
-        Set<Entry> cpRefs = new HashSet<>();
+        Set<Entry> cpRefs = new HashSet<Entry>();
 
         // look for constant pool entries:
         cls.visitRefs(VRM_CLASSIC, cpRefs);
@@ -1167,7 +1167,7 @@
         method_descr.expectLength(totalNM);
         if (verbose > 1)  Utils.log.fine("expecting #fields="+totalNF+" and #methods="+totalNM+" in #classes="+numClasses);
 
-        List<Class.Field> fields = new ArrayList<>(totalNF);
+        List<Class.Field> fields = new ArrayList<Class.Field>(totalNF);
         field_descr.readFrom(in);
         for (int i = 0; i < classes.length; i++) {
             Class c = classes[i];
@@ -1183,7 +1183,7 @@
         countAndReadAttrs(ATTR_CONTEXT_FIELD, fields);
         fields = null;  // release to GC
 
-        List<Class.Method> methods = new ArrayList<>(totalNM);
+        List<Class.Method> methods = new ArrayList<Class.Method>(totalNM);
         method_descr.readFrom(in);
         for (int i = 0; i < classes.length; i++) {
             Class c = classes[i];
@@ -1206,10 +1206,10 @@
 
     Code[] allCodes;
     List<Code> codesWithFlags;
-    Map<Class, Set<Entry>> ldcRefMap = new HashMap<>();
+    Map<Class, Set<Entry>> ldcRefMap = new HashMap<Class, Set<Entry>>();
 
     Code[] buildCodeAttrs(List<Class.Method> methods) {
-        List<Code> codes = new ArrayList<>(methods.size());
+        List<Code> codes = new ArrayList<Code>(methods.size());
         for (Class.Method m : methods) {
             if (m.getAttribute(attrCodeEmpty) != null) {
                 m.code = new Code(m);
@@ -1233,7 +1233,7 @@
         boolean attrsOK = testBit(archiveOptions, AO_HAVE_ALL_CODE_FLAGS);
         code_headers.expectLength(allCodes.length);
         code_headers.readFrom(in);
-        List<Code> longCodes = new ArrayList<>(allCodes.length / 10);
+        List<Code> longCodes = new ArrayList<Code>(allCodes.length / 10);
         for (int i = 0; i < allCodes.length; i++) {
             Code c = allCodes[i];
             int sc = code_headers.getByte();
@@ -1472,7 +1472,7 @@
                 bits -= (1L<<ai);
                 nfa += 1;
             }
-            List<Attribute> ha = new ArrayList<>(nfa + noa);
+            List<Attribute> ha = new ArrayList<Attribute>(nfa + noa);
             h.attributes = ha;
             bits = attrBits;  // iterate again
             for (int ai = 0; bits != 0; ai++) {
@@ -1596,7 +1596,7 @@
     @SuppressWarnings("unchecked")
     void readAttrs(int ctype, Collection holders) throws IOException {
         // Decode band values into attributes.
-        Set<Attribute.Layout> sawDefs = new HashSet<>();
+        Set<Attribute.Layout> sawDefs = new HashSet<Attribute.Layout>();
         ByteArrayOutputStream buf = new ByteArrayOutputStream();
         for (Iterator i = holders.iterator(); i.hasNext(); ) {
             final Attribute.Holder h = (Attribute.Holder) i.next();
@@ -1800,7 +1800,7 @@
         // scratch buffer for collecting code::
         byte[] buf = new byte[1<<12];
         // record of all switch opcodes (these are variable-length)
-        List<Integer> allSwitchOps = new ArrayList<>();
+        List<Integer> allSwitchOps = new ArrayList<Integer>();
         for (int k = 0; k < allCodes.length; k++) {
             Code c = allCodes[k];
         scanOneMethod:
@@ -1916,7 +1916,7 @@
 
             Set<Entry> ldcRefSet = ldcRefMap.get(curClass);
             if (ldcRefSet == null)
-                ldcRefMap.put(curClass, ldcRefSet = new HashSet<>());
+                ldcRefMap.put(curClass, ldcRefSet = new HashSet<Entry>());
 
             ClassEntry thisClass  = curClass.thisClass;
             ClassEntry superClass = curClass.superClass;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageWriter.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageWriter.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageWriter.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageWriter.java	2011-07-12 16:56:06.706260036 +0100
@@ -116,7 +116,7 @@
     int[][]     attrCounts;       // count attr. occurences
 
     void setup() {
-        requiredEntries = new HashSet<>();
+        requiredEntries = new HashSet<Entry>();
         setArchiveOptions();
         trimClassAttributes();
         collectAttributeLayouts();
@@ -176,7 +176,7 @@
             }
         }
         // Decide on default version number (majority rule).
-        Map<Integer, int[]> verCounts = new HashMap<>();
+        Map<Integer, int[]> verCounts = new HashMap<Integer, int[]>();
         int bestCount = 0;
         int bestVersion = -1;
         for (Class cls : pkg.classes) {
@@ -729,7 +729,7 @@
     @SuppressWarnings("unchecked")
     void collectAttributeLayouts() {
         maxFlags = new int[ATTR_CONTEXT_LIMIT];
-        allLayouts = new FixedList<>(ATTR_CONTEXT_LIMIT);
+        allLayouts = new FixedList<Map<Attribute.Layout,int[]>>(ATTR_CONTEXT_LIMIT);
         for (int i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
             allLayouts.set(i, new HashMap<Attribute.Layout, int[]>());
         }
@@ -774,7 +774,7 @@
         }
         // Collect counts for both predefs. and custom defs.
         // Decide on custom, local attribute definitions.
-        backCountTable = new HashMap<>();
+        backCountTable = new HashMap<Attribute.Layout, int[]>();
         attrCounts = new int[ATTR_CONTEXT_LIMIT][];
         for (int i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
             // Now the remaining defs in allLayouts[i] need attr. indexes.
@@ -889,7 +889,7 @@
 
     @SuppressWarnings("unchecked")
     void writeAttrDefs() throws IOException {
-        List<Object[]> defList = new ArrayList<>();
+        List<Object[]> defList = new ArrayList<Object[]>();
         for (int i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
             int limit = attrDefs.get(i).size();
             for (int j = 0; j < limit; j++) {
@@ -1007,7 +1007,7 @@
     void collectInnerClasses() {
         // Capture inner classes, removing them from individual classes.
         // Irregular inner classes must stay local, though.
-        Map<ClassEntry, InnerClass> allICMap = new HashMap<>();
+        Map<ClassEntry, InnerClass> allICMap = new HashMap<ClassEntry, InnerClass>();
         // First, collect a consistent global set.
         for (Class cls : pkg.classes) {
             if (!cls.hasInnerClasses())  continue;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java	2011-04-14 01:29:58.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java	2011-07-12 16:56:06.710260102 +0100
@@ -183,8 +183,8 @@
         final Map<Attribute.Layout, Attribute> attrDefs;
         final Map<Attribute.Layout, String> attrCommands;
         {
-            Map<Attribute.Layout, Attribute> lattrDefs   = new HashMap<>();
-            Map<Attribute.Layout, String>  lattrCommands = new HashMap<>();
+            Map<Attribute.Layout, Attribute> lattrDefs   = new HashMap<Attribute.Layout, Attribute>();
+            Map<Attribute.Layout, String>  lattrCommands = new HashMap<Attribute.Layout, String>();
             String[] keys = {
                 Pack200.Packer.CLASS_ATTRIBUTE_PFX,
                 Pack200.Packer.FIELD_ATTRIBUTE_PFX,
@@ -593,7 +593,7 @@
                 assert(pkg.files.containsAll(pkg.getClassStubs()));
                 // Order of stubs in file list must agree with classes.
                 List<Package.File> res = pkg.files;
-                assert((res = new ArrayList<>(pkg.files))
+                assert((res = new ArrayList<Package.File>(pkg.files))
                        .retainAll(pkg.getClassStubs()) || true);
                 assert(res.equals(pkg.getClassStubs()));
             }
@@ -626,7 +626,7 @@
 
         List<InFile> scanJar(JarFile jf) throws IOException {
             // Collect jar entries, preserving order.
-            List<InFile> inFiles = new ArrayList<>();
+            List<InFile> inFiles = new ArrayList<InFile>();
             try {
                 for (JarEntry je : Collections.list(jf.entries())) {
                     InFile inFile = new InFile(jf, je);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PopulationCoding.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PopulationCoding.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PopulationCoding.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PopulationCoding.java	2011-07-12 16:56:06.714260168 +0100
@@ -309,7 +309,7 @@
         // As each new value is added, we assert that the value
         // was not already in the set.
         Set<Integer> uniqueValuesForDebug = null;
-        assert((uniqueValuesForDebug = new HashSet<>()) != null);
+        assert((uniqueValuesForDebug = new HashSet<Integer>()) != null);
         int fillp = 1;
         maxForDebug += fillp;
         int min = Integer.MIN_VALUE;  // farthest from the center
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PropMap.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PropMap.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PropMap.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PropMap.java	2011-07-12 16:56:06.714260168 +0100
@@ -48,8 +48,8 @@
  */
 
 final class PropMap implements SortedMap<Object, Object>  {
-    private final TreeMap<Object, Object> theMap = new TreeMap<>();;
-    private final List<PropertyChangeListener> listenerList = new ArrayList<>(1);
+    private final TreeMap<Object, Object> theMap = new TreeMap<Object, Object>();;
+    private final List<PropertyChangeListener> listenerList = new ArrayList<PropertyChangeListener>(1);
 
     void addListener(PropertyChangeListener listener) {
         listenerList.add(listener);
@@ -150,7 +150,7 @@
             }
         }
 
-        defaultProps = (new HashMap<>(props));  // shrink to fit
+        defaultProps = (new HashMap<Object, Object>(props));  // shrink to fit
     }
 
     PropMap() {
@@ -186,7 +186,7 @@
     // Get sequence of props for "prefix", and "prefix.*".
     List getProperties(String prefix) {
         Collection<Object> values = prefixMap(prefix).values();
-        List<Object> res = new ArrayList<>(values.size());
+        List<Object> res = new ArrayList<Object>(values.size());
         res.addAll(values);
         while (res.remove(null));
         return res;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/TLGlobals.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/TLGlobals.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/TLGlobals.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/TLGlobals.java	2011-07-12 16:56:06.714260168 +0100
@@ -58,12 +58,12 @@
     private final Map<String, MemberEntry> memberEntries;
 
     TLGlobals() {
-        utf8Entries = new HashMap<>();
-        classEntries = new HashMap<>();
-        literalEntries = new HashMap<>();
-        signatureEntries = new HashMap<>();
-        descriptorEntries = new HashMap<>();
-        memberEntries = new HashMap<>();
+        utf8Entries = new HashMap<String,Utf8Entry>();
+        classEntries = new HashMap<String,ClassEntry>();
+        literalEntries = new HashMap<Object,LiteralEntry>();
+        signatureEntries = new HashMap<String,SignatureEntry>();
+        descriptorEntries = new HashMap<String,DescriptorEntry>();
+        memberEntries = new HashMap<String,MemberEntry>();
         props = new PropMap();
     }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java	2011-07-12 16:56:06.714260168 +0100
@@ -233,7 +233,7 @@
             props.setProperty(java.util.jar.Pack200.Unpacker.PROGRESS,"50");
             pkg.ensureAllClassFiles();
             // Now write out the files.
-            Set<Package.Class> classesToWrite = new HashSet<>(pkg.getClasses());
+            Set<Package.Class> classesToWrite = new HashSet<Package.Class>(pkg.getClasses());
             for (Package.File file : pkg.getFiles()) {
                 String name = file.nameString;
                 JarEntry je = new JarEntry(Utils.getJarEntryName(name));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Utils.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Utils.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Utils.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Utils.java	2011-07-12 16:56:06.714260168 +0100
@@ -132,7 +132,7 @@
     // Keep a TLS point to the global data and environment.
     // This makes it simpler to supply environmental options
     // to the engine code, especially the native code.
-    static final ThreadLocal<TLGlobals> currentInstance = new ThreadLocal<>();
+    static final ThreadLocal<TLGlobals> currentInstance = new ThreadLocal<TLGlobals>();
 
     // convenience methods to access the TL globals
     static TLGlobals getTLGlobals() {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/DnsContextFactory.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/DnsContextFactory.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/DnsContextFactory.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/DnsContextFactory.java	2011-07-12 16:56:06.714260168 +0100
@@ -135,7 +135,7 @@
             throw new ConfigurationException("DNS pseudo-URL required");
         }
 
-        List<String> servers = new ArrayList<>();
+        List<String> servers = new ArrayList<String>();
 
         for (int i = 0; i < urls.length; i++) {
             String server = urls[i].getHost();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java openjdk-boot/jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java	2011-07-12 16:56:06.822261957 +0100
@@ -1284,7 +1284,7 @@
      */
     public Collection<?> toCollection() throws SQLException {
 
-        TreeMap<Integer, Object> tMap = new TreeMap<>();
+        TreeMap<Integer, Object> tMap = new TreeMap<Integer, Object>();
 
         for (int i = 0; i<numRows; i++) {
             tMap.put(Integer.valueOf(i), rvh.get(i));
@@ -1314,7 +1314,7 @@
     public Collection<?> toCollection(int column) throws SQLException {
 
         int nRows = numRows;
-        Vector<Object> vec = new Vector<>(nRows);
+        Vector<Object> vec = new Vector<Object>(nRows);
 
         // create a copy
         CachedRowSetImpl crsTemp;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/rowset/JoinRowSetImpl.java openjdk-boot/jdk/src/share/classes/com/sun/rowset/JoinRowSetImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/rowset/JoinRowSetImpl.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/rowset/JoinRowSetImpl.java	2011-07-12 16:56:06.866262683 +0100
@@ -222,7 +222,7 @@
            // either of the setter methods have been set.
            if(boolColId){
               //
-              ArrayList<Integer> indices = new ArrayList<>();
+              ArrayList<Integer> indices = new ArrayList<Integer>();
               for(int i=0;i<cRowset.getMatchColumnNames().length;i++) {
                   if( (strMatchKey = (cRowset.getMatchColumnNames())[i]) != null) {
                       iMatchKey = cRowset.findColumn(strMatchKey);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/callback/DialogCallbackHandler.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/callback/DialogCallbackHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/callback/DialogCallbackHandler.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/callback/DialogCallbackHandler.java	2011-07-12 16:56:06.714260168 +0100
@@ -99,10 +99,10 @@
         throws UnsupportedCallbackException
     {
         /* Collect messages to display in the dialog */
-        final List<Object> messages = new ArrayList<>(3);
+        final List<Object> messages = new ArrayList<Object>(3);
 
         /* Collection actions to perform if the user clicks OK */
-        final List<Action> okActions = new ArrayList<>(2);
+        final List<Action> okActions = new ArrayList<Action>(2);
 
         ConfirmationInfo confirmation = new ConfirmationInfo();
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/login/ConfigFile.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/login/ConfigFile.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/login/ConfigFile.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/login/ConfigFile.java	2011-07-12 16:56:06.714260168 +0100
@@ -152,7 +152,7 @@
 
         // new configuration
         HashMap<String, LinkedList<AppConfigurationEntry>> newConfig =
-                new HashMap<>();
+            new HashMap<String, LinkedList<AppConfigurationEntry>>();
 
         if (url != null) {
 
@@ -392,7 +392,7 @@
         String moduleClass;
         String sflag;
         AppConfigurationEntry.LoginModuleControlFlag controlFlag;
-        LinkedList<AppConfigurationEntry> configEntries = new LinkedList<>();
+        LinkedList<AppConfigurationEntry> configEntries = new LinkedList<AppConfigurationEntry>();
 
         // application name
         appName = st.sval;
@@ -432,7 +432,7 @@
             }
 
             // get the args
-            HashMap<String, String> options = new HashMap<>();
+            HashMap<String, String> options = new HashMap<String, String>();
             String key;
             String value;
             while (peek(";") == false) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/JndiLoginModule.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/JndiLoginModule.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/JndiLoginModule.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/JndiLoginModule.java	2011-07-12 16:56:06.714260168 +0100
@@ -184,7 +184,7 @@
     private UnixNumericUserPrincipal UIDPrincipal;
     private UnixNumericGroupPrincipal GIDPrincipal;
     private LinkedList<UnixNumericGroupPrincipal> supplementaryGroups =
-                                new LinkedList<>();
+                                new LinkedList<UnixNumericGroupPrincipal>();
 
     // initial state
     private Subject subject;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java	2011-07-12 16:56:06.714260168 +0100
@@ -658,7 +658,7 @@
                 throw new FailedLoginException(
                     "Unable to find X.509 certificate chain in keystore");
             } else {
-                LinkedList<Certificate> certList = new LinkedList<>();
+                LinkedList<Certificate> certList = new LinkedList<Certificate>();
                 for (int i=0; i < fromKeyStore.length; i++) {
                     certList.add(fromKeyStore[i]);
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/SolarisLoginModule.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/SolarisLoginModule.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/SolarisLoginModule.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/SolarisLoginModule.java	2011-07-12 16:56:06.714260168 +0100
@@ -76,7 +76,7 @@
     private SolarisNumericUserPrincipal UIDPrincipal;
     private SolarisNumericGroupPrincipal GIDPrincipal;
     private LinkedList<SolarisNumericGroupPrincipal> supplementaryGroups =
-                new LinkedList<>();
+                new LinkedList<SolarisNumericGroupPrincipal>();
 
     /**
      * Initialize this <code>LoginModule</code>.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/UnixLoginModule.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/UnixLoginModule.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/UnixLoginModule.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/UnixLoginModule.java	2011-07-12 16:56:06.714260168 +0100
@@ -70,7 +70,7 @@
     private UnixNumericUserPrincipal UIDPrincipal;
     private UnixNumericGroupPrincipal GIDPrincipal;
     private LinkedList<UnixNumericGroupPrincipal> supplementaryGroups =
-                new LinkedList<>();
+                new LinkedList<UnixNumericGroupPrincipal>();
 
     /**
      * Initialize this <code>LoginModule</code>.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/PolicyFile.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/PolicyFile.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/PolicyFile.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/PolicyFile.java	2011-07-12 16:56:06.714260168 +0100
@@ -1180,7 +1180,7 @@
             // Done
             return certs;
 
-        ArrayList<Certificate> userCertList = new ArrayList<>();
+        ArrayList<Certificate> userCertList = new ArrayList<Certificate>();
         i = 0;
         while (i < certs.length) {
             userCertList.add(certs[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/DeleteOnExitHook.java openjdk-boot/jdk/src/share/classes/java/io/DeleteOnExitHook.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/DeleteOnExitHook.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/DeleteOnExitHook.java	2011-07-12 16:56:06.714260168 +0100
@@ -34,7 +34,7 @@
  */
 
 class DeleteOnExitHook {
-    private static LinkedHashSet<String> files = new LinkedHashSet<>();
+    private static LinkedHashSet<String> files = new LinkedHashSet<String>();
     static {
         // DeleteOnExitHook must be the last shutdown hook to be invoked.
         // Application shutdown hooks may add the first file to the
@@ -71,7 +71,7 @@
             files = null;
         }
 
-        ArrayList<String> toBeDeleted = new ArrayList<>(theFiles);
+        ArrayList<String> toBeDeleted = new ArrayList<String>(theFiles);
 
         // reverse the list to maintain previous jdk deletion order.
         // Last in first deleted.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/FileInputStream.java openjdk-boot/jdk/src/share/classes/java/io/FileInputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/FileInputStream.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/FileInputStream.java	2011-07-12 16:56:06.714260168 +0100
@@ -57,7 +57,7 @@
     private volatile boolean closed = false;
 
     private static final ThreadLocal<Boolean> runningFinalize =
-        new ThreadLocal<>();
+        new ThreadLocal<Boolean>();
 
     private static boolean isRunningFinalize() {
         Boolean val;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/File.java openjdk-boot/jdk/src/share/classes/java/io/File.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/File.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/File.java	2011-07-12 16:56:06.714260168 +0100
@@ -1082,7 +1082,7 @@
         if ((names == null) || (filter == null)) {
             return names;
         }
-        List<String> v = new ArrayList<>();
+        List<String> v = new ArrayList<String>();
         for (int i = 0 ; i < names.length ; i++) {
             if (filter.accept(this, names[i])) {
                 v.add(names[i]);
@@ -1173,7 +1173,7 @@
     public File[] listFiles(FilenameFilter filter) {
         String ss[] = list();
         if (ss == null) return null;
-        ArrayList<File> files = new ArrayList<>();
+        ArrayList<File> files = new ArrayList<File>();
         for (String s : ss)
             if ((filter == null) || filter.accept(this, s))
                 files.add(new File(s, this));
@@ -1211,7 +1211,7 @@
     public File[] listFiles(FileFilter filter) {
         String ss[] = list();
         if (ss == null) return null;
-        ArrayList<File> files = new ArrayList<>();
+        ArrayList<File> files = new ArrayList<File>();
         for (String s : ss) {
             File f = new File(s, this);
             if ((filter == null) || filter.accept(f))
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/FileOutputStream.java openjdk-boot/jdk/src/share/classes/java/io/FileOutputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/FileOutputStream.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/FileOutputStream.java	2011-07-12 16:56:06.714260168 +0100
@@ -70,7 +70,7 @@
     private final Object closeLock = new Object();
     private volatile boolean closed = false;
     private static final ThreadLocal<Boolean> runningFinalize =
-        new ThreadLocal<>();
+        new ThreadLocal<Boolean>();
 
     private static boolean isRunningFinalize() {
         Boolean val;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/FilePermission.java openjdk-boot/jdk/src/share/classes/java/io/FilePermission.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/FilePermission.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/FilePermission.java	2011-07-12 16:56:06.714260168 +0100
@@ -725,7 +725,7 @@
      */
 
     public FilePermissionCollection() {
-        perms = new ArrayList<>();
+        perms = new ArrayList<Permission>();
     }
 
     /**
@@ -830,7 +830,7 @@
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
-        Vector<Permission> permissions = new Vector<>(perms.size());
+        Vector<Permission> permissions = new Vector<Permission>(perms.size());
         synchronized (this) {
             permissions.addAll(perms);
         }
@@ -853,7 +853,7 @@
 
         // Get the one we want
         Vector<Permission> permissions = (Vector<Permission>)gfields.get("permissions", null);
-        perms = new ArrayList<>(permissions.size());
+        perms = new ArrayList<Permission>(permissions.size());
         perms.addAll(permissions);
     }
 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectInputStream.java openjdk-boot/jdk/src/share/classes/java/io/ObjectInputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectInputStream.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/ObjectInputStream.java	2011-07-12 16:56:06.718260234 +0100
@@ -213,7 +213,7 @@
 
     /** table mapping primitive type names to corresponding class objects */
     private static final HashMap<String, Class<?>> primClasses
-        = new HashMap<>(8, 1.0F);
+        = new HashMap<String, Class<?>>(8, 1.0F);
     static {
         primClasses.put("boolean", boolean.class);
         primClasses.put("byte", byte.class);
@@ -229,11 +229,11 @@
     private static class Caches {
         /** cache of subclass security audit results */
         static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<WeakClassKey,Boolean>();
 
         /** queue for WeakReferences to audited subclasses */
         static final ReferenceQueue<Class<?>> subclassAuditsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
     }
 
     /** filter stream for handling block data conversion */
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectOutputStream.java openjdk-boot/jdk/src/share/classes/java/io/ObjectOutputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectOutputStream.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/ObjectOutputStream.java	2011-07-12 16:56:06.718260234 +0100
@@ -165,11 +165,11 @@
     private static class Caches {
         /** cache of subclass security audit results */
         static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<WeakClassKey,Boolean>();
 
         /** queue for WeakReferences to audited subclasses */
         static final ReferenceQueue<Class<?>> subclassAuditsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
     }
 
     /** filter stream for handling block data conversion */
@@ -2413,7 +2413,7 @@
         private final List<String> stack;
 
         DebugTraceInfoStack() {
-            stack = new ArrayList<>();
+            stack = new ArrayList<String>();
         }
 
         /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectStreamClass.java openjdk-boot/jdk/src/share/classes/java/io/ObjectStreamClass.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectStreamClass.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/ObjectStreamClass.java	2011-07-12 16:56:06.718260234 +0100
@@ -84,18 +84,18 @@
     private static class Caches {
         /** cache mapping local classes -> descriptors */
         static final ConcurrentMap<WeakClassKey,Reference<?>> localDescs =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<WeakClassKey,Reference<?>>();
 
         /** cache mapping field group/local desc pairs -> field reflectors */
         static final ConcurrentMap<FieldReflectorKey,Reference<?>> reflectors =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<FieldReflectorKey,Reference<?>>();
 
         /** queue for WeakReferences to local classes */
         private static final ReferenceQueue<Class<?>> localDescsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
         /** queue for WeakReferences to field reflectors keys */
         private static final ReferenceQueue<Class<?>> reflectorsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
     }
 
     /** class associated with this descriptor (if any) */
@@ -290,7 +290,7 @@
         EntryFuture future = null;
         if (entry == null) {
             EntryFuture newEntry = new EntryFuture();
-            Reference<?> newRef = new SoftReference<>(newEntry);
+            Reference<?> newRef = new SoftReference<EntryFuture>(newEntry);
             do {
                 if (ref != null) {
                     Caches.localDescs.remove(key, ref);
@@ -1130,7 +1130,7 @@
     private ClassDataSlot[] getClassDataLayout0()
         throws InvalidClassException
     {
-        ArrayList<ClassDataSlot> slots = new ArrayList<>();
+        ArrayList<ClassDataSlot> slots = new ArrayList<ClassDataSlot>();
         Class<?> start = cl, end = cl;
 
         // locate closest non-serializable superclass
@@ -1566,7 +1566,7 @@
 
         ObjectStreamField[] boundFields =
             new ObjectStreamField[serialPersistentFields.length];
-        Set<String> fieldNames = new HashSet<>(serialPersistentFields.length);
+        Set<String> fieldNames = new HashSet<String>(serialPersistentFields.length);
 
         for (int i = 0; i < serialPersistentFields.length; i++) {
             ObjectStreamField spf = serialPersistentFields[i];
@@ -1604,7 +1604,7 @@
      */
     private static ObjectStreamField[] getDefaultSerialFields(Class<?> cl) {
         Field[] clFields = cl.getDeclaredFields();
-        ArrayList<ObjectStreamField> list = new ArrayList<>();
+        ArrayList<ObjectStreamField> list = new ArrayList<ObjectStreamField>();
         int mask = Modifier.STATIC | Modifier.TRANSIENT;
 
         for (int i = 0; i < clFields.length; i++) {
@@ -1855,8 +1855,8 @@
             writeKeys = new long[nfields];
             offsets = new int[nfields];
             typeCodes = new char[nfields];
-            ArrayList<Class<?>> typeList = new ArrayList<>();
-            Set<Long> usedKeys = new HashSet<>();
+            ArrayList<Class<?>> typeList = new ArrayList<Class<?>>();
+            Set<Long> usedKeys = new HashSet<Long>();
 
 
             for (int i = 0; i < nfields; i++) {
@@ -2092,7 +2092,7 @@
         EntryFuture future = null;
         if (entry == null) {
             EntryFuture newEntry = new EntryFuture();
-            Reference<?> newRef = new SoftReference<>(newEntry);
+            Reference<?> newRef = new SoftReference<EntryFuture>(newEntry);
             do {
                 if (ref != null) {
                     Caches.reflectors.remove(key, ref);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/ApplicationShutdownHooks.java openjdk-boot/jdk/src/share/classes/java/lang/ApplicationShutdownHooks.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/ApplicationShutdownHooks.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/ApplicationShutdownHooks.java	2011-07-12 16:56:06.718260234 +0100
@@ -47,7 +47,7 @@
                     }
                 }
             );
-            hooks = new IdentityHashMap<>();
+            hooks = new IdentityHashMap<Thread, Thread>();
         } catch (IllegalStateException e) {
             // application shutdown hooks cannot be added if
             // shutdown is in progress.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Character.java openjdk-boot/jdk/src/share/classes/java/lang/Character.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Character.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Character.java	2011-07-12 16:56:06.718260234 +0100
@@ -646,7 +646,8 @@
      */
     public static final class UnicodeBlock extends Subset {
 
-        private static Map<String, UnicodeBlock> map = new HashMap<>(256);
+        private static Map<String, UnicodeBlock> map
+            = new HashMap<String, UnicodeBlock>(256);
 
         /**
          * Creates a UnicodeBlock with the given identifier name.
@@ -4175,7 +4176,7 @@
 
         private static HashMap<String, Character.UnicodeScript> aliases;
         static {
-            aliases = new HashMap<>(128);
+            aliases = new HashMap<String, UnicodeScript>(128);
             aliases.put("ARAB", ARABIC);
             aliases.put("ARMI", IMPERIAL_ARAMAIC);
             aliases.put("ARMN", ARMENIAN);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/CharacterName.java openjdk-boot/jdk/src/share/classes/java/lang/CharacterName.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/CharacterName.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/CharacterName.java	2011-07-12 16:56:06.718260234 +0100
@@ -81,7 +81,7 @@
             } while (cpOff < cpEnd);
             strPool = new byte[total - cpEnd];
             dis.readFully(strPool);
-            refStrPool = new SoftReference<>(strPool);
+            refStrPool = new SoftReference<byte[]>(strPool);
         } catch (Exception x) {
             throw new InternalError(x.getMessage());
         } finally {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Class.java openjdk-boot/jdk/src/share/classes/java/lang/Class.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Class.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Class.java	2011-07-12 16:56:06.722260300 +0100
@@ -1308,7 +1308,7 @@
         return java.security.AccessController.doPrivileged(
             new java.security.PrivilegedAction<Class<?>[]>() {
                 public Class[] run() {
-                    List<Class<?>> list = new ArrayList<>();
+                    List<Class<?>> list = new ArrayList<Class<?>>();
                     Class<?> currentClass = Class.this;
                     while (currentClass != null) {
                         Class<?>[] members = currentClass.getDeclaredClasses();
@@ -2308,9 +2308,9 @@
         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
         if (useCaches) {
             if (publicOnly) {
-                declaredPublicFields = new SoftReference<>(res);
+                declaredPublicFields = new SoftReference<Field[]>(res);
             } else {
-                declaredFields = new SoftReference<>(res);
+                declaredFields = new SoftReference<Field[]>(res);
             }
         }
         return res;
@@ -2332,9 +2332,9 @@
 
         // No cached value available; compute value recursively.
         // Traverse in correct order for getField().
-        List<Field> fields = new ArrayList<>();
+        List<Field> fields = new ArrayList<Field>();
         if (traversedInterfaces == null) {
-            traversedInterfaces = new HashSet<>();
+            traversedInterfaces = new HashSet<Class<?>>();
         }
 
         // Local fields
@@ -2360,7 +2360,7 @@
         res = new Field[fields.size()];
         fields.toArray(res);
         if (useCaches) {
-            publicFields = new SoftReference<>(res);
+            publicFields = new SoftReference<Field[]>(res);
         }
         return res;
     }
@@ -2405,9 +2405,9 @@
         }
         if (useCaches) {
             if (publicOnly) {
-                publicConstructors = new SoftReference<>(res);
+                publicConstructors = new SoftReference<Constructor<T>[]>(res);
             } else {
-                declaredConstructors = new SoftReference<>(res);
+                declaredConstructors = new SoftReference<Constructor<T>[]>(res);
             }
         }
         return res;
@@ -2442,9 +2442,9 @@
         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
         if (useCaches) {
             if (publicOnly) {
-                declaredPublicMethods = new SoftReference<>(res);
+                declaredPublicMethods = new SoftReference<Method[]>(res);
             } else {
-                declaredMethods = new SoftReference<>(res);
+                declaredMethods = new SoftReference<Method[]>(res);
             }
         }
         return res;
@@ -2600,7 +2600,7 @@
         methods.compactAndTrim();
         res = methods.getArray();
         if (useCaches) {
-            publicMethods = new SoftReference<>(res);
+            publicMethods = new SoftReference<Method[]>(res);
         }
         return res;
     }
@@ -2979,7 +2979,7 @@
             if (universe == null)
                 throw new IllegalArgumentException(
                     getName() + " is not an enum type");
-            Map<String, T> m = new HashMap<>(2 * universe.length);
+            Map<String, T> m = new HashMap<String, T>(2 * universe.length);
             for (T constant : universe)
                 m.put(((Enum<?>)constant).name(), constant);
             enumConstantDirectory = m;
@@ -3092,7 +3092,7 @@
         if (superClass == null) {
             annotations = declaredAnnotations;
         } else {
-            annotations = new HashMap<>();
+            annotations = new HashMap<Class<? extends Annotation>, Annotation>();
             superClass.initAnnotationsIfNecessary();
             for (Map.Entry<Class<? extends Annotation>, Annotation> e : superClass.annotations.entrySet()) {
                 Class<? extends Annotation> annotationClass = e.getKey();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/ClassLoader.java openjdk-boot/jdk/src/share/classes/java/lang/ClassLoader.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/ClassLoader.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/ClassLoader.java	2011-07-12 16:56:06.722260300 +0100
@@ -246,7 +246,7 @@
 
     // The classes loaded by this class loader. The only purpose of this table
     // is to keep the classes from being GC'ed until the loader is GC'ed.
-    private final Vector<Class<?>> classes = new Vector<>();
+    private final Vector<Class<?>> classes = new Vector<Class<?>>();
 
     // The "default" domain. Set as the default ProtectionDomain on newly
     // created classes.
@@ -265,7 +265,8 @@
     // The packages defined in this class loader.  Each package name is mapped
     // to its corresponding Package object.
     // @GuardedBy("itself")
-    private final HashMap<String, Package> packages = new HashMap<>();
+    private final HashMap<String, Package> packages =
+        new HashMap<String, Package>();
 
     private static Void checkCreateClassLoader() {
         SecurityManager security = System.getSecurityManager();
@@ -278,16 +279,16 @@
     private ClassLoader(Void unused, ClassLoader parent) {
         this.parent = parent;
         if (ParallelLoaders.isRegistered(this.getClass())) {
-            parallelLockMap = new ConcurrentHashMap<>();
-            package2certs = new ConcurrentHashMap<>();
+            parallelLockMap = new ConcurrentHashMap<String, Object>();
+            package2certs = new ConcurrentHashMap<String, Certificate[]>();
             domains =
                 Collections.synchronizedSet(new HashSet<ProtectionDomain>());
             assertionLock = new Object();
         } else {
             // no finer-grained lock; lock on the classloader instance
             parallelLockMap = null;
-            package2certs = new Hashtable<>();
-            domains = new HashSet<>();
+            package2certs = new Hashtable<String, Certificate[]>();
+            domains = new HashSet<ProtectionDomain>();
             assertionLock = this;
         }
     }
@@ -1175,7 +1176,7 @@
         }
         tmp[1] = findResources(name);
 
-        return new CompoundEnumeration<>(tmp);
+        return new CompoundEnumeration<URL>(tmp);
     }
 
     /**
@@ -1657,7 +1658,7 @@
     protected Package[] getPackages() {
         Map<String, Package> map;
         synchronized (packages) {
-            map = new HashMap<>(packages);
+            map = new HashMap<String, Package>(packages);
         }
         Package[] pkgs;
         if (parent != null) {
@@ -1764,17 +1765,20 @@
     }
 
     // All native library names we've loaded.
-    private static Vector<String> loadedLibraryNames = new Vector<>();
+    private static Vector<String> loadedLibraryNames
+        = new Vector<String>();
 
     // Native libraries belonging to system classes.
     private static Vector<NativeLibrary> systemNativeLibraries
-        = new Vector<>();
+        = new Vector<NativeLibrary>();
 
     // Native libraries associated with the class loader.
-    private Vector<NativeLibrary> nativeLibraries = new Vector<>();
+    private Vector<NativeLibrary> nativeLibraries
+        = new Vector<NativeLibrary>();
 
     // native libraries being loaded/unloaded.
-    private static Stack<NativeLibrary> nativeLibraryContext = new Stack<>();
+    private static Stack<NativeLibrary> nativeLibraryContext
+        = new Stack<NativeLibrary>();
 
     // The paths searched for libraries
     private static String usr_paths[];
@@ -2097,8 +2101,8 @@
          * them to empty maps, effectively ignoring any present settings.
          */
         synchronized (assertionLock) {
-            classAssertionStatus = new HashMap<>();
-            packageAssertionStatus = new HashMap<>();
+            classAssertionStatus = new HashMap<String, Boolean>();
+            packageAssertionStatus = new HashMap<String, Boolean>();
             defaultAssertionStatus = false;
         }
     }
@@ -2160,8 +2164,8 @@
     private void initializeJavaAssertionMaps() {
         // assert Thread.holdsLock(assertionLock);
 
-        classAssertionStatus = new HashMap<>();
-        packageAssertionStatus = new HashMap<>();
+        classAssertionStatus = new HashMap<String, Boolean>();
+        packageAssertionStatus = new HashMap<String, Boolean>();
         AssertionStatusDirectives directives = retrieveDirectives();
 
         for(int i = 0; i < directives.classes.length; i++)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/management/ManagementFactory.java openjdk-boot/jdk/src/share/classes/java/lang/management/ManagementFactory.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/management/ManagementFactory.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/management/ManagementFactory.java	2011-07-12 16:56:06.722260300 +0100
@@ -789,7 +789,7 @@
            getPlatformManagementInterfaces()
     {
         Set<Class<? extends PlatformManagedObject>> result =
-            new TreeSet<>();
+            new TreeSet<Class<? extends PlatformManagedObject>>();
         for (PlatformComponent component: PlatformComponent.values()) {
             result.add(component.getMXBeanInterface());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/management/PlatformComponent.java openjdk-boot/jdk/src/share/classes/java/lang/management/PlatformComponent.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/management/PlatformComponent.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/management/PlatformComponent.java	2011-07-12 16:56:06.722260300 +0100
@@ -287,7 +287,7 @@
             List<T> getGcMXBeanList(Class<T> gcMXBeanIntf) {
         List<GarbageCollectorMXBean> list =
             ManagementFactoryHelper.getGarbageCollectorMXBeans();
-        List<T> result = new ArrayList<>(list.size());
+        List<T> result = new ArrayList<T>(list.size());
         for (GarbageCollectorMXBean m : list) {
             if (gcMXBeanIntf.isInstance(m)) {
                 result.add(gcMXBeanIntf.cast(m));
@@ -342,7 +342,7 @@
     }
 
     private static Set<String> keyProperties(String... keyNames) {
-        Set<String> set = new HashSet<>();
+        Set<String> set = new HashSet<String>();
         set.add("type");
         for (String s : keyNames) {
             set.add(s);
@@ -407,7 +407,7 @@
             List<T> getMXBeans(MBeanServerConnection mbs, Class<T> mxbeanInterface)
         throws java.io.IOException
     {
-        List<T> result = new ArrayList<>();
+        List<T> result = new ArrayList<T>();
         for (ObjectName on : getObjectNames(mbs)) {
             result.add(ManagementFactory.
                 newPlatformMXBeanProxy(mbs,
@@ -438,7 +438,7 @@
     private static Map<String, PlatformComponent> enumMap;
     private static synchronized void ensureInitialized() {
         if (enumMap == null) {
-            enumMap = new HashMap<>();
+            enumMap = new HashMap<String,PlatformComponent>();
             for (PlatformComponent pc: PlatformComponent.values()) {
                 // Use String as the key rather than Class<?> to avoid
                 // causing unnecessary class loading of management interface
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Package.java openjdk-boot/jdk/src/share/classes/java/lang/Package.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Package.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Package.java	2011-07-12 16:56:06.722260300 +0100
@@ -596,13 +596,16 @@
     }
 
     // The map of loaded system packages
-    private static Map<String, Package> pkgs = new HashMap<>(31);
+    private static Map<String, Package> pkgs
+        = new HashMap<String, Package>(31);
 
     // Maps each directory or zip file name to its corresponding url
-    private static Map<String, URL> urls = new HashMap<>(10);
+    private static Map<String, URL> urls
+        = new HashMap<String, URL>(10);
 
     // Maps each code source url for a jar file to its manifest
-    private static Map<String, Manifest> mans = new HashMap<>(10);
+    private static Map<String, Manifest> mans
+        = new HashMap<String, Manifest>(10);
 
     private static native String getSystemPackage0(String name);
     private static native String[] getSystemPackages0();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/ProcessBuilder.java openjdk-boot/jdk/src/share/classes/java/lang/ProcessBuilder.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/ProcessBuilder.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/ProcessBuilder.java	2011-07-12 16:56:06.722260300 +0100
@@ -214,7 +214,7 @@
      * @param command a string array containing the program and its arguments
      */
     public ProcessBuilder(String... command) {
-        this.command = new ArrayList<>(command.length);
+        this.command = new ArrayList<String>(command.length);
         for (String arg : command)
             this.command.add(arg);
     }
@@ -251,7 +251,7 @@
      * @return this process builder
      */
     public ProcessBuilder command(String... command) {
-        this.command = new ArrayList<>(command.length);
+        this.command = new ArrayList<String>(command.length);
         for (String arg : command)
             this.command.add(arg);
         return this;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/Constructor.java openjdk-boot/jdk/src/share/classes/java/lang/reflect/Constructor.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/Constructor.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/reflect/Constructor.java	2011-07-12 16:56:06.722260300 +0100
@@ -136,7 +136,7 @@
         // which implicitly requires that new java.lang.reflect
         // objects be fabricated for each reflective call on Class
         // objects.)
-        Constructor<T> res = new Constructor<>(clazz,
+        Constructor<T> res = new Constructor<T>(clazz,
                                                 parameterTypes,
                                                 exceptionTypes, modifiers, slot,
                                                 signature,
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/Proxy.java openjdk-boot/jdk/src/share/classes/java/lang/reflect/Proxy.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/Proxy.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/reflect/Proxy.java	2011-07-12 16:56:06.722260300 +0100
@@ -232,7 +232,7 @@
 
     /** maps a class loader to the proxy class cache for that loader */
     private static Map<ClassLoader, Map<List<String>, Object>> loaderToCache
-        = new WeakHashMap<>();
+        = new WeakHashMap<ClassLoader, Map<List<String>, Object>>();
 
     /** marks that a particular proxy class is currently being generated */
     private static Object pendingGenerationMarker = new Object();
@@ -356,7 +356,7 @@
         String[] interfaceNames = new String[interfaces.length];
 
         // for detecting duplicates
-        Set<Class<?>> interfaceSet = new HashSet<>();
+        Set<Class<?>> interfaceSet = new HashSet<Class<?>>();
 
         for (int i = 0; i < interfaces.length; i++) {
             /*
@@ -413,7 +413,7 @@
         synchronized (loaderToCache) {
             cache = loaderToCache.get(loader);
             if (cache == null) {
-                cache = new HashMap<>();
+                cache = new HashMap<List<String>, Object>();
                 loaderToCache.put(loader, cache);
             }
             /*
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/ReflectAccess.java openjdk-boot/jdk/src/share/classes/java/lang/reflect/ReflectAccess.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/ReflectAccess.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/reflect/ReflectAccess.java	2011-07-12 16:56:06.722260300 +0100
@@ -84,7 +84,7 @@
                                              byte[] annotations,
                                              byte[] parameterAnnotations)
     {
-        return new Constructor<>(declaringClass,
+        return new Constructor<T>(declaringClass,
                                   parameterTypes,
                                   checkedExceptions,
                                   modifiers,
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/StringCoding.java openjdk-boot/jdk/src/share/classes/java/lang/StringCoding.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/StringCoding.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/StringCoding.java	2011-07-12 16:56:06.722260300 +0100
@@ -53,9 +53,9 @@
 
     /** The cached coders for each thread */
     private final static ThreadLocal<SoftReference<StringDecoder>> decoder =
-        new ThreadLocal<>();
+        new ThreadLocal<SoftReference<StringDecoder>>();
     private final static ThreadLocal<SoftReference<StringEncoder>> encoder =
-        new ThreadLocal<>();
+        new ThreadLocal<SoftReference<StringEncoder>>();
 
     private static boolean warnUnsupportedCharset = true;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/String.java openjdk-boot/jdk/src/share/classes/java/lang/String.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/String.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/String.java	2011-07-12 16:56:06.722260300 +0100
@@ -2330,7 +2330,7 @@
             int off = 0;
             int next = 0;
             boolean limited = limit > 0;
-            ArrayList<String> list = new ArrayList<>();
+            ArrayList<String> list = new ArrayList<String>();
             while ((next = indexOf(ch, off)) != -1) {
                 if (!limited || list.size() < limit - 1) {
                     list.add(substring(off, next));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Thread.java openjdk-boot/jdk/src/share/classes/java/lang/Thread.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Thread.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Thread.java	2011-07-12 16:56:06.726260366 +0100
@@ -1616,7 +1616,8 @@
         // Get a snapshot of the list of all threads
         Thread[] threads = getThreads();
         StackTraceElement[][] traces = dumpThreads(threads);
-        Map<Thread, StackTraceElement[]> m = new HashMap<>(threads.length);
+        Map<Thread, StackTraceElement[]> m
+            = new HashMap<Thread, StackTraceElement[]>(threads.length);
         for (int i = 0; i < threads.length; i++) {
             StackTraceElement[] stackTrace = traces[i];
             if (stackTrace != null) {
@@ -1637,11 +1638,11 @@
     private static class Caches {
         /** cache of subclass security audit results */
         static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<WeakClassKey,Boolean>();
 
         /** queue for WeakReferences to audited subclasses */
         static final ReferenceQueue<Class<?>> subclassAuditsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Throwable.java openjdk-boot/jdk/src/share/classes/java/lang/Throwable.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Throwable.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Throwable.java	2011-07-12 16:56:06.726260366 +0100
@@ -917,7 +917,7 @@
                 // Use the sentinel for a zero-length list
                 suppressed = SUPPRESSED_SENTINEL;
             } else { // Copy Throwables to new list
-                suppressed = new ArrayList<>(1);
+                suppressed = new ArrayList<Throwable>(1);
                 for (Throwable t : suppressedExceptions) {
                     // Enforce constraints on suppressed exceptions in
                     // case of corrupt or malicious stream.
@@ -1048,7 +1048,7 @@
             return;
 
         if (suppressedExceptions == SUPPRESSED_SENTINEL)
-            suppressedExceptions = new ArrayList<>(1);
+            suppressedExceptions = new ArrayList<Throwable>(1);
 
         suppressedExceptions.add(exception);
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/net/InetAddress.java openjdk-boot/jdk/src/share/classes/java/net/InetAddress.java
--- openjdk-boot.orig/jdk/src/share/classes/java/net/InetAddress.java	2011-07-12 12:43:47.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/net/InetAddress.java	2011-07-12 16:56:06.726260366 +0100
@@ -677,7 +677,7 @@
 
     static InetAddressImpl  impl;
 
-    private static final HashMap<String, Void> lookupTable = new HashMap<>();
+    private static final HashMap<String, Void> lookupTable = new HashMap<String, Void>();
 
     /**
      * Represents a cache entry
@@ -736,7 +736,7 @@
 
                 // As we iterate in insertion order we can
                 // terminate when a non-expired entry is found.
-                LinkedList<String> expired = new LinkedList<>();
+                LinkedList<String> expired = new LinkedList<String>();
                 long now = System.currentTimeMillis();
                 for (String key : cache.keySet()) {
                     CacheEntry entry = cache.get(key);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/net/URLClassLoader.java openjdk-boot/jdk/src/share/classes/java/net/URLClassLoader.java
--- openjdk-boot.orig/jdk/src/share/classes/java/net/URLClassLoader.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/net/URLClassLoader.java	2011-07-12 16:56:06.726260366 +0100
@@ -205,7 +205,7 @@
      */
 
     private WeakHashMap<Closeable,Void>
-        closeables = new WeakHashMap<>();
+        closeables = new WeakHashMap<Closeable, Void>();
 
     /**
      * Returns an input stream for reading the specified resource.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/nio/file/Files.java openjdk-boot/jdk/src/share/classes/java/nio/file/Files.java
--- openjdk-boot.orig/jdk/src/share/classes/java/nio/file/Files.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/nio/file/Files.java	2011-07-12 16:56:06.726260366 +0100
@@ -1487,7 +1487,7 @@
             return AccessController
                 .doPrivileged(new PrivilegedAction<List<FileTypeDetector>>() {
                     @Override public List<FileTypeDetector> run() {
-                        List<FileTypeDetector> list = new ArrayList<>();
+                        List<FileTypeDetector> list = new ArrayList<FileTypeDetector>();
                         ServiceLoader<FileTypeDetector> loader = ServiceLoader
                             .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());
                         for (FileTypeDetector detector: loader) {
@@ -3008,7 +3008,7 @@
         BufferedReader reader = null;
         try {
             reader = newBufferedReader(path, cs);
-            List<String> result = new ArrayList<>();
+            List<String> result = new ArrayList<String>();
             for (;;) {
                 String line = reader.readLine();
                 if (line == null)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/AccessControlContext.java openjdk-boot/jdk/src/share/classes/java/security/AccessControlContext.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/AccessControlContext.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/AccessControlContext.java	2011-07-12 16:56:06.726260366 +0100
@@ -124,7 +124,7 @@
                 this.context = null;
             }
         } else {
-            List<ProtectionDomain> v = new ArrayList<>(context.length);
+            List<ProtectionDomain> v = new ArrayList<ProtectionDomain>(context.length);
             for (int i =0; i< context.length; i++) {
                 if ((context[i] != null) &&  (!v.contains(context[i])))
                     v.add(context[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/BasicPermission.java openjdk-boot/jdk/src/share/classes/java/security/BasicPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/BasicPermission.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/BasicPermission.java	2011-07-12 16:56:06.726260366 +0100
@@ -515,7 +515,7 @@
 
         // Copy perms into a Hashtable
         Hashtable<String, Permission> permissions =
-                new Hashtable<>(perms.size()*2);
+            new Hashtable<String, Permission>(perms.size()*2);
 
         synchronized (this) {
             permissions.putAll(perms);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/CodeSource.java openjdk-boot/jdk/src/share/classes/java/security/CodeSource.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/CodeSource.java	2011-04-20 04:40:22.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/CodeSource.java	2011-07-12 16:56:06.726260366 +0100
@@ -188,7 +188,7 @@
         } else if (signers != null) {
             // Convert the code signers to certs
             ArrayList<java.security.cert.Certificate> certChains =
-                        new ArrayList<>();
+                        new ArrayList<java.security.cert.Certificate>();
             for (int i = 0; i < signers.length; i++) {
                 certChains.addAll(
                     signers[i].getSignerCertPath().getCertificates());
@@ -606,10 +606,10 @@
 
             // Iterate through all the certificates
             int i = 0;
-            List<CodeSigner> signers = new ArrayList<>();
+            List<CodeSigner> signers = new ArrayList<CodeSigner>();
             while (i < certs.length) {
                 List<java.security.cert.Certificate> certChain =
-                        new ArrayList<>();
+                        new ArrayList<java.security.cert.Certificate>();
                 certChain.add(certs[i++]); // first cert is an end-entity cert
                 int j = i;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/Permissions.java openjdk-boot/jdk/src/share/classes/java/security/Permissions.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/Permissions.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/Permissions.java	2011-07-12 16:56:06.726260366 +0100
@@ -362,7 +362,7 @@
 
         // Copy perms into a Hashtable
         Hashtable<Class<?>, PermissionCollection> perms =
-            new Hashtable<>(permsMap.size()*2); // no sync; estimate
+            new Hashtable<Class<?>, PermissionCollection>(permsMap.size()*2); // no sync; estimate
         synchronized (this) {
             perms.putAll(permsMap);
         }
@@ -567,7 +567,7 @@
 
         // Copy perms into a Hashtable
         Hashtable<Permission, Permission> perms =
-                new Hashtable<>(permsMap.size()*2);
+            new Hashtable<Permission, Permission>(permsMap.size()*2);
         synchronized (this) {
             perms.putAll(permsMap);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/ProtectionDomain.java openjdk-boot/jdk/src/share/classes/java/security/ProtectionDomain.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/ProtectionDomain.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/ProtectionDomain.java	2011-07-12 16:56:06.726260366 +0100
@@ -368,8 +368,8 @@
         int swag = 32;
         int vcap = 8;
         Enumeration<Permission> e;
-        List<Permission> pdVector = new ArrayList<>(vcap);
-        List<Permission> plVector = new ArrayList<>(swag);
+        List<Permission> pdVector = new ArrayList<Permission>(vcap);
+        List<Permission> plVector = new ArrayList<Permission>(swag);
 
         //
         // Build a vector of domain permissions for subsequent merge
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/Provider.java openjdk-boot/jdk/src/share/classes/java/security/Provider.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/Provider.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/Provider.java	2011-07-12 16:56:06.730260432 +0100
@@ -437,7 +437,7 @@
 
     private void readObject(ObjectInputStream in)
                 throws IOException, ClassNotFoundException {
-        Map<Object,Object> copy = new HashMap<>();
+        Map<Object,Object> copy = new HashMap<Object,Object>();
         for (Map.Entry<Object,Object> entry : super.entrySet()) {
             copy.put(entry.getKey(), entry.getValue());
         }
@@ -719,7 +719,7 @@
         }
         if (serviceSet == null) {
             ensureLegacyParsed();
-            Set<Service> set = new LinkedHashSet<>();
+            Set<Service> set = new LinkedHashSet<Service>();
             if (serviceMap != null) {
                 set.addAll(serviceMap.values());
             }
@@ -1395,7 +1395,7 @@
                     if (s != null) {
                         String[] classNames = s.split("\\|");
                         List<Class> classList =
-                            new ArrayList<>(classNames.length);
+                            new ArrayList<Class>(classNames.length);
                         for (String className : classNames) {
                             Class clazz = getKeyClass(className);
                             if (clazz != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/SecureClassLoader.java openjdk-boot/jdk/src/share/classes/java/security/SecureClassLoader.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/SecureClassLoader.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/SecureClassLoader.java	2011-07-12 16:56:06.730260432 +0100
@@ -50,7 +50,7 @@
     // HashMap that maps CodeSource to ProtectionDomain
     // @GuardedBy("pdcache")
     private final HashMap<CodeSource, ProtectionDomain> pdcache =
-                        new HashMap<>(11);
+        new HashMap<CodeSource, ProtectionDomain>(11);
 
     private static final Debug debug = Debug.getInstance("scl");
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/Security.java openjdk-boot/jdk/src/share/classes/java/security/Security.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/Security.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/Security.java	2011-07-12 16:56:06.730260432 +0100
@@ -546,7 +546,7 @@
             value = filter.substring(index + 1);
         }
 
-        Hashtable<String, String> hashtableFilter = new Hashtable<>(1);
+        Hashtable<String, String> hashtableFilter = new Hashtable<String, String>(1);
         hashtableFilter.put(key, value);
 
         return (getProviders(hashtableFilter));
@@ -606,7 +606,7 @@
         // Then only return those providers who satisfy the selection criteria.
         Provider[] allProviders = Security.getProviders();
         Set<String> keySet = filter.keySet();
-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);
+        LinkedHashSet<Provider> candidates = new LinkedHashSet<Provider>(5);
 
         // Returns all installed providers
         // if the selection criteria is null.
@@ -660,7 +660,7 @@
     }
 
     // Map containing cached Spi Class objects of the specified type
-    private static final Map<String, Class> spiMap = new ConcurrentHashMap<>();
+    private static final Map<String, Class> spiMap = new ConcurrentHashMap<String, Class>();
 
     /**
      * Return the Class object for the given engine type
@@ -884,7 +884,7 @@
                                                 String attrName,
                                                 String filterValue,
                                                 Provider[] allProviders) {
-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);
+        LinkedHashSet<Provider> candidates = new LinkedHashSet<Provider>(5);
         for (int i = 0; i < allProviders.length; i++) {
             if (isCriterionSatisfied(allProviders[i], serviceName,
                                      algName,
@@ -1081,7 +1081,7 @@
             return Collections.EMPTY_SET;
         }
 
-        HashSet<String> result = new HashSet<>();
+        HashSet<String> result = new HashSet<String>();
         Provider[] providers = Security.getProviders();
 
         for (int i = 0; i < providers.length; i++) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/UnresolvedPermissionCollection.java openjdk-boot/jdk/src/share/classes/java/security/UnresolvedPermissionCollection.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/UnresolvedPermissionCollection.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/UnresolvedPermissionCollection.java	2011-07-12 16:56:06.730260432 +0100
@@ -119,7 +119,7 @@
 
     public Enumeration<Permission> elements() {
         List<Permission> results =
-            new ArrayList<>(); // where results are stored
+            new ArrayList<Permission>(); // where results are stored
 
         // Get iterator of Map values (which are lists of permissions)
         synchronized (this) {
@@ -161,7 +161,7 @@
 
         // Copy perms into a Hashtable
         Hashtable<String, Vector<UnresolvedPermission>> permissions =
-            new Hashtable<>(perms.size()*2);
+            new Hashtable<String, Vector<UnresolvedPermission>>(perms.size()*2);
 
         // Convert each entry (List) into a Vector
         synchronized (this) {
@@ -169,7 +169,7 @@
             for (Map.Entry<String, List<UnresolvedPermission>> e : set) {
                 // Convert list into Vector
                 List<UnresolvedPermission> list = e.getValue();
-                Vector<UnresolvedPermission> vec = new Vector<>(list.size());
+                Vector<UnresolvedPermission> vec = new Vector<UnresolvedPermission>(list.size());
                 synchronized (list) {
                     vec.addAll(list);
                 }
@@ -206,7 +206,7 @@
         for (Map.Entry<String, Vector<UnresolvedPermission>> e : set) {
             // Convert Vector into ArrayList
             Vector<UnresolvedPermission> vec = e.getValue();
-            List<UnresolvedPermission> list = new ArrayList<>(vec.size());
+            List<UnresolvedPermission> list = new ArrayList<UnresolvedPermission>(vec.size());
             list.addAll(vec);
 
             // Add to Hashtable being serialized
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/UnresolvedPermission.java openjdk-boot/jdk/src/share/classes/java/security/UnresolvedPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/UnresolvedPermission.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/UnresolvedPermission.java	2011-07-12 16:56:06.730260432 +0100
@@ -198,7 +198,7 @@
                 if (this.certs == null) {
                     // extract the signer certs
                     ArrayList<java.security.cert.Certificate> signerCerts =
-                        new ArrayList<>();
+                        new ArrayList<java.security.cert.Certificate>();
                     i = 0;
                     while (i < certs.length) {
                         signerCerts.add(certs[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/AbstractList.java openjdk-boot/jdk/src/share/classes/java/util/AbstractList.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/AbstractList.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/AbstractList.java	2011-07-12 16:56:06.730260432 +0100
@@ -482,8 +482,8 @@
      */
     public List<E> subList(int fromIndex, int toIndex) {
         return (this instanceof RandomAccess ?
-                new RandomAccessSubList<>(this, fromIndex, toIndex) :
-                new SubList<>(this, fromIndex, toIndex));
+                new RandomAccessSubList<E>(this, fromIndex, toIndex) :
+                new SubList<E>(this, fromIndex, toIndex));
     }
 
     // Comparison and hashing
@@ -747,7 +747,7 @@
     }
 
     public List<E> subList(int fromIndex, int toIndex) {
-        return new SubList<>(this, fromIndex, toIndex);
+        return new SubList<E>(this, fromIndex, toIndex);
     }
 
     private void rangeCheck(int index) {
@@ -776,6 +776,6 @@
     }
 
     public List<E> subList(int fromIndex, int toIndex) {
-        return new RandomAccessSubList<>(this, fromIndex, toIndex);
+        return new RandomAccessSubList<E>(this, fromIndex, toIndex);
     }
 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Arrays.java openjdk-boot/jdk/src/share/classes/java/util/Arrays.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Arrays.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Arrays.java	2011-07-12 16:56:06.730260432 +0100
@@ -2825,7 +2825,7 @@
      */
     @SafeVarargs
     public static <T> List<T> asList(T... a) {
-        return new ArrayList<>(a);
+        return new ArrayList<T>(a);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Collections.java openjdk-boot/jdk/src/share/classes/java/util/Collections.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Collections.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Collections.java	2011-07-12 16:56:06.750260766 +0100
@@ -1035,7 +1035,7 @@
      * @return an unmodifiable view of the specified collection.
      */
     public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
-        return new UnmodifiableCollection<>(c);
+        return new UnmodifiableCollection<T>(c);
     }
 
     /**
@@ -1109,7 +1109,7 @@
      * @return an unmodifiable view of the specified set.
      */
     public static <T> Set<T> unmodifiableSet(Set<? extends T> s) {
-        return new UnmodifiableSet<>(s);
+        return new UnmodifiableSet<T>(s);
     }
 
     /**
@@ -1141,7 +1141,7 @@
      * @return an unmodifiable view of the specified sorted set.
      */
     public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> s) {
-        return new UnmodifiableSortedSet<>(s);
+        return new UnmodifiableSortedSet<T>(s);
     }
 
     /**
@@ -1158,13 +1158,13 @@
         public Comparator<? super E> comparator() {return ss.comparator();}
 
         public SortedSet<E> subSet(E fromElement, E toElement) {
-            return new UnmodifiableSortedSet<>(ss.subSet(fromElement,toElement));
+            return new UnmodifiableSortedSet<E>(ss.subSet(fromElement,toElement));
         }
         public SortedSet<E> headSet(E toElement) {
-            return new UnmodifiableSortedSet<>(ss.headSet(toElement));
+            return new UnmodifiableSortedSet<E>(ss.headSet(toElement));
         }
         public SortedSet<E> tailSet(E fromElement) {
-            return new UnmodifiableSortedSet<>(ss.tailSet(fromElement));
+            return new UnmodifiableSortedSet<E>(ss.tailSet(fromElement));
         }
 
         public E first()                   {return ss.first();}
@@ -1188,8 +1188,8 @@
      */
     public static <T> List<T> unmodifiableList(List<? extends T> list) {
         return (list instanceof RandomAccess ?
-                new UnmodifiableRandomAccessList<>(list) :
-                new UnmodifiableList<>(list));
+                new UnmodifiableRandomAccessList<T>(list) :
+                new UnmodifiableList<T>(list));
     }
 
     /**
@@ -1250,7 +1250,7 @@
         }
 
         public List<E> subList(int fromIndex, int toIndex) {
-            return new UnmodifiableList<>(list.subList(fromIndex, toIndex));
+            return new UnmodifiableList<E>(list.subList(fromIndex, toIndex));
         }
 
         /**
@@ -1267,7 +1267,7 @@
          */
         private Object readResolve() {
             return (list instanceof RandomAccess
-                    ? new UnmodifiableRandomAccessList<>(list)
+                    ? new UnmodifiableRandomAccessList<E>(list)
                     : this);
         }
     }
@@ -1283,7 +1283,7 @@
         }
 
         public List<E> subList(int fromIndex, int toIndex) {
-            return new UnmodifiableRandomAccessList<>(
+            return new UnmodifiableRandomAccessList<E>(
                 list.subList(fromIndex, toIndex));
         }
 
@@ -1296,7 +1296,7 @@
          * deserialization.
          */
         private Object writeReplace() {
-            return new UnmodifiableList<>(list);
+            return new UnmodifiableList<E>(list);
         }
     }
 
@@ -1315,7 +1315,7 @@
      * @return an unmodifiable view of the specified map.
      */
     public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m) {
-        return new UnmodifiableMap<>(m);
+        return new UnmodifiableMap<K,V>(m);
     }
 
     /**
@@ -1363,7 +1363,7 @@
 
         public Set<Map.Entry<K,V>> entrySet() {
             if (entrySet==null)
-                entrySet = new UnmodifiableEntrySet<>(m.entrySet());
+                entrySet = new UnmodifiableEntrySet<K,V>(m.entrySet());
             return entrySet;
         }
 
@@ -1400,7 +1400,7 @@
                         return i.hasNext();
                     }
                     public Map.Entry<K,V> next() {
-                        return new UnmodifiableEntry<>(i.next());
+                        return new UnmodifiableEntry<K,V>(i.next());
                     }
                     public void remove() {
                         throw new UnsupportedOperationException();
@@ -1411,7 +1411,7 @@
             public Object[] toArray() {
                 Object[] a = c.toArray();
                 for (int i=0; i<a.length; i++)
-                    a[i] = new UnmodifiableEntry<>((Map.Entry<K,V>)a[i]);
+                    a[i] = new UnmodifiableEntry<K,V>((Map.Entry<K,V>)a[i]);
                 return a;
             }
 
@@ -1422,7 +1422,7 @@
                 Object[] arr = c.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));
 
                 for (int i=0; i<arr.length; i++)
-                    arr[i] = new UnmodifiableEntry<>((Map.Entry<K,V>)arr[i]);
+                    arr[i] = new UnmodifiableEntry<K,V>((Map.Entry<K,V>)arr[i]);
 
                 if (arr.length > a.length)
                     return (T[])arr;
@@ -1443,7 +1443,7 @@
                 if (!(o instanceof Map.Entry))
                     return false;
                 return c.contains(
-                    new UnmodifiableEntry<>((Map.Entry<?,?>) o));
+                    new UnmodifiableEntry<Object,Object>((Map.Entry<?,?>) o));
             }
 
             /**
@@ -1517,7 +1517,7 @@
      * @return an unmodifiable view of the specified sorted map.
      */
     public static <K,V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<K, ? extends V> m) {
-        return new UnmodifiableSortedMap<>(m);
+        return new UnmodifiableSortedMap<K,V>(m);
     }
 
     /**
@@ -1535,13 +1535,13 @@
         public Comparator<? super K> comparator() {return sm.comparator();}
 
         public SortedMap<K,V> subMap(K fromKey, K toKey) {
-            return new UnmodifiableSortedMap<>(sm.subMap(fromKey, toKey));
+            return new UnmodifiableSortedMap<K,V>(sm.subMap(fromKey, toKey));
         }
         public SortedMap<K,V> headMap(K toKey) {
-            return new UnmodifiableSortedMap<>(sm.headMap(toKey));
+            return new UnmodifiableSortedMap<K,V>(sm.headMap(toKey));
         }
         public SortedMap<K,V> tailMap(K fromKey) {
-            return new UnmodifiableSortedMap<>(sm.tailMap(fromKey));
+            return new UnmodifiableSortedMap<K,V>(sm.tailMap(fromKey));
         }
 
         public K firstKey()           {return sm.firstKey();}
@@ -1583,11 +1583,11 @@
      * @return a synchronized view of the specified collection.
      */
     public static <T> Collection<T> synchronizedCollection(Collection<T> c) {
-        return new SynchronizedCollection<>(c);
+        return new SynchronizedCollection<T>(c);
     }
 
     static <T> Collection<T> synchronizedCollection(Collection<T> c, Object mutex) {
-        return new SynchronizedCollection<>(c, mutex);
+        return new SynchronizedCollection<T>(c, mutex);
     }
 
     /**
@@ -1686,11 +1686,11 @@
      * @return a synchronized view of the specified set.
      */
     public static <T> Set<T> synchronizedSet(Set<T> s) {
-        return new SynchronizedSet<>(s);
+        return new SynchronizedSet<T>(s);
     }
 
     static <T> Set<T> synchronizedSet(Set<T> s, Object mutex) {
-        return new SynchronizedSet<>(s, mutex);
+        return new SynchronizedSet<T>(s, mutex);
     }
 
     /**
@@ -1754,7 +1754,7 @@
      * @return a synchronized view of the specified sorted set.
      */
     public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s) {
-        return new SynchronizedSortedSet<>(s);
+        return new SynchronizedSortedSet<T>(s);
     }
 
     /**
@@ -1783,18 +1783,18 @@
 
         public SortedSet<E> subSet(E fromElement, E toElement) {
             synchronized (mutex) {
-                return new SynchronizedSortedSet<>(
+                return new SynchronizedSortedSet<E>(
                     ss.subSet(fromElement, toElement), mutex);
             }
         }
         public SortedSet<E> headSet(E toElement) {
             synchronized (mutex) {
-                return new SynchronizedSortedSet<>(ss.headSet(toElement), mutex);
+                return new SynchronizedSortedSet<E>(ss.headSet(toElement), mutex);
             }
         }
         public SortedSet<E> tailSet(E fromElement) {
             synchronized (mutex) {
-               return new SynchronizedSortedSet<>(ss.tailSet(fromElement),mutex);
+               return new SynchronizedSortedSet<E>(ss.tailSet(fromElement),mutex);
             }
         }
 
@@ -1833,14 +1833,14 @@
      */
     public static <T> List<T> synchronizedList(List<T> list) {
         return (list instanceof RandomAccess ?
-                new SynchronizedRandomAccessList<>(list) :
-                new SynchronizedList<>(list));
+                new SynchronizedRandomAccessList<T>(list) :
+                new SynchronizedList<T>(list));
     }
 
     static <T> List<T> synchronizedList(List<T> list, Object mutex) {
         return (list instanceof RandomAccess ?
-                new SynchronizedRandomAccessList<>(list, mutex) :
-                new SynchronizedList<>(list, mutex));
+                new SynchronizedRandomAccessList<T>(list, mutex) :
+                new SynchronizedList<T>(list, mutex));
     }
 
     /**
@@ -1903,7 +1903,7 @@
 
         public List<E> subList(int fromIndex, int toIndex) {
             synchronized (mutex) {
-                return new SynchronizedList<>(list.subList(fromIndex, toIndex),
+                return new SynchronizedList<E>(list.subList(fromIndex, toIndex),
                                             mutex);
             }
         }
@@ -1922,7 +1922,7 @@
          */
         private Object readResolve() {
             return (list instanceof RandomAccess
-                    ? new SynchronizedRandomAccessList<>(list)
+                    ? new SynchronizedRandomAccessList<E>(list)
                     : this);
         }
     }
@@ -1944,7 +1944,7 @@
 
         public List<E> subList(int fromIndex, int toIndex) {
             synchronized (mutex) {
-                return new SynchronizedRandomAccessList<>(
+                return new SynchronizedRandomAccessList<E>(
                     list.subList(fromIndex, toIndex), mutex);
             }
         }
@@ -1958,7 +1958,7 @@
          * deserialization.
          */
         private Object writeReplace() {
-            return new SynchronizedList<>(list);
+            return new SynchronizedList<E>(list);
         }
     }
 
@@ -1990,7 +1990,7 @@
      * @return a synchronized view of the specified map.
      */
     public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {
-        return new SynchronizedMap<>(m);
+        return new SynchronizedMap<K,V>(m);
     }
 
     /**
@@ -2051,7 +2051,7 @@
         public Set<K> keySet() {
             synchronized (mutex) {
                 if (keySet==null)
-                    keySet = new SynchronizedSet<>(m.keySet(), mutex);
+                    keySet = new SynchronizedSet<K>(m.keySet(), mutex);
                 return keySet;
             }
         }
@@ -2059,7 +2059,7 @@
         public Set<Map.Entry<K,V>> entrySet() {
             synchronized (mutex) {
                 if (entrySet==null)
-                    entrySet = new SynchronizedSet<>(m.entrySet(), mutex);
+                    entrySet = new SynchronizedSet<Map.Entry<K,V>>(m.entrySet(), mutex);
                 return entrySet;
             }
         }
@@ -2067,7 +2067,7 @@
         public Collection<V> values() {
             synchronized (mutex) {
                 if (values==null)
-                    values = new SynchronizedCollection<>(m.values(), mutex);
+                    values = new SynchronizedCollection<V>(m.values(), mutex);
                 return values;
             }
         }
@@ -2129,7 +2129,7 @@
      * @return a synchronized view of the specified sorted map.
      */
     public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m) {
-        return new SynchronizedSortedMap<>(m);
+        return new SynchronizedSortedMap<K,V>(m);
     }
 
 
@@ -2159,18 +2159,18 @@
 
         public SortedMap<K,V> subMap(K fromKey, K toKey) {
             synchronized (mutex) {
-                return new SynchronizedSortedMap<>(
+                return new SynchronizedSortedMap<K,V>(
                     sm.subMap(fromKey, toKey), mutex);
             }
         }
         public SortedMap<K,V> headMap(K toKey) {
             synchronized (mutex) {
-                return new SynchronizedSortedMap<>(sm.headMap(toKey), mutex);
+                return new SynchronizedSortedMap<K,V>(sm.headMap(toKey), mutex);
             }
         }
         public SortedMap<K,V> tailMap(K fromKey) {
             synchronized (mutex) {
-               return new SynchronizedSortedMap<>(sm.tailMap(fromKey),mutex);
+               return new SynchronizedSortedMap<K,V>(sm.tailMap(fromKey),mutex);
             }
         }
 
@@ -2246,7 +2246,7 @@
      */
     public static <E> Collection<E> checkedCollection(Collection<E> c,
                                                       Class<E> type) {
-        return new CheckedCollection<>(c, type);
+        return new CheckedCollection<E>(c, type);
     }
 
     @SuppressWarnings("unchecked")
@@ -2378,7 +2378,7 @@
      * @since 1.5
      */
     public static <E> Set<E> checkedSet(Set<E> s, Class<E> type) {
-        return new CheckedSet<>(s, type);
+        return new CheckedSet<E>(s, type);
     }
 
     /**
@@ -2424,7 +2424,7 @@
      */
     public static <E> SortedSet<E> checkedSortedSet(SortedSet<E> s,
                                                     Class<E> type) {
-        return new CheckedSortedSet<>(s, type);
+        return new CheckedSortedSet<E>(s, type);
     }
 
     /**
@@ -2484,8 +2484,8 @@
      */
     public static <E> List<E> checkedList(List<E> list, Class<E> type) {
         return (list instanceof RandomAccess ?
-                new CheckedRandomAccessList<>(list, type) :
-                new CheckedList<>(list, type));
+                new CheckedRandomAccessList<E>(list, type) :
+                new CheckedList<E>(list, type));
     }
 
     /**
@@ -2550,7 +2550,7 @@
         }
 
         public List<E> subList(int fromIndex, int toIndex) {
-            return new CheckedList<>(list.subList(fromIndex, toIndex), type);
+            return new CheckedList<E>(list.subList(fromIndex, toIndex), type);
         }
     }
 
@@ -2567,7 +2567,7 @@
         }
 
         public List<E> subList(int fromIndex, int toIndex) {
-            return new CheckedRandomAccessList<>(
+            return new CheckedRandomAccessList<E>(
                 list.subList(fromIndex, toIndex), type);
         }
     }
@@ -2609,7 +2609,7 @@
     public static <K, V> Map<K, V> checkedMap(Map<K, V> m,
                                               Class<K> keyType,
                                               Class<V> valueType) {
-        return new CheckedMap<>(m, keyType, valueType);
+        return new CheckedMap<K,V>(m, keyType, valueType);
     }
 
 
@@ -2677,14 +2677,15 @@
             // - protection from malicious t
             // - correct behavior if t is a concurrent map
             Object[] entries = t.entrySet().toArray();
-            List<Map.Entry<K,V>> checked = new ArrayList<>(entries.length);
+            List<Map.Entry<K,V>> checked =
+                new ArrayList<Map.Entry<K,V>>(entries.length);
             for (Object o : entries) {
                 Map.Entry<?,?> e = (Map.Entry<?,?>) o;
                 Object k = e.getKey();
                 Object v = e.getValue();
                 typeCheck(k, v);
                 checked.add(
-                    new AbstractMap.SimpleImmutableEntry<>((K) k, (V) v));
+                    new AbstractMap.SimpleImmutableEntry<K,V>((K) k, (V) v));
             }
             for (Map.Entry<K,V> e : checked)
                 m.put(e.getKey(), e.getValue());
@@ -2694,7 +2695,7 @@
 
         public Set<Map.Entry<K,V>> entrySet() {
             if (entrySet==null)
-                entrySet = new CheckedEntrySet<>(m.entrySet(), valueType);
+                entrySet = new CheckedEntrySet<K,V>(m.entrySet(), valueType);
             return entrySet;
         }
 
@@ -2809,7 +2810,7 @@
                 if (!(o instanceof Map.Entry))
                     return false;
                 return s.remove(new AbstractMap.SimpleImmutableEntry
-                                <>((Map.Entry<?,?>)o));
+                                <Object, Object>((Map.Entry<?,?>)o));
             }
 
             public boolean removeAll(Collection<?> c) {
@@ -2842,7 +2843,7 @@
 
             static <K,V,T> CheckedEntry<K,V,T> checkedEntry(Map.Entry<K,V> e,
                                                             Class<T> valueType) {
-                return new CheckedEntry<>(e, valueType);
+                return new CheckedEntry<K,V,T>(e, valueType);
             }
 
             /**
@@ -2883,7 +2884,7 @@
                     if (!(o instanceof Map.Entry))
                         return false;
                     return e.equals(new AbstractMap.SimpleImmutableEntry
-                                    <>((Map.Entry<?,?>)o));
+                                    <Object, Object>((Map.Entry<?,?>)o));
                 }
             }
         }
@@ -2926,7 +2927,7 @@
     public static <K,V> SortedMap<K,V> checkedSortedMap(SortedMap<K, V> m,
                                                         Class<K> keyType,
                                                         Class<V> valueType) {
-        return new CheckedSortedMap<>(m, keyType, valueType);
+        return new CheckedSortedMap<K,V>(m, keyType, valueType);
     }
 
     /**
@@ -2992,7 +2993,7 @@
 
     private static class EmptyIterator<E> implements Iterator<E> {
         static final EmptyIterator<Object> EMPTY_ITERATOR
-            = new EmptyIterator<>();
+            = new EmptyIterator<Object>();
 
         public boolean hasNext() { return false; }
         public E next() { throw new NoSuchElementException(); }
@@ -3041,7 +3042,7 @@
         implements ListIterator<E>
     {
         static final EmptyListIterator<Object> EMPTY_ITERATOR
-            = new EmptyListIterator<>();
+            = new EmptyListIterator<Object>();
 
         public boolean hasPrevious() { return false; }
         public E previous() { throw new NoSuchElementException(); }
@@ -3077,7 +3078,7 @@
 
     private static class EmptyEnumeration<E> implements Enumeration<E> {
         static final EmptyEnumeration<Object> EMPTY_ENUMERATION
-            = new EmptyEnumeration<>();
+            = new EmptyEnumeration<Object>();
 
         public boolean hasMoreElements() { return false; }
         public E nextElement() { throw new NoSuchElementException(); }
@@ -3089,7 +3090,7 @@
      * @see #emptySet()
      */
     @SuppressWarnings("unchecked")
-    public static final Set EMPTY_SET = new EmptySet<>();
+    public static final Set EMPTY_SET = new EmptySet<Object>();
 
     /**
      * Returns the empty set (immutable).  This set is serializable.
@@ -3149,7 +3150,7 @@
      * @see #emptyList()
      */
     @SuppressWarnings("unchecked")
-    public static final List EMPTY_LIST = new EmptyList<>();
+    public static final List EMPTY_LIST = new EmptyList<Object>();
 
     /**
      * Returns the empty list (immutable).  This list is serializable.
@@ -3223,7 +3224,7 @@
      * @since 1.3
      */
     @SuppressWarnings("unchecked")
-    public static final Map EMPTY_MAP = new EmptyMap<>();
+    public static final Map EMPTY_MAP = new EmptyMap<Object,Object>();
 
     /**
      * Returns the empty map (immutable).  This map is serializable.
@@ -3285,7 +3286,7 @@
      * @return an immutable set containing only the specified object.
      */
     public static <T> Set<T> singleton(T o) {
-        return new SingletonSet<>(o);
+        return new SingletonSet<T>(o);
     }
 
     static <E> Iterator<E> singletonIterator(final E e) {
@@ -3338,7 +3339,7 @@
      * @since 1.3
      */
     public static <T> List<T> singletonList(T o) {
-        return new SingletonList<>(o);
+        return new SingletonList<T>(o);
     }
 
     /**
@@ -3380,7 +3381,7 @@
      * @since 1.3
      */
     public static <K,V> Map<K,V> singletonMap(K key, V value) {
-        return new SingletonMap<>(key, value);
+        return new SingletonMap<K,V>(key, value);
     }
 
     /**
@@ -3422,7 +3423,7 @@
         public Set<Map.Entry<K,V>> entrySet() {
             if (entrySet==null)
                 entrySet = Collections.<Map.Entry<K,V>>singleton(
-                    new SimpleImmutableEntry<>(k, v));
+                    new SimpleImmutableEntry<K,V>(k, v));
             return entrySet;
         }
 
@@ -3454,7 +3455,7 @@
     public static <T> List<T> nCopies(int n, T o) {
         if (n < 0)
             throw new IllegalArgumentException("List length = " + n);
-        return new CopiesList<>(n, o);
+        return new CopiesList<T>(n, o);
     }
 
     /**
@@ -3528,7 +3529,7 @@
             if (fromIndex > toIndex)
                 throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                                    ") > toIndex(" + toIndex + ")");
-            return new CopiesList<>(toIndex - fromIndex, element);
+            return new CopiesList<E>(toIndex - fromIndex, element);
         }
     }
 
@@ -3596,7 +3597,7 @@
         if (cmp instanceof ReverseComparator2)
             return ((ReverseComparator2<T>)cmp).cmp;
 
-        return new ReverseComparator2<>(cmp);
+        return new ReverseComparator2<T>(cmp);
     }
 
     /**
@@ -3675,7 +3676,7 @@
      * @see ArrayList
      */
     public static <T> ArrayList<T> list(Enumeration<T> e) {
-        ArrayList<T> l = new ArrayList<>();
+        ArrayList<T> l = new ArrayList<T>();
         while (e.hasMoreElements())
             l.add(e.nextElement());
         return l;
@@ -3868,7 +3869,7 @@
      * @since 1.6
      */
     public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {
-        return new SetFromMap<>(map);
+        return new SetFromMap<E>(map);
     }
 
     /**
@@ -3932,7 +3933,7 @@
      * @since  1.6
      */
     public static <T> Queue<T> asLifoQueue(Deque<T> deque) {
-        return new AsLIFOQueue<>(deque);
+        return new AsLIFOQueue<T>(deque);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/EnumMap.java openjdk-boot/jdk/src/share/classes/java/util/EnumMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/EnumMap.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/EnumMap.java	2011-07-12 16:56:06.750260766 +0100
@@ -500,7 +500,7 @@
             int j = 0;
             for (int i = 0; i < vals.length; i++)
                 if (vals[i] != null)
-                    a[j++] = new AbstractMap.SimpleEntry<>(
+                    a[j++] = new AbstractMap.SimpleEntry<K,V>(
                         keyUniverse[i], unmaskNull(vals[i]));
             return a;
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/EnumSet.java openjdk-boot/jdk/src/share/classes/java/util/EnumSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/EnumSet.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/EnumSet.java	2011-07-12 16:56:06.750260766 +0100
@@ -110,9 +110,9 @@
             throw new ClassCastException(elementType + " not an enum");
 
         if (universe.length <= 64)
-            return new RegularEnumSet<>(elementType, universe);
+            return new RegularEnumSet<E>(elementType, universe);
         else
-            return new JumboEnumSet<>(elementType, universe);
+            return new JumboEnumSet<E>(elementType, universe);
     }
 
     /**
@@ -431,7 +431,7 @@
     }
 
     Object writeReplace() {
-        return new SerializationProxy<>(this);
+        return new SerializationProxy<E>(this);
     }
 
     // readObject method for the serialization proxy pattern
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Formatter.java openjdk-boot/jdk/src/share/classes/java/util/Formatter.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Formatter.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Formatter.java	2011-07-12 16:56:06.750260766 +0100
@@ -2514,7 +2514,7 @@
      * Finds format specifiers in the format string.
      */
     private FormatString[] parse(String s) {
-        ArrayList<FormatString> al = new ArrayList<>();
+        ArrayList<FormatString> al = new ArrayList<FormatString>();
         Matcher m = fsPattern.matcher(s);
         for (int i = 0, len = s.length(); i < len; ) {
             if (m.find(i)) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/HashMap.java openjdk-boot/jdk/src/share/classes/java/util/HashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/HashMap.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/HashMap.java	2011-07-12 16:56:06.750260766 +0100
@@ -763,7 +763,7 @@
      */
     void addEntry(int hash, K key, V value, int bucketIndex) {
         Entry<K,V> e = table[bucketIndex];
-        table[bucketIndex] = new Entry<>(hash, key, value, e);
+        table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
         if (size++ >= threshold)
             resize(2 * table.length);
     }
@@ -778,7 +778,7 @@
      */
     void createEntry(int hash, K key, V value, int bucketIndex) {
         Entry<K,V> e = table[bucketIndex];
-        table[bucketIndex] = new Entry<>(hash, key, value, e);
+        table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
         size++;
     }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/HashSet.java openjdk-boot/jdk/src/share/classes/java/util/HashSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/HashSet.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/HashSet.java	2011-07-12 16:56:06.750260766 +0100
@@ -100,7 +100,7 @@
      * default initial capacity (16) and load factor (0.75).
      */
     public HashSet() {
-        map = new HashMap<>();
+        map = new HashMap<E,Object>();
     }
 
     /**
@@ -113,7 +113,7 @@
      * @throws NullPointerException if the specified collection is null
      */
     public HashSet(Collection<? extends E> c) {
-        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
+        map = new HashMap<E,Object>(Math.max((int) (c.size()/.75f) + 1, 16));
         addAll(c);
     }
 
@@ -127,7 +127,7 @@
      *             than zero, or if the load factor is nonpositive
      */
     public HashSet(int initialCapacity, float loadFactor) {
-        map = new HashMap<>(initialCapacity, loadFactor);
+        map = new HashMap<E,Object>(initialCapacity, loadFactor);
     }
 
     /**
@@ -139,7 +139,7 @@
      *             than zero
      */
     public HashSet(int initialCapacity) {
-        map = new HashMap<>(initialCapacity);
+        map = new HashMap<E,Object>(initialCapacity);
     }
 
     /**
@@ -156,7 +156,7 @@
      *             than zero, or if the load factor is nonpositive
      */
     HashSet(int initialCapacity, float loadFactor, boolean dummy) {
-        map = new LinkedHashMap<>(initialCapacity, loadFactor);
+        map = new LinkedHashMap<E,Object>(initialCapacity, loadFactor);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Hashtable.java openjdk-boot/jdk/src/share/classes/java/util/Hashtable.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Hashtable.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Hashtable.java	2011-07-12 16:56:06.754260831 +0100
@@ -455,7 +455,7 @@
 
         // Creates the new entry.
         Entry<K,V> e = tab[index];
-        tab[index] = new Entry<>(hash, key, value, e);
+        tab[index] = new Entry<K,V>(hash, key, value, e);
         count++;
         return null;
     }
@@ -579,7 +579,7 @@
         if (count == 0) {
             return Collections.emptyEnumeration();
         } else {
-            return new Enumerator<>(type, false);
+            return new Enumerator<T>(type, false);
         }
     }
 
@@ -587,7 +587,7 @@
         if (count == 0) {
             return Collections.emptyIterator();
         } else {
-            return new Enumerator<>(type, true);
+            return new Enumerator<T>(type, true);
         }
     }
 
@@ -863,7 +863,7 @@
 
                 while (entry != null) {
                     entryStack =
-                        new Entry<>(0, entry.key, entry.value, entryStack);
+                        new Entry<Object, Object>(0, entry.key, entry.value, entryStack);
                     entry = entry.next;
                 }
             }
@@ -941,7 +941,7 @@
         }
         // Creates the new entry.
         Entry<K,V> e = tab[index];
-        tab[index] = new Entry<>(hash, key, value, e);
+        tab[index] = new Entry<K,V>(hash, key, value, e);
         count++;
     }
 
@@ -962,7 +962,7 @@
         }
 
         protected Object clone() {
-            return new Entry<>(hash, key, value,
+            return new Entry<K,V>(hash, key, value,
                                   (next==null ? null : (Entry<K,V>) next.clone()));
         }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/IdentityHashMap.java openjdk-boot/jdk/src/share/classes/java/util/IdentityHashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/IdentityHashMap.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/IdentityHashMap.java	2011-07-12 16:56:06.754260831 +0100
@@ -1145,7 +1145,7 @@
             Object[] result = new Object[size];
             Iterator<Map.Entry<K,V>> it = iterator();
             for (int i = 0; i < size; i++)
-                result[i] = new AbstractMap.SimpleEntry<>(it.next());
+                result[i] = new AbstractMap.SimpleEntry<K,V>(it.next());
             return result;
         }
 
@@ -1157,7 +1157,7 @@
                     .newInstance(a.getClass().getComponentType(), size);
             Iterator<Map.Entry<K,V>> it = iterator();
             for (int i = 0; i < size; i++)
-                a[i] = (T) new AbstractMap.SimpleEntry<>(it.next());
+                a[i] = (T) new AbstractMap.SimpleEntry<K,V>(it.next());
             if (a.length > size)
                 a[size] = null;
             return a;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/JumboEnumSet.java openjdk-boot/jdk/src/share/classes/java/util/JumboEnumSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/JumboEnumSet.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/JumboEnumSet.java	2011-07-12 16:56:06.754260831 +0100
@@ -91,7 +91,7 @@
      * @return an iterator over the elements contained in this set
      */
     public Iterator<E> iterator() {
-        return new EnumSetIterator<>();
+        return new EnumSetIterator<E>();
     }
 
     private class EnumSetIterator<E extends Enum<E>> implements Iterator<E> {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/LinkedHashMap.java openjdk-boot/jdk/src/share/classes/java/util/LinkedHashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/LinkedHashMap.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/LinkedHashMap.java	2011-07-12 16:56:06.754260831 +0100
@@ -237,7 +237,7 @@
      * the chain.
      */
     void init() {
-        header = new Entry<>(-1, null, null, null);
+        header = new Entry<K,V>(-1, null, null, null);
         header.before = header.after = header;
     }
 
@@ -438,7 +438,7 @@
      */
     void createEntry(int hash, K key, V value, int bucketIndex) {
         HashMap.Entry<K,V> old = table[bucketIndex];
-        Entry<K,V> e = new Entry<>(hash, key, value, old);
+        Entry<K,V> e = new Entry<K,V>(hash, key, value, old);
         table[bucketIndex] = e;
         e.addBefore(header);
         size++;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/LinkedList.java openjdk-boot/jdk/src/share/classes/java/util/LinkedList.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/LinkedList.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/LinkedList.java	2011-07-12 16:56:06.754260831 +0100
@@ -122,7 +122,7 @@
      */
     private void linkFirst(E e) {
         final Node<E> f = first;
-        final Node<E> newNode = new Node<>(null, e, f);
+        final Node<E> newNode = new Node<E>(null, e, f);
         first = newNode;
         if (f == null)
             last = newNode;
@@ -137,7 +137,7 @@
      */
     void linkLast(E e) {
         final Node<E> l = last;
-        final Node<E> newNode = new Node<>(l, e, null);
+        final Node<E> newNode = new Node<E>(l, e, null);
         last = newNode;
         if (l == null)
             first = newNode;
@@ -153,7 +153,7 @@
     void linkBefore(E e, Node<E> succ) {
         // assert succ != null;
         final Node<E> pred = succ.prev;
-        final Node<E> newNode = new Node<>(pred, e, succ);
+        final Node<E> newNode = new Node<E>(pred, e, succ);
         succ.prev = newNode;
         if (pred == null)
             first = newNode;
@@ -419,7 +419,7 @@
 
         for (Object o : a) {
             @SuppressWarnings("unchecked") E e = (E) o;
-            Node<E> newNode = new Node<>(pred, e, null);
+            Node<E> newNode = new Node<E>(pred, e, null);
             if (pred == null)
                 first = newNode;
             else
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/ListResourceBundle.java openjdk-boot/jdk/src/share/classes/java/util/ListResourceBundle.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/ListResourceBundle.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/ListResourceBundle.java	2011-07-12 16:56:06.754260831 +0100
@@ -187,7 +187,7 @@
             return;
 
         Object[][] contents = getContents();
-        HashMap<String,Object> temp = new HashMap<>(contents.length);
+        HashMap<String,Object> temp = new HashMap<String,Object>(contents.length);
         for (int i = 0; i < contents.length; ++i) {
             // key must be non-null String, value must be non-null
             String key = (String) contents[i][0];
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Locale.java openjdk-boot/jdk/src/share/classes/java/util/Locale.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Locale.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Locale.java	2011-07-12 16:56:06.818261891 +0100
@@ -1793,7 +1793,7 @@
                 return formatList(variantNames, listPattern, listCompositionPattern);
             }
         }
-        ArrayList<String> names = new ArrayList<>(4);
+        ArrayList<String> names = new ArrayList<String>(4);
         if (languageName.length() != 0) {
             names.add(languageName);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/FileHandler.java openjdk-boot/jdk/src/share/classes/java/util/logging/FileHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/FileHandler.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/FileHandler.java	2011-07-12 16:56:06.754260831 +0100
@@ -127,7 +127,7 @@
     private FileOutputStream lockStream;
     private File files[];
     private static final int MAX_LOCKS = 100;
-    private static java.util.HashMap<String, String> locks = new java.util.HashMap<>();
+    private static java.util.HashMap<String, String> locks = new java.util.HashMap<String, String>();
 
     // A metered stream is a subclass of OutputStream that
     //   (a) forwards all its output to a target stream
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Level.java openjdk-boot/jdk/src/share/classes/java/util/logging/Level.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Level.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/Level.java	2011-07-12 16:56:06.754260831 +0100
@@ -59,7 +59,7 @@
  */
 
 public class Level implements java.io.Serializable {
-    private static java.util.ArrayList<Level> known = new java.util.ArrayList<>();
+    private static java.util.ArrayList<Level> known = new java.util.ArrayList<Level>();
     private static String defaultBundle = "sun.util.logging.resources.logging";
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Logger.java openjdk-boot/jdk/src/share/classes/java/util/logging/Logger.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Logger.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/Logger.java	2011-07-12 16:56:06.754260831 +0100
@@ -170,7 +170,7 @@
     private LogManager manager;
     private String name;
     private final CopyOnWriteArrayList<Handler> handlers =
-        new CopyOnWriteArrayList<>();
+        new CopyOnWriteArrayList<Handler>();
     private String resourceBundleName;
     private volatile boolean useParentHandlers = true;
     private volatile Filter filter;
@@ -1439,7 +1439,7 @@
             // Set our new parent.
             parent = newParent;
             if (parent.kids == null) {
-                parent.kids = new ArrayList<>(2);
+                parent.kids = new ArrayList<LogManager.LoggerWeakRef>(2);
             }
             if (ref == null) {
                 // we didn't have a previous parent
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Logging.java openjdk-boot/jdk/src/share/classes/java/util/logging/Logging.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Logging.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/Logging.java	2011-07-12 16:56:06.754260831 +0100
@@ -56,7 +56,7 @@
 
     public List<String> getLoggerNames() {
         Enumeration loggers = logManager.getLoggerNames();
-        ArrayList<String> array = new ArrayList<>();
+        ArrayList<String> array = new ArrayList<String>();
 
         for (; loggers.hasMoreElements();) {
             array.add((String) loggers.nextElement());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/LogManager.java openjdk-boot/jdk/src/share/classes/java/util/logging/LogManager.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/LogManager.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/LogManager.java	2011-07-12 16:56:06.754260831 +0100
@@ -156,7 +156,8 @@
     private final static Level defaultLevel = Level.INFO;
 
     // Table of named Loggers that maps names to Loggers.
-    private Hashtable<String,LoggerWeakRef> namedLoggers = new Hashtable<>();
+    private Hashtable<String,LoggerWeakRef> namedLoggers =
+        new Hashtable<String,LoggerWeakRef>();
     // Tree of named Loggers
     private LogNode root = new LogNode(null);
     private Logger rootLogger;
@@ -444,7 +445,7 @@
     // loggerRefQueue holds LoggerWeakRef objects for Logger objects
     // that have been GC'ed.
     private final ReferenceQueue<Logger> loggerRefQueue
-        = new ReferenceQueue<>();
+        = new ReferenceQueue<Logger>();
 
     // Package-level inner class.
     // Helper class for managing WeakReferences to Logger objects.
@@ -694,7 +695,7 @@
                 name = "";
             }
             if (node.children == null) {
-                node.children = new HashMap<>();
+                node.children = new HashMap<String,LogNode>();
             }
             LogNode child = node.children.get(head);
             if (child == null) {
@@ -878,7 +879,7 @@
         }
         hands = hands.trim();
         int ix = 0;
-        Vector<String> result = new Vector<>();
+        Vector<String> result = new Vector<String>();
         while (ix < hands.length()) {
             int end = ix;
             while (end < hands.length()) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/LogRecord.java openjdk-boot/jdk/src/share/classes/java/util/logging/LogRecord.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/LogRecord.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/LogRecord.java	2011-07-12 16:56:06.754260831 +0100
@@ -85,7 +85,8 @@
     private static final AtomicInteger nextThreadId
         = new AtomicInteger(MIN_SEQUENTIAL_THREAD_ID);
 
-    private static final ThreadLocal<Integer> threadIds = new ThreadLocal<>();
+    private static final ThreadLocal<Integer> threadIds
+        = new ThreadLocal<Integer>();
 
     /**
      * @serial Logging message level
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/prefs/AbstractPreferences.java openjdk-boot/jdk/src/share/classes/java/util/prefs/AbstractPreferences.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/prefs/AbstractPreferences.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/prefs/AbstractPreferences.java	2011-07-12 16:56:06.758260897 +0100
@@ -155,7 +155,8 @@
      * All known unremoved children of this node.  (This "cache" is consulted
      * prior to calling childSpi() or getChild().
      */
-    private Map<String, AbstractPreferences> kidCache = new HashMap<>();
+    private Map<String, AbstractPreferences> kidCache
+        = new HashMap<String, AbstractPreferences>();
 
     /**
      * This field is used to keep track of whether or not this node has
@@ -712,7 +713,7 @@
             if (removed)
                 throw new IllegalStateException("Node has been removed.");
 
-            Set<String> s = new TreeSet<>(kidCache.keySet());
+            Set<String> s = new TreeSet<String>(kidCache.keySet());
             for (String kid : childrenNamesSpi())
                 s.add(kid);
             return s.toArray(EMPTY_STRING_ARRAY);
@@ -1441,7 +1442,8 @@
      * event delivery from preference activity, greatly simplifying
      * locking and reducing opportunity for deadlock.
      */
-    private static final List<EventObject> eventQueue = new LinkedList<>();
+    private static final List<EventObject> eventQueue
+        = new LinkedList<EventObject>();
 
     /**
      * These two classes are used to distinguish NodeChangeEvents on
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/PriorityQueue.java openjdk-boot/jdk/src/share/classes/java/util/PriorityQueue.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/PriorityQueue.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/PriorityQueue.java	2011-07-12 16:56:06.758260897 +0100
@@ -538,7 +538,7 @@
                     cursor--;
                 else {
                     if (forgetMeNot == null)
-                        forgetMeNot = new ArrayDeque<>();
+                        forgetMeNot = new ArrayDeque<E>();
                     forgetMeNot.add(moved);
                 }
             } else if (lastRetElt != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Properties.java openjdk-boot/jdk/src/share/classes/java/util/Properties.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Properties.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Properties.java	2011-07-12 16:56:06.758260897 +0100
@@ -1010,7 +1010,7 @@
      * @since   1.6
      */
     public Set<String> stringPropertyNames() {
-        Hashtable<String, String> h = new Hashtable<>();
+        Hashtable<String, String> h = new Hashtable<String, String>();
         enumerateStringProperties(h);
         return h.keySet();
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/regex/Pattern.java openjdk-boot/jdk/src/share/classes/java/util/regex/Pattern.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/regex/Pattern.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/regex/Pattern.java	2011-07-12 16:56:06.758260897 +0100
@@ -1193,7 +1193,7 @@
     public String[] split(CharSequence input, int limit) {
         int index = 0;
         boolean matchLimited = limit > 0;
-        ArrayList<String> matchList = new ArrayList<>();
+        ArrayList<String> matchList = new ArrayList<String>();
         Matcher m = matcher(input);
 
         // Add segments before each match found
@@ -1695,7 +1695,7 @@
 
     Map<String, Integer> namedGroups() {
         if (namedGroups == null)
-            namedGroups = new HashMap<>(2);
+            namedGroups = new HashMap<String, Integer>(2);
         return namedGroups;
     }
 
@@ -5495,7 +5495,7 @@
         }
 
         private static final HashMap<String, CharPropertyFactory> map
-            = new HashMap<>();
+            = new HashMap<String, CharPropertyFactory>();
 
         static {
             // Unicode character property aliases, defined in
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/regex/UnicodeProp.java openjdk-boot/jdk/src/share/classes/java/util/regex/UnicodeProp.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/regex/UnicodeProp.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/regex/UnicodeProp.java	2011-07-12 16:56:06.818261891 +0100
@@ -193,8 +193,8 @@
         }
     };
 
-    private final static HashMap<String, String> posix = new HashMap<>();
-    private final static HashMap<String, String> aliases = new HashMap<>();
+    private final static HashMap<String, String> posix = new HashMap<String,String>();
+    private final static HashMap<String, String> aliases = new HashMap<String,String>();
     static {
         posix.put("ALPHA", "ALPHABETIC");
         posix.put("LOWER", "LOWERCASE");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/RegularEnumSet.java openjdk-boot/jdk/src/share/classes/java/util/RegularEnumSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/RegularEnumSet.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/RegularEnumSet.java	2011-07-12 16:56:06.758260897 +0100
@@ -72,7 +72,7 @@
      * @return an iterator over the elements contained in this set
      */
     public Iterator<E> iterator() {
-        return new EnumSetIterator<>();
+        return new EnumSetIterator<E>();
     }
 
     private class EnumSetIterator<E extends Enum<E>> implements Iterator<E> {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/ResourceBundle.java openjdk-boot/jdk/src/share/classes/java/util/ResourceBundle.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/ResourceBundle.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/ResourceBundle.java	2011-07-12 16:56:06.818261891 +0100
@@ -289,7 +289,7 @@
      * name for compatibility with some workarounds for bug 4212439.
      */
     private static final ConcurrentMap<CacheKey, BundleReference> cacheList
-        = new ConcurrentHashMap<>(INITIAL_CACHE_SIZE);
+      = new ConcurrentHashMap<CacheKey,BundleReference>(INITIAL_CACHE_SIZE);
 
     /**
      * Queue for reference objects referring to class loaders or bundles.
@@ -1754,7 +1754,7 @@
      * @since 1.6
      */
     public Set<String> keySet() {
-        Set<String> keys = new HashSet<>();
+        Set<String> keys = new HashSet<String>();
         for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
             keys.addAll(rb.handleKeySet());
         }
@@ -1782,7 +1782,7 @@
         if (keySet == null) {
             synchronized (this) {
                 if (keySet == null) {
-                    Set<String> keys = new HashSet<>();
+                    Set<String> keys = new HashSet<String>();
                     Enumeration<String> enumKeys = getKeys();
                     while (enumKeys.hasMoreElements()) {
                         String key = enumKeys.nextElement();
@@ -2300,7 +2300,7 @@
             if (baseName == null) {
                 throw new NullPointerException();
             }
-            return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));
+            return new ArrayList<Locale>(CANDIDATES_CACHE.get(locale.getBaseLocale()));
         }
 
         private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();
@@ -2326,7 +2326,7 @@
                 if (language.equals("nb") || isNorwegianBokmal) {
                     List<Locale> tmpList = getDefaultList("nb", script, region, variant);
                     // Insert a locale replacing "nb" with "no" for every list entry
-                    List<Locale> bokmalList = new LinkedList<>();
+                    List<Locale> bokmalList = new LinkedList<Locale>();
                     for (Locale l : tmpList) {
                         bokmalList.add(l);
                         if (l.getLanguage().length() == 0) {
@@ -2373,7 +2373,7 @@
                 List<String> variants = null;
 
                 if (variant.length() > 0) {
-                    variants = new LinkedList<>();
+                    variants = new LinkedList<String>();
                     int idx = variant.length();
                     while (idx != -1) {
                         variants.add(variant.substring(0, idx));
@@ -2381,7 +2381,7 @@
                     }
                 }
 
-                List<Locale> list = new LinkedList<>();
+                List<Locale> list = new LinkedList<Locale>();
 
                 if (variants != null) {
                     for (String v : variants) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/ServiceLoader.java openjdk-boot/jdk/src/share/classes/java/util/ServiceLoader.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/ServiceLoader.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/ServiceLoader.java	2011-07-12 16:56:06.758260897 +0100
@@ -191,7 +191,7 @@
     private ClassLoader loader;
 
     // Cached providers, in instantiation order
-    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();
+    private LinkedHashMap<String,S> providers = new LinkedHashMap<String,S>();
 
     // The current lazy-lookup iterator
     private LazyIterator lookupIterator;
@@ -291,7 +291,7 @@
     {
         InputStream in = null;
         BufferedReader r = null;
-        ArrayList<String> names = new ArrayList<>();
+        ArrayList<String> names = new ArrayList<String>();
         try {
             in = u.openStream();
             r = new BufferedReader(new InputStreamReader(in, "utf-8"));
@@ -463,7 +463,7 @@
     public static <S> ServiceLoader<S> load(Class<S> service,
                                             ClassLoader loader)
     {
-        return new ServiceLoader<>(service, loader);
+        return new ServiceLoader<S>(service, loader);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/TimSort.java openjdk-boot/jdk/src/share/classes/java/util/TimSort.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/TimSort.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/TimSort.java	2011-07-12 16:56:06.758260897 +0100
@@ -196,7 +196,7 @@
          * extending short natural runs to minRun elements, and merging runs
          * to maintain stack invariant.
          */
-        TimSort<T> ts = new TimSort<>(a, c);
+        TimSort<T> ts = new TimSort<T>(a, c);
         int minRun = minRunLength(nRemaining);
         do {
             // Identify next run
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/TreeMap.java openjdk-boot/jdk/src/share/classes/java/util/TreeMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/TreeMap.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/TreeMap.java	2011-07-12 16:56:06.758260897 +0100
@@ -530,7 +530,7 @@
         if (t == null) {
             compare(key, key); // type (and possibly null) check
 
-            root = new Entry<>(key, value, null);
+            root = new Entry<K,V>(key, value, null);
             size = 1;
             modCount++;
             return null;
@@ -566,7 +566,7 @@
                     return t.setValue(value);
             } while (t != null);
         }
-        Entry<K,V> e = new Entry<>(key, value, parent);
+        Entry<K,V> e = new Entry<K,V>(key, value, parent);
         if (cmp < 0)
             parent.left = e;
         else
@@ -1066,14 +1066,14 @@
         }
         public NavigableSet<E> subSet(E fromElement, boolean fromInclusive,
                                       E toElement,   boolean toInclusive) {
-            return new KeySet<>(m.subMap(fromElement, fromInclusive,
+            return new KeySet<E>(m.subMap(fromElement, fromInclusive,
                                           toElement,   toInclusive));
         }
         public NavigableSet<E> headSet(E toElement, boolean inclusive) {
-            return new KeySet<>(m.headMap(toElement, inclusive));
+            return new KeySet<E>(m.headMap(toElement, inclusive));
         }
         public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
-            return new KeySet<>(m.tailMap(fromElement, inclusive));
+            return new KeySet<E>(m.tailMap(fromElement, inclusive));
         }
         public SortedSet<E> subSet(E fromElement, E toElement) {
             return subSet(fromElement, true, toElement, false);
@@ -1202,7 +1202,7 @@
      */
     static <K,V> Map.Entry<K,V> exportEntry(TreeMap.Entry<K,V> e) {
         return (e == null) ? null :
-            new AbstractMap.SimpleImmutableEntry<>(e);
+            new AbstractMap.SimpleImmutableEntry<K,V>(e);
     }
 
     /**
@@ -2403,7 +2403,7 @@
             value = (defaultVal != null ? defaultVal : (V) str.readObject());
         }
 
-        Entry<K,V> middle =  new Entry<>(key, value, null);
+        Entry<K,V> middle =  new Entry<K,V>(key, value, null);
 
         // color nodes in non-full bottommost level red
         if (level == redLevel)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/TreeSet.java openjdk-boot/jdk/src/share/classes/java/util/TreeSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/TreeSet.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/TreeSet.java	2011-07-12 16:56:06.758260897 +0100
@@ -138,7 +138,7 @@
      *        ordering} of the elements will be used.
      */
     public TreeSet(Comparator<? super E> comparator) {
-        this(new TreeMap<>(comparator));
+        this(new TreeMap<E,Object>(comparator));
     }
 
     /**
@@ -195,7 +195,7 @@
      * @since 1.6
      */
     public NavigableSet<E> descendingSet() {
-        return new TreeSet<>(m.descendingMap());
+        return new TreeSet<E>(m.descendingMap());
     }
 
     /**
@@ -322,7 +322,7 @@
      */
     public NavigableSet<E> subSet(E fromElement, boolean fromInclusive,
                                   E toElement,   boolean toInclusive) {
-        return new TreeSet<>(m.subMap(fromElement, fromInclusive,
+        return new TreeSet<E>(m.subMap(fromElement, fromInclusive,
                                        toElement,   toInclusive));
     }
 
@@ -335,7 +335,7 @@
      * @since 1.6
      */
     public NavigableSet<E> headSet(E toElement, boolean inclusive) {
-        return new TreeSet<>(m.headMap(toElement, inclusive));
+        return new TreeSet<E>(m.headMap(toElement, inclusive));
     }
 
     /**
@@ -347,7 +347,7 @@
      * @since 1.6
      */
     public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
-        return new TreeSet<>(m.tailMap(fromElement, inclusive));
+        return new TreeSet<E>(m.tailMap(fromElement, inclusive));
     }
 
     /**
@@ -477,7 +477,7 @@
             throw new InternalError();
         }
 
-        clone.m = new TreeMap<>(m);
+        clone.m = new TreeMap<E,Object>(m);
         return clone;
     }
 
@@ -524,9 +524,9 @@
         // Create backing TreeMap
         TreeMap<E,Object> tm;
         if (c==null)
-            tm = new TreeMap<>();
+            tm = new TreeMap<E,Object>();
         else
-            tm = new TreeMap<>(c);
+            tm = new TreeMap<E,Object>(c);
         m = tm;
 
         // Read in size
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/WeakHashMap.java openjdk-boot/jdk/src/share/classes/java/util/WeakHashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/WeakHashMap.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/WeakHashMap.java	2011-07-12 16:56:06.762260963 +0100
@@ -171,7 +171,7 @@
     /**
      * Reference queue for cleared WeakEntries
      */
-    private final ReferenceQueue<Object> queue = new ReferenceQueue<>();
+    private final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();
 
     /**
      * The number of times this WeakHashMap has been structurally modified.
@@ -439,7 +439,7 @@
 
         modCount++;
         Entry<K,V> e = tab[i];
-        tab[i] = new Entry<>(k, value, queue, h, e);
+        tab[i] = new Entry<K,V>(k, value, queue, h, e);
         if (++size >= threshold)
             resize(tab.length * 2);
         return null;
@@ -955,9 +955,10 @@
         }
 
         private List<Map.Entry<K,V>> deepCopy() {
-            List<Map.Entry<K,V>> list = new ArrayList<>(size());
+            List<Map.Entry<K,V>> list =
+                new ArrayList<Map.Entry<K,V>>(size());
             for (Map.Entry<K,V> e : this)
-                list.add(new AbstractMap.SimpleEntry<>(e));
+                list.add(new AbstractMap.SimpleEntry<K,V>(e));
             return list;
         }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/zip/ZipFile.java openjdk-boot/jdk/src/share/classes/java/util/zip/ZipFile.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/zip/ZipFile.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/zip/ZipFile.java	2011-07-12 16:56:06.762260963 +0100
@@ -319,7 +319,7 @@
 
     // the outstanding inputstreams that need to be closed,
     // mapped to the inflater objects they use.
-    private final Map<InputStream, Inflater> streams = new WeakHashMap<>();
+    private final Map<InputStream, Inflater> streams = new WeakHashMap<InputStream,Inflater>();
 
     /**
      * Returns an input stream for reading the contents of the specified
@@ -461,7 +461,7 @@
     }
 
     // List of available Inflater objects for decompression
-    private Deque<Inflater> inflaterCache = new ArrayDeque<>();
+    private Deque<Inflater> inflaterCache = new ArrayDeque<Inflater>();
 
     /**
      * Returns the path name of the ZIP file.
@@ -577,7 +577,7 @@
             // Close streams, release their inflaters
             synchronized (streams) {
                 if (false == streams.isEmpty()) {
-                    Map<InputStream, Inflater> copy = new HashMap<>(streams);
+                    Map<InputStream, Inflater> copy = new HashMap<InputStream,Inflater>(streams);
                     streams.clear();
                     for (Map.Entry<InputStream, Inflater> e : copy.entrySet()) {
                         e.getKey().close();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/zip/ZipOutputStream.java openjdk-boot/jdk/src/share/classes/java/util/zip/ZipOutputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/zip/ZipOutputStream.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/zip/ZipOutputStream.java	2011-07-12 16:56:06.762260963 +0100
@@ -53,8 +53,8 @@
     }
 
     private XEntry current;
-    private Vector<XEntry> xentries = new Vector<>();
-    private HashSet<String> names = new HashSet<>();
+    private Vector<XEntry> xentries = new Vector<XEntry>();
+    private HashSet<String> names = new HashSet<String>();
     private CRC32 crc = new CRC32();
     private long written = 0;
     private long locoff = 0;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/kerberos/DelegationPermission.java openjdk-boot/jdk/src/share/classes/javax/security/auth/kerberos/DelegationPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/kerberos/DelegationPermission.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/security/auth/kerberos/DelegationPermission.java	2011-07-12 16:56:06.762260963 +0100
@@ -361,7 +361,7 @@
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
-        Vector<Permission> permissions = new Vector<>(perms.size());
+        Vector<Permission> permissions = new Vector<Permission>(perms.size());
 
         synchronized (this) {
             permissions.addAll(perms);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/kerberos/ServicePermission.java openjdk-boot/jdk/src/share/classes/javax/security/auth/kerberos/ServicePermission.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/kerberos/ServicePermission.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/security/auth/kerberos/ServicePermission.java	2011-07-12 16:56:06.762260963 +0100
@@ -569,7 +569,7 @@
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
-        Vector<Permission> permissions = new Vector<>(perms.size());
+        Vector<Permission> permissions = new Vector<Permission>(perms.size());
 
         synchronized (this) {
             permissions.addAll(perms);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/PrivateCredentialPermission.java openjdk-boot/jdk/src/share/classes/javax/security/auth/PrivateCredentialPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/PrivateCredentialPermission.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/security/auth/PrivateCredentialPermission.java	2011-07-12 16:56:06.762260963 +0100
@@ -329,7 +329,7 @@
             throw new IllegalArgumentException("invalid empty name");
         }
 
-        ArrayList<CredOwner> pList = new ArrayList<>();
+        ArrayList<CredOwner> pList = new ArrayList<CredOwner>();
         StringTokenizer tokenizer = new StringTokenizer(name, " ", true);
         String principalClass = null;
         String principalName = null;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/SubjectDomainCombiner.java openjdk-boot/jdk/src/share/classes/javax/security/auth/SubjectDomainCombiner.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/SubjectDomainCombiner.java	2011-06-11 00:38:08.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/security/auth/SubjectDomainCombiner.java	2011-07-12 16:56:06.762260963 +0100
@@ -48,7 +48,7 @@
 
     private Subject subject;
     private WeakKeyValueMap<ProtectionDomain, ProtectionDomain> cachedPDs =
-                new WeakKeyValueMap<>();
+        new WeakKeyValueMap<ProtectionDomain, ProtectionDomain>();
     private Set<Principal> principalSet;
     private Principal[] principals;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/invoke/util/ValueConversions.java openjdk-boot/jdk/src/share/classes/sun/invoke/util/ValueConversions.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/invoke/util/ValueConversions.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/invoke/util/ValueConversions.java	2011-07-12 16:56:06.818261891 +0100
@@ -59,7 +59,7 @@
         EnumMap<Wrapper, MethodHandle>[] caches
                 = (EnumMap<Wrapper, MethodHandle>[]) new EnumMap[n];  // unchecked warning expected here
         for (int i = 0; i < n; i++)
-            caches[i] = new EnumMap<>(Wrapper.class);
+            caches[i] = new EnumMap<Wrapper, MethodHandle>(Wrapper.class);
         return caches;
     }
 
@@ -1013,7 +1013,7 @@
                                   Object a8, Object a9)
                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
     private static MethodHandle[] makeArrays() {
-        ArrayList<MethodHandle> mhs = new ArrayList<>();
+        ArrayList<MethodHandle> mhs = new ArrayList<MethodHandle>();
         for (;;) {
             MethodHandle mh = findCollector("array", mhs.size(), Object[].class);
             if (mh == null)  break;
@@ -1059,7 +1059,7 @@
                                   Object a8, Object a9)
                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }
     private static MethodHandle[] makeFillArrays() {
-        ArrayList<MethodHandle> mhs = new ArrayList<>();
+        ArrayList<MethodHandle> mhs = new ArrayList<MethodHandle>();
         mhs.add(null);  // there is no empty fill; at least a0 is required
         for (;;) {
             MethodHandle mh = findCollector("fillArray", mhs.size(), Object[].class, Object[].class, Integer.class);
@@ -1214,7 +1214,7 @@
                                      Object a8, Object a9)
                 { return makeList(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
     private static MethodHandle[] makeLists() {
-        ArrayList<MethodHandle> mhs = new ArrayList<>();
+        ArrayList<MethodHandle> mhs = new ArrayList<MethodHandle>();
         for (;;) {
             MethodHandle mh = findCollector("list", mhs.size(), List.class);
             if (mh == null)  break;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/io/CharacterEncoding.java openjdk-boot/jdk/src/share/classes/sun/io/CharacterEncoding.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/io/CharacterEncoding.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/io/CharacterEncoding.java	2011-07-12 16:56:06.762260963 +0100
@@ -54,7 +54,7 @@
     private static volatile boolean installedAll;
 
     static {
-        aliasTable = new HashMap<>(460, 1.0f);                    /* MDA */
+        aliasTable = new HashMap<String,String>(460, 1.0f);                    /* MDA */
 
         aliasTable.put("us-ascii",              "ASCII");
         aliasTable.put("ascii",                 "ASCII");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/io/Converters.java openjdk-boot/jdk/src/share/classes/sun/io/Converters.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/io/Converters.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/io/Converters.java	2011-07-12 16:56:06.762260963 +0100
@@ -120,7 +120,7 @@
 
     private static Class<?> cache(int type, Object encoding, Class<?> c) {
         SoftReference<Object[]>[] srs = classCache[type];
-        srs[CACHE_SIZE - 1] = new SoftReference<>(new Object[] { c, encoding });
+        srs[CACHE_SIZE - 1] = new SoftReference<Object[]>(new Object[] { c, encoding });
         moveToFront(srs, CACHE_SIZE - 1);
         return c;
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/launcher/LauncherHelper.java openjdk-boot/jdk/src/share/classes/sun/launcher/LauncherHelper.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/launcher/LauncherHelper.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/launcher/LauncherHelper.java	2011-07-12 16:56:06.762260963 +0100
@@ -169,7 +169,7 @@
     private static void printProperties(PrintStream ostream) {
         Properties p = System.getProperties();
         ostream.println(PROP_SETTINGS);
-        List<String> sortedPropertyKeys = new ArrayList<>();
+        List<String> sortedPropertyKeys = new ArrayList<String>();
         sortedPropertyKeys.addAll(p.stringPropertyNames());
         Collections.sort(sortedPropertyKeys);
         for (String x : sortedPropertyKeys) {
@@ -244,7 +244,7 @@
         }
         // Locale does not implement Comparable so we convert it to String
         // and sort it for pretty printing.
-        Set<String> sortedSet = new TreeSet<>();
+        Set<String> sortedSet = new TreeSet<String>();
         for (Locale l : tlocales) {
             sortedSet.add(l.toString());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/ManagementFactoryHelper.java openjdk-boot/jdk/src/share/classes/sun/management/ManagementFactoryHelper.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/ManagementFactoryHelper.java	2011-06-11 00:38:09.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/ManagementFactoryHelper.java	2011-07-12 16:56:06.818261891 +0100
@@ -204,7 +204,7 @@
     private static List<BufferPoolMXBean> bufferPools = null;
     public static synchronized List<BufferPoolMXBean> getBufferPoolMXBeans() {
         if (bufferPools == null) {
-            bufferPools = new ArrayList<>(2);
+            bufferPools = new ArrayList<BufferPoolMXBean>(2);
             bufferPools.add(createBufferPoolMXBean(sun.misc.SharedSecrets.getJavaNioAccess()
                 .getDirectBufferPool()));
             bufferPools.add(createBufferPoolMXBean(sun.nio.ch.FileChannelImpl
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/spi/nameservice/dns/DNSNameService.java openjdk-boot/jdk/src/share/classes/sun/net/spi/nameservice/dns/DNSNameService.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/spi/nameservice/dns/DNSNameService.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/spi/nameservice/dns/DNSNameService.java	2011-07-12 16:56:06.762260963 +0100
@@ -52,7 +52,7 @@
 
     // Per-thread soft cache of the last temporary context
     private static ThreadLocal<SoftReference<ThreadContext>> contextRef =
-            new ThreadLocal<>();
+            new ThreadLocal<SoftReference<ThreadContext>>();
 
     // Simple class to encapsulate the temporary context
     private static class ThreadContext {
@@ -99,7 +99,7 @@
 
         // new thread context needs to be created
         if (thrCtxt == null) {
-            final Hashtable<String,Object> env = new Hashtable<>();
+            final Hashtable<String,Object> env = new Hashtable<String,Object>();
             env.put("java.naming.factory.initial",
                     "com.sun.jndi.dns.DnsContextFactory");
 
@@ -165,7 +165,7 @@
                                       final String[] ids, int depth)
             throws UnknownHostException
     {
-        ArrayList<String> results = new ArrayList<>();
+        ArrayList<String> results = new ArrayList<String>();
         Attributes attrs;
 
         // do the query
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java	2011-07-12 16:56:06.762260963 +0100
@@ -111,7 +111,7 @@
      * at the same time, then all but the first will block until
      * the first completes its authentication.
      */
-    static private HashMap<String,Thread> requests = new HashMap<>();
+    static private HashMap<String,Thread> requests = new HashMap<String,Thread>();
 
     /* check if a request for this destination is in progress
      * return false immediately if not. Otherwise block until
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/cs/AbstractCharsetProvider.java openjdk-boot/jdk/src/share/classes/sun/nio/cs/AbstractCharsetProvider.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/cs/AbstractCharsetProvider.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/cs/AbstractCharsetProvider.java	2011-07-12 16:56:06.762260963 +0100
@@ -49,22 +49,22 @@
     /* Maps canonical names to class names
      */
     private Map<String,String> classMap
-        = new TreeMap<>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
+        = new TreeMap<String,String>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
 
     /* Maps alias names to canonical names
      */
     private Map<String,String> aliasMap
-        = new TreeMap<>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
+        = new TreeMap<String,String>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
 
     /* Maps canonical names to alias-name arrays
      */
     private Map<String,String[]> aliasNameMap
-        = new TreeMap<>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
+        = new TreeMap<String,String[]>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
 
     /* Maps canonical names to soft references that hold cached instances
      */
     private Map<String,SoftReference<Charset>> cache
-        = new TreeMap<>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
+        = new TreeMap<String,SoftReference<Charset>>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
 
     private String packagePrefix;
 
@@ -167,7 +167,7 @@
         final ArrayList<String> ks;
         synchronized (this) {
             init();
-            ks = new ArrayList<>(classMap.keySet());
+            ks = new ArrayList<String>(classMap.keySet());
         }
 
         return new Iterator<Charset>() {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractAclFileAttributeView.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractAclFileAttributeView.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractAclFileAttributeView.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractAclFileAttributeView.java	2011-07-12 16:56:06.762260963 +0100
@@ -84,7 +84,7 @@
             throw new IllegalArgumentException("'" + name() + ":" +
                 attribute + "' not recognized");
         }
-        Map<String,Object> result = new HashMap<>(2);
+        Map<String,Object> result = new HashMap<String,Object>(2);
         if (acl)
             result.put(ACL_NAME, getAcl());
         if (owner)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java	2011-07-12 16:56:06.762260963 +0100
@@ -89,8 +89,8 @@
      * Used to build a map of attribute name/values.
      */
     static class AttributesBuilder {
-        private Set<String> names = new HashSet<>();
-        private Map<String,Object> map = new HashMap<>();
+        private Set<String> names = new HashSet<String>();
+        private Map<String,Object> map = new HashMap<String,Object>();
         private boolean copyAll;
 
         private AttributesBuilder(Set<String> allowed, String[] requested) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractPoller.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractPoller.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractPoller.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractPoller.java	2011-07-12 16:56:06.762260963 +0100
@@ -102,7 +102,7 @@
             throw new NullPointerException();
         if (events.length == 0)
             throw new IllegalArgumentException("No events to register");
-        Set<WatchEvent.Kind<?>> eventSet = new HashSet<>(events.length);
+        Set<WatchEvent.Kind<?>> eventSet = new HashSet<WatchEvent.Kind<?>>(events.length);
         for (WatchEvent.Kind<?> event: events) {
             // standard events
             if (event == StandardWatchEventKinds.ENTRY_CREATE ||
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java	2011-07-12 16:56:06.762260963 +0100
@@ -77,7 +77,7 @@
         throws IOException
     {
         // names of attributes to return
-        List<String> names = new ArrayList<>();
+        List<String> names = new ArrayList<String>();
         for (String name: attributes) {
             if (name.equals("*")) {
                 names = list();
@@ -90,7 +90,7 @@
         }
 
         // read each value and return in map
-        Map<String,Object> result = new HashMap<>();
+        Map<String,Object> result = new HashMap<String,Object>();
         for (String name: names) {
             int size = size(name);
             byte[] buf = new byte[size];
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java	2011-07-12 16:56:06.762260963 +0100
@@ -71,7 +71,7 @@
 
     @Override
     public Map<String,Object> readAttributes(String[] attributes) throws IOException {
-        Map<String,Object> result = new HashMap<>();
+        Map<String,Object> result = new HashMap<String,Object>();
         for (String attribute: attributes) {
             if (attribute.equals("*") || attribute.equals(OWNER_NAME)) {
                 result.put(OWNER_NAME, getOwner());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/Util.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/Util.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/Util.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/Util.java	2011-07-12 16:56:06.762260963 +0100
@@ -63,7 +63,7 @@
      * Returns a Set containing the given elements.
      */
     static <E> Set<E> newSet(E... elements) {
-        HashSet<E> set = new HashSet<>();
+        HashSet<E> set = new HashSet<E>();
         for (E e: elements) {
             set.add(e);
         }
@@ -75,7 +75,7 @@
      * the given elements.
      */
     static <E> Set<E> newSet(Set<E> other, E... elements) {
-        HashSet<E> set = new HashSet<>(other);
+        HashSet<E> set = new HashSet<E>(other);
         for (E e: elements) {
             set.add(e);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/Activation.java openjdk-boot/jdk/src/share/classes/sun/rmi/server/Activation.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/Activation.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/server/Activation.java	2011-07-12 16:56:06.862262617 +0100
@@ -149,10 +149,10 @@
 
     /** maps activation id to its respective group id */
     private Map<ActivationID,ActivationGroupID> idTable =
-        new ConcurrentHashMap<>();
+        new ConcurrentHashMap<ActivationID,ActivationGroupID>();
     /** maps group id to its GroupEntry groups */
     private Map<ActivationGroupID,GroupEntry> groupTable =
-        new ConcurrentHashMap<>();
+        new ConcurrentHashMap<ActivationGroupID,GroupEntry>();
 
     private byte majorVersion = MAJOR_VERSION;
     private byte minorVersion = MINOR_VERSION;
@@ -288,10 +288,10 @@
     {
         ois.defaultReadObject();
         if (! (groupTable instanceof ConcurrentHashMap)) {
-            groupTable = new ConcurrentHashMap<>(groupTable);
+            groupTable = new ConcurrentHashMap<ActivationGroupID,GroupEntry>(groupTable);
         }
         if (! (idTable instanceof ConcurrentHashMap)) {
-            idTable = new ConcurrentHashMap<>(idTable);
+            idTable = new ConcurrentHashMap<ActivationID,ActivationGroupID>(idTable);
         }
     }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/AclEntryImpl.java openjdk-boot/jdk/src/share/classes/sun/security/acl/AclEntryImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/AclEntryImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/acl/AclEntryImpl.java	2011-07-12 16:56:06.766261029 +0100
@@ -37,7 +37,7 @@
  */
 public class AclEntryImpl implements AclEntry {
     private Principal user = null;
-    private Vector<Permission> permissionSet = new Vector<>(10, 10);
+    private Vector<Permission> permissionSet = new Vector<Permission>(10, 10);
     private boolean negative = false;
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/AclImpl.java openjdk-boot/jdk/src/share/classes/sun/security/acl/AclImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/AclImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/acl/AclImpl.java	2011-07-12 16:56:06.766261029 +0100
@@ -41,15 +41,15 @@
     // or principal.
     //
     private Hashtable<Principal, AclEntry> allowedUsersTable =
-                                        new Hashtable<>(23);
+        new Hashtable<Principal,AclEntry>(23);
     private Hashtable<Principal, AclEntry> allowedGroupsTable =
-                                        new Hashtable<>(23);
+        new Hashtable<Principal, AclEntry>(23);
     private Hashtable<Principal, AclEntry> deniedUsersTable =
-                                        new Hashtable<>(23);
+        new Hashtable<Principal, AclEntry>(23);
     private Hashtable<Principal, AclEntry> deniedGroupsTable =
-                                        new Hashtable<>(23);
+        new Hashtable<Principal, AclEntry>(23);
     private String aclName = null;
-    private Vector<Permission> zeroSet = new Vector<>(1,1);
+    private Vector<Permission> zeroSet = new Vector<Permission>(1,1);
 
 
     /**
@@ -294,7 +294,7 @@
     //
     private static Enumeration<Permission> union(Enumeration<Permission> e1,
                 Enumeration<Permission> e2) {
-        Vector<Permission> v = new Vector<>(20, 20);
+        Vector<Permission> v = new Vector<Permission>(20, 20);
 
         while (e1.hasMoreElements())
             v.addElement(e1.nextElement());
@@ -313,7 +313,7 @@
     //
     private Enumeration<Permission> subtract(Enumeration<Permission> e1,
                 Enumeration<Permission> e2) {
-        Vector<Permission> v = new Vector<>(20, 20);
+        Vector<Permission> v = new Vector<Permission>(20, 20);
 
         while (e1.hasMoreElements())
             v.addElement(e1.nextElement());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/GroupImpl.java openjdk-boot/jdk/src/share/classes/sun/security/acl/GroupImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/GroupImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/acl/GroupImpl.java	2011-07-12 16:56:06.766261029 +0100
@@ -34,7 +34,7 @@
  * @author      Satish Dharmaraj
  */
 public class GroupImpl implements Group {
-    private Vector<Principal> groupMembers = new Vector<>(50, 100);
+    private Vector<Principal> groupMembers = new Vector<Principal>(50, 100);
     private String group;
 
     /**
@@ -131,7 +131,7 @@
         if (groupMembers.contains(member)) {
             return true;
         } else {
-            Vector<Group> alreadySeen = new Vector<>(10);
+            Vector<Group> alreadySeen = new Vector<Group>(10);
             return isMemberRecurse(member, alreadySeen);
         }
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/jca/ProviderList.java openjdk-boot/jdk/src/share/classes/sun/security/jca/ProviderList.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/jca/ProviderList.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/jca/ProviderList.java	2011-07-12 16:56:06.766261029 +0100
@@ -96,7 +96,7 @@
         if (providerList.getProvider(p.getName()) != null) {
             return providerList;
         }
-        List<ProviderConfig> list = new ArrayList<>
+        List<ProviderConfig> list = new ArrayList<ProviderConfig>
                                     (Arrays.asList(providerList.configs));
         int n = list.size();
         if ((position < 0) || (position > n)) {
@@ -160,7 +160,7 @@
      * Return a new ProviderList parsed from the java.security Properties.
      */
     private ProviderList() {
-        List<ProviderConfig> configList = new ArrayList<>();
+        List<ProviderConfig> configList = new ArrayList<ProviderConfig>();
         for (int i = 1; true; i++) {
             String entry = Security.getProperty("security.provider." + i);
             if (entry == null) {
@@ -200,7 +200,7 @@
      * possible recursion and deadlock during verification.
      */
     ProviderList getJarList(String[] jarClassNames) {
-        List<ProviderConfig> newConfigs = new ArrayList<>();
+        List<ProviderConfig> newConfigs = new ArrayList<ProviderConfig>();
         for (String className : jarClassNames) {
             ProviderConfig newConfig = new ProviderConfig(className);
             for (ProviderConfig config : configs) {
@@ -356,7 +356,7 @@
      */
     @Deprecated
     public List<Service> getServices(String type, List<String> algorithms) {
-        List<ServiceId> ids = new ArrayList<>();
+        List<ServiceId> ids = new ArrayList<ServiceId>();
         for (String alg : algorithms) {
             ids.add(new ServiceId(type, alg));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/jca/Providers.java openjdk-boot/jdk/src/share/classes/sun/security/jca/Providers.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/jca/Providers.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/jca/Providers.java	2011-07-12 16:56:06.766261029 +0100
@@ -40,7 +40,7 @@
 public class Providers {
 
     private static final ThreadLocal<ProviderList> threadLists =
-        new InheritableThreadLocal<>();
+        new InheritableThreadLocal<ProviderList>();
 
     // number of threads currently using thread-local provider lists
     // tracked to allow an optimization if == 0
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/jgss/krb5/Krb5Util.java openjdk-boot/jdk/src/share/classes/sun/security/jgss/krb5/Krb5Util.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/jgss/krb5/Krb5Util.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/jgss/krb5/Krb5Util.java	2011-07-12 16:56:06.862262617 +0100
@@ -267,7 +267,7 @@
             if (ktabs.isEmpty()) {
                 return kk.toArray(new KerberosKey[kk.size()]);
             } else {
-                List<KerberosKey> keys = new ArrayList<>();
+                List<KerberosKey> keys = new ArrayList<KerberosKey>();
                 for (KeyTab ktab: ktabs) {
                     for (KerberosKey k: ktab.getKeys(kp)) {
                         keys.add(k);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/Config.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/Config.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/Config.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/Config.java	2011-07-12 16:56:06.766261029 +0100
@@ -527,7 +527,7 @@
                 }
                 })));
                 String Line;
-                Vector<String> v = new Vector<>();
+                Vector<String> v = new Vector<String>();
                 String previous = null;
                 while ((Line = br.readLine()) != null) {
                     // ignore comments and blank line in the configuration file.
@@ -588,7 +588,7 @@
             throw new KrbException("I/O error while reading" +
                         " configuration file.");
         }
-        Hashtable<String,Object> table = new Hashtable<>();
+        Hashtable<String,Object> table = new Hashtable<String,Object>();
         for (int i = 0; i < v.size(); i++) {
             String line = v.elementAt(i).trim();
             if (line.equalsIgnoreCase("[realms]")) {
@@ -597,7 +597,7 @@
                     if ((count == v.size()) ||
                         (v.elementAt(count).startsWith("["))) {
                         Hashtable<String,Hashtable<String,Vector<String>>> temp =
-                            new Hashtable<>();
+                            new Hashtable<String,Hashtable<String,Vector<String>>>();
                         temp = parseRealmField(v, i + 1, count);
                         table.put("realms", temp);
                         i = count - 1;
@@ -610,7 +610,7 @@
                     if ((count == v.size()) ||
                         (v.elementAt(count).startsWith("["))) {
                         Hashtable<String,Hashtable<String,Vector<String>>> temp =
-                            new Hashtable<>();
+                            new Hashtable<String,Hashtable<String,Vector<String>>>();
                         temp = parseRealmField(v, i + 1, count);
                         table.put("capaths", temp);
                         i = count - 1;
@@ -728,7 +728,7 @@
      * Parses key-value pairs under a stanza name.
      */
     private Hashtable<String,String>  parseField(Vector<String> v, int start, int end) {
-        Hashtable<String,String> table = new Hashtable<>();
+      Hashtable<String,String> table = new Hashtable<String,String>();
         String line;
         for (int i = start; i < end; i++) {
             line = v.elementAt(i);
@@ -750,7 +750,7 @@
      * information for the realm given within a pair of braces.
      */
     private Hashtable<String,Hashtable<String,Vector<String>>> parseRealmField(Vector<String> v, int start, int end) {
-        Hashtable<String,Hashtable<String,Vector<String>>> table = new Hashtable<>();
+        Hashtable<String,Hashtable<String,Vector<String>>> table = new Hashtable<String,Hashtable<String,Vector<String>>>();
         String line;
         for (int i = start; i < end; i++) {
             line = v.elementAt(i).trim();
@@ -790,9 +790,9 @@
      * Parses key-value pairs within each braces under [realms].
      */
     private Hashtable<String,Vector<String>> parseRealmFieldEx(Vector<String> v, int start, int end) {
-        Hashtable<String,Vector<String>> table = new Hashtable<>();
-        Vector<String> keyVector = new Vector<>();
-        Vector<String> nameVector = new Vector<>();
+        Hashtable<String,Vector<String>> table = new Hashtable<String,Vector<String>>();
+        Vector<String> keyVector = new Vector<String>();
+        Vector<String> nameVector = new Vector<String>();
         String line = "";
         String key;
         for (int i = start; i < end; i++) {
@@ -897,7 +897,7 @@
             }
             st = new StringTokenizer(default_enctypes, delim);
             int len = st.countTokens();
-            ArrayList<Integer> ls = new ArrayList<>(len);
+            ArrayList<Integer> ls = new ArrayList<Integer>(len);
             int type;
             for (int i = 0; i < len; i++) {
                 type = getType(st.nextToken());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/Authenticator.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/Authenticator.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/Authenticator.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/Authenticator.java	2011-07-12 16:56:06.774261161 +0100
@@ -176,7 +176,7 @@
      * @exception IOException if an I/O error occurs while reading encoded data.
      */
     public byte[] asn1Encode() throws Asn1Exception, IOException {
-        Vector<DerValue> v = new Vector<>();
+        Vector<DerValue> v = new Vector<DerValue>();
         DerOutputStream temp = new DerOutputStream();
         temp.putInteger(BigInteger.valueOf(authenticator_vno));
         v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte) 0x00), temp.toByteArray()));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/AuthorizationData.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/AuthorizationData.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/AuthorizationData.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/AuthorizationData.java	2011-07-12 16:56:06.774261161 +0100
@@ -99,7 +99,7 @@
      * @exception IOException if an I/O error occurs while reading encoded data.
      */
     public AuthorizationData(DerValue der) throws Asn1Exception, IOException {
-        Vector<AuthorizationDataEntry> v = new Vector<>();
+        Vector<AuthorizationDataEntry> v = new Vector<AuthorizationDataEntry>();
         if (der.getTag() != DerValue.tag_Sequence) {
             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java	2011-07-12 16:56:06.774261161 +0100
@@ -490,7 +490,7 @@
 
     private static String exec(String c) {
         StringTokenizer st = new StringTokenizer(c);
-        Vector<String> v = new Vector<>();
+        Vector<String> v = new Vector<String>();
         while (st.hasMoreTokens()) {
             v.addElement(st.nextToken());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/crypto/EType.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/crypto/EType.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/crypto/EType.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/crypto/EType.java	2011-07-12 16:56:06.774261161 +0100
@@ -257,7 +257,7 @@
                 + configName);
         }
 
-        List<Integer> list = new ArrayList<>(answer.length);
+        List<Integer> list = new ArrayList<Integer>(answer.length);
         for (int i = 0; i < answer.length; i++) {
             if (EncryptionKey.findKey(answer[i], keys) != null) {
                 list.add(answer[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/EncAPRepPart.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/EncAPRepPart.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/EncAPRepPart.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/EncAPRepPart.java	2011-07-12 16:56:06.774261161 +0100
@@ -133,7 +133,7 @@
      * @exception IOException if an I/O error occurs while reading encoded data.
      */
     public byte[] asn1Encode() throws Asn1Exception, IOException {
-        Vector<DerValue> v = new Vector<>();
+        Vector<DerValue> v = new Vector<DerValue>();
         DerOutputStream temp = new DerOutputStream();
         v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT,
                 true, (byte) 0x00), ctime.asn1Encode()));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/HostAddresses.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/HostAddresses.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/HostAddresses.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/HostAddresses.java	2011-07-12 16:56:06.774261161 +0100
@@ -179,7 +179,7 @@
     */
     public HostAddresses(DerValue encoding)
         throws  Asn1Exception, IOException {
-        Vector<HostAddress> tempAddresses = new Vector<>();
+        Vector<HostAddress> tempAddresses = new Vector<HostAddress>();
         DerValue der = null;
         while (encoding.getData().available() > 0) {
             der = encoding.getData().getDerValue();
@@ -265,7 +265,7 @@
         if (addresses == null || addresses.length == 0)
             return null;
 
-        ArrayList<InetAddress> ipAddrs = new ArrayList<>(addresses.length);
+        ArrayList<InetAddress> ipAddrs = new ArrayList<InetAddress>(addresses.length);
 
         for (int i = 0; i < addresses.length; i++) {
             try {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KDCReqBody.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KDCReqBody.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KDCReqBody.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KDCReqBody.java	2011-07-12 16:56:06.774261161 +0100
@@ -158,7 +158,7 @@
             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
         }
         der = encoding.getData().getDerValue();
-        Vector<Integer> v = new Vector<>();
+        Vector<Integer> v = new Vector<Integer>();
         if ((der.getTag() & (byte)0x1F) == (byte)0x08) {
             subDer = der.getData().getDerValue();
 
@@ -183,7 +183,7 @@
             encAuthorizationData = EncryptedData.parse(encoding.getData(), (byte)0x0A, true);
         }
         if (encoding.getData().available() > 0) {
-            Vector<Ticket> tempTickets = new Vector<>();
+            Vector<Ticket> tempTickets = new Vector<Ticket>();
             der = encoding.getData().getDerValue();
             if ((der.getTag() & (byte)0x1F) == (byte)0x0B) {
                 subDer = der.getData().getDerValue();
@@ -216,7 +216,7 @@
      *
      */
     public byte[] asn1Encode(int msgType) throws Asn1Exception, IOException {
-        Vector<DerValue> v = new Vector<>();
+        Vector<DerValue> v = new Vector<DerValue>();
         v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x00), kdcOptions.asn1Encode()));
         if (msgType == Krb5.KRB_AS_REQ) {
             if (cname != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KDCReq.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KDCReq.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KDCReq.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KDCReq.java	2011-07-12 16:56:06.774261161 +0100
@@ -150,7 +150,7 @@
             if (subsubDer.getTag() != DerValue.tag_SequenceOf) {
                 throw new Asn1Exception(Krb5.ASN1_BAD_ID);
             }
-            Vector<PAData> v = new Vector<>();
+            Vector<PAData> v = new Vector<PAData>();
             while (subsubDer.getData().available() > 0) {
                 v.addElement(new PAData(subsubDer.getData().getDerValue()));
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KrbCredInfo.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KrbCredInfo.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KrbCredInfo.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KrbCredInfo.java	2011-07-12 16:56:06.778261227 +0100
@@ -157,7 +157,7 @@
      * @exception IOException if an I/O error occurs while reading encoded data.
      */
     public byte[] asn1Encode() throws Asn1Exception, IOException {
-        Vector<DerValue> v = new Vector<>();
+        Vector<DerValue> v = new Vector<DerValue>();
         v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x00), key.asn1Encode()));
         if (prealm != null)
             v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x01), prealm.asn1Encode()));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KRBCred.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KRBCred.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KRBCred.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KRBCred.java	2011-07-12 16:56:06.778261227 +0100
@@ -134,7 +134,7 @@
             if (subsubDer.getTag() != DerValue.tag_SequenceOf) {
                 throw new Asn1Exception(Krb5.ASN1_BAD_ID);
             }
-            Vector<Ticket> v = new Vector<>();
+            Vector<Ticket> v = new Vector<Ticket>();
             while (subsubDer.getData().available() > 0) {
                 v.addElement(new Ticket(subsubDer.getData().getDerValue()));
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KRBError.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KRBError.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KRBError.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KRBError.java	2011-07-12 16:56:06.778261227 +0100
@@ -260,7 +260,7 @@
     private void parsePAData(byte[] data)
             throws IOException, Asn1Exception {
         DerValue derPA = new DerValue(data);
-        List<PAData> paList = new ArrayList<>();
+        List<PAData> paList = new ArrayList<PAData>();
         while (derPA.data.available() > 0) {
             // read the PA-DATA
             DerValue tmp = derPA.data.getDerValue();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java	2011-07-12 16:56:06.778261227 +0100
@@ -67,7 +67,7 @@
 
     // Attention: Currently there is no way to remove a keytab from this map,
     // this might lead to a memory leak.
-    private static Map<String,KeyTab> map = new HashMap<>();
+    private static Map<String,KeyTab> map = new HashMap<String,KeyTab>();
 
     // KeyTab file does not exist. Note: a missing keytab is still valid
     private boolean isMissing = false;
@@ -79,7 +79,7 @@
     private long lastModified;
     private int kt_vno;
 
-    private Vector<KeyTabEntry> entries = new Vector<>();
+    private Vector<KeyTabEntry> entries = new Vector<KeyTabEntry>();
 
     /**
      * Constructs a KeyTab object.
@@ -280,7 +280,7 @@
         KeyTabEntry entry;
         EncryptionKey key;
         int size = entries.size();
-        ArrayList<EncryptionKey> keys = new ArrayList<>(size);
+        ArrayList<EncryptionKey> keys = new ArrayList<EncryptionKey>(size);
         for (int i = size-1; i >= 0; i--) {
             entry = entries.elementAt(i);
             if (entry.service.match(service)) {
@@ -482,7 +482,7 @@
         int count = 0;
 
         // Remember the highest KVNO for each etype. Used for kvno == -2
-        Map<Integer,Integer> highest = new HashMap<>();
+        Map<Integer,Integer> highest = new HashMap<Integer, Integer>();
 
         for (int i = entries.size()-1; i >= 0; i--) {
             KeyTabEntry e = entries.get(i);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/LastReq.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/LastReq.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/LastReq.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/LastReq.java	2011-07-12 16:56:06.778261227 +0100
@@ -77,7 +77,7 @@
      */
 
     public LastReq(DerValue encoding) throws Asn1Exception, IOException {
-        Vector<LastReqEntry> v= new Vector<>();
+        Vector<LastReqEntry> v= new Vector<LastReqEntry>();
         if (encoding.getTag() != DerValue.tag_Sequence) {
             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/KdcComm.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/KdcComm.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/KdcComm.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/KdcComm.java	2011-07-12 16:56:06.778261227 +0100
@@ -462,7 +462,7 @@
      */
     static class KdcAccessibility {
         // Known bad KDCs
-        private static Set<String> bads = new HashSet<>();
+        private static Set<String> bads = new HashSet<String>();
 
         private static synchronized void addBad(String kdc) {
             if (DEBUG) {
@@ -492,9 +492,9 @@
         // Returns a preferred KDC list by putting the bad ones at the end
         private static synchronized String[] list(String kdcList) {
             StringTokenizer st = new StringTokenizer(kdcList);
-            List<String> list = new ArrayList<>();
+            List<String> list = new ArrayList<String>();
             if (badPolicy == BpType.TRY_LAST) {
-                List<String> badkdcs = new ArrayList<>();
+                List<String> badkdcs = new ArrayList<String>();
                 while (st.hasMoreTokens()) {
                     String t = st.nextToken();
                     if (bads.contains(t)) badkdcs.add(t);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/PrincipalName.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/PrincipalName.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/PrincipalName.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/PrincipalName.java	2011-07-12 16:56:06.778261227 +0100
@@ -244,7 +244,7 @@
             if (subDer.getTag() != DerValue.tag_SequenceOf) {
                 throw new Asn1Exception(Krb5.ASN1_BAD_ID);
             }
-            Vector<String> v = new Vector<>();
+            Vector<String> v = new Vector<String>();
             DerValue subSubDer;
             while(subDer.getData().available() > 0) {
                 subSubDer = subDer.getData().getDerValue();
@@ -299,7 +299,7 @@
     // Code repetition, realm parsed again by class Realm
     protected static String[] parseName(String name) {
 
-        Vector<String> tempStrings = new Vector<>();
+        Vector<String> tempStrings = new Vector<String>();
         String temp = name;
         int i = 0;
         int componentStart = 0;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/Realm.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/Realm.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/Realm.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/Realm.java	2011-07-12 16:56:06.778261227 +0100
@@ -359,14 +359,14 @@
         }
 
         String tempTarget = null, tempRealm = null;
-        Stack<String> iStack = new Stack<>();
+        Stack<String> iStack = new Stack<String>();
 
         /*
          * The half-established reversed-path, starting from the final target
          * (sRealm), each item can be connected to by the next one.
          * Might contains wrong item, if found, a bad track is performed
          */
-        Vector<String> tempList = new Vector<>(8, 8);
+        Vector<String> tempList = new Vector<String>(8, 8);
         tempList.add(sRealm);
 
         int count = 0; // For debug only
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java	2011-07-12 16:56:06.862262617 +0100
@@ -590,7 +590,7 @@
             // Except the performance improvement, another benefit is to break
             // the dead loop while looking for the issuer back and forth
             // between the delegated self-issued certificate and its issuer.
-            Set<TrustAnchor> newTrustAnchors = new HashSet<>(trustAnchors);
+            Set<TrustAnchor> newTrustAnchors = new HashSet<TrustAnchor>(trustAnchors);
 
             if (prevKey != null) {
                 // Add the previous certificate as a trust anchor.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/JavaKeyStore.java openjdk-boot/jdk/src/share/classes/sun/security/provider/JavaKeyStore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/JavaKeyStore.java	2011-04-14 01:29:59.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/JavaKeyStore.java	2011-07-12 16:56:06.778261227 +0100
@@ -683,7 +683,7 @@
                     // Read the certificate chain
                     int numOfCerts = dis.readInt();
                     if (numOfCerts > 0) {
-                        List<Certificate> certs = new ArrayList<>(
+                        List<Certificate> certs = new ArrayList<Certificate>(
                                 numOfCerts > 10 ? 10 : numOfCerts);
                         for (int j = 0; j < numOfCerts; j++) {
                             if (xVersion == 2) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/PolicyFile.java openjdk-boot/jdk/src/share/classes/sun/security/provider/PolicyFile.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/PolicyFile.java	2011-07-12 12:43:47.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/PolicyFile.java	2011-07-12 16:56:06.778261227 +0100
@@ -299,7 +299,7 @@
     private static final int DEFAULT_CACHE_SIZE = 1;
 
     // contains the policy grant entries, PD cache, and alias mapping
-    private AtomicReference<PolicyInfo> policyInfo = new AtomicReference<>();
+    private AtomicReference<PolicyInfo> policyInfo = new AtomicReference<PolicyInfo>();
     private boolean constructed = false;
 
     private boolean expandProperties = true;
@@ -1333,7 +1333,7 @@
 
         List<PolicyParser.PrincipalEntry> entryPs = entry.getPrincipals();
         if (debug != null) {
-            ArrayList<PolicyParser.PrincipalEntry> accPs = new ArrayList<>();
+            ArrayList<PolicyParser.PrincipalEntry> accPs = new ArrayList<PolicyParser.PrincipalEntry>();
             if (principals != null) {
                 for (int i = 0; i < principals.length; i++) {
                     accPs.add(new PolicyParser.PrincipalEntry
@@ -1414,7 +1414,7 @@
                     // check if the PrincipalComparator
                     // implies the current thread's principals
 
-                    Set<Principal> pSet = new HashSet<>(principals.length);
+                    Set<Principal> pSet = new HashSet<Principal>(principals.length);
                     for (int j = 0; j < principals.length; j++) {
                         pSet.add(principals[j]);
                     }
@@ -1697,7 +1697,7 @@
             // build an info array for every principal
             // in the current domain which has a principal class
             // that is equal to policy entry principal class name
-            List<Principal> plist = new ArrayList<>();
+            List<Principal> plist = new ArrayList<Principal>();
             for (int i = 0; i < pdp.length; i++) {
                 if(pe.principalClass.equals(pdp[i].getClass().getName()))
                     plist.add(pdp[i]);
@@ -1767,7 +1767,7 @@
             // Done
             return certs;
 
-        ArrayList<Certificate> userCertList = new ArrayList<>();
+        ArrayList<Certificate> userCertList = new ArrayList<Certificate>();
         i = 0;
         while (i < certs.length) {
             userCertList.add(certs[i]);
@@ -2246,7 +2246,7 @@
                     if (this.certs == null) {
                         // extract the signer certs
                         ArrayList<Certificate> signerCerts =
-                            new ArrayList<>();
+                            new ArrayList<Certificate>();
                         i = 0;
                         while (i < certs.length) {
                             signerCerts.add(certs[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/Sun.java openjdk-boot/jdk/src/share/classes/sun/security/provider/Sun.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/Sun.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/Sun.java	2011-07-12 16:56:06.778261227 +0100
@@ -55,7 +55,7 @@
             SunEntries.putEntries(this);
         } else {
             // use LinkedHashMap to preserve the order of the PRNGs
-            Map<Object, Object> map = new LinkedHashMap<>();
+            Map<Object, Object> map = new LinkedHashMap<Object, Object>();
             SunEntries.putEntries(map);
             AccessController.doPrivileged(new PutAllAction(this, map));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/VerificationProvider.java openjdk-boot/jdk/src/share/classes/sun/security/provider/VerificationProvider.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/VerificationProvider.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/VerificationProvider.java	2011-07-12 16:56:06.778261227 +0100
@@ -76,7 +76,7 @@
             SunRsaSignEntries.putEntries(this);
         } else {
             // use LinkedHashMap to preserve the order of the PRNGs
-            Map<Object, Object> map = new LinkedHashMap<>();
+            Map<Object, Object> map = new LinkedHashMap<Object, Object>();
             SunEntries.putEntries(map);
             SunRsaSignEntries.putEntries(map);
             AccessController.doPrivileged(new PutAllAction(this, map));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/X509Factory.java openjdk-boot/jdk/src/share/classes/sun/security/provider/X509Factory.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/X509Factory.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/X509Factory.java	2011-07-12 16:56:06.778261227 +0100
@@ -409,10 +409,10 @@
         parseX509orPKCS7Cert(InputStream is)
         throws CertificateException, IOException
     {
-        Collection<X509CertImpl> coll = new ArrayList<>();
+        Collection<X509CertImpl> coll = new ArrayList<X509CertImpl>();
         byte[] data = readOneBlock(is);
         if (data == null) {
-            return new ArrayList<>(0);
+            return new ArrayList<Certificate>(0);
         }
         try {
             PKCS7 pkcs7 = new PKCS7(data);
@@ -422,7 +422,7 @@
                 return Arrays.asList(certs);
             } else {
                 // no crls provided
-                return new ArrayList<>(0);
+                return new ArrayList<Certificate>(0);
             }
         } catch (ParsingException e) {
             while (data != null) {
@@ -442,10 +442,10 @@
         parseX509orPKCS7CRL(InputStream is)
         throws CRLException, IOException
     {
-        Collection<X509CRLImpl> coll = new ArrayList<>();
+        Collection<X509CRLImpl> coll = new ArrayList<X509CRLImpl>();
         byte[] data = readOneBlock(is);
         if (data == null) {
-            return new ArrayList<>(0);
+            return new ArrayList<java.security.cert.CRL>(0);
         }
         try {
             PKCS7 pkcs7 = new PKCS7(data);
@@ -455,7 +455,7 @@
                 return Arrays.asList(crls);
             } else {
                 // no crls provided
-                return new ArrayList<>(0);
+                return new ArrayList<java.security.cert.CRL>(0);
             }
         } catch (ParsingException e) {
             while (data != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/rsa/RSACore.java openjdk-boot/jdk/src/share/classes/sun/security/rsa/RSACore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/rsa/RSACore.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/rsa/RSACore.java	2011-07-12 16:56:06.778261227 +0100
@@ -219,7 +219,7 @@
     // use a weak hashmap so that cached values are automatically cleared
     // when the modulus is GC'ed
     private final static Map<BigInteger, BlindingParameters> blindingCache =
-                new WeakHashMap<>();
+        new WeakHashMap<BigInteger, BlindingParameters>();
 
     /**
      * Set of blinding parameters for a given RSA key.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/rsa/SunRsaSign.java openjdk-boot/jdk/src/share/classes/sun/security/rsa/SunRsaSign.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/rsa/SunRsaSign.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/rsa/SunRsaSign.java	2011-07-12 16:56:06.782261293 +0100
@@ -52,7 +52,7 @@
             SunRsaSignEntries.putEntries(this);
         } else {
             // use LinkedHashMap to preserve the order of the PRNGs
-            Map<Object, Object> map = new HashMap<>();
+            Map<Object, Object> map = new HashMap<Object, Object>();
             SunRsaSignEntries.putEntries(map);
             AccessController.doPrivileged(new PutAllAction(this, map));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/CipherSuite.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/CipherSuite.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/CipherSuite.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/CipherSuite.java	2011-07-12 16:56:06.782261293 +0100
@@ -393,7 +393,7 @@
 
         // Map BulkCipher -> Boolean(available)
         private final static Map<BulkCipher,Boolean> availableCache =
-                                            new HashMap<>(8);
+            new HashMap<BulkCipher,Boolean>(8);
 
         // descriptive name including key size, e.g. AES/128
         final String description;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java	2011-04-20 04:40:22.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java	2011-07-12 16:56:06.782261293 +0100
@@ -656,7 +656,7 @@
         if (certRequest != null) {
             X509ExtendedKeyManager km = sslContext.getX509KeyManager();
 
-            ArrayList<String> keytypesTmp = new ArrayList<>(4);
+            ArrayList<String> keytypesTmp = new ArrayList<String>(4);
 
             for (int i = 0; i < certRequest.types.length; i++) {
                 String typeName;
@@ -1175,7 +1175,7 @@
                         "Can't reuse existing SSL client session");
                 }
 
-                Collection<CipherSuite> cipherList = new ArrayList<>(2);
+                Collection<CipherSuite> cipherList = new ArrayList<CipherSuite>(2);
                 cipherList.add(sessionSuite);
                 if (!secureRenegotiation &&
                         cipherSuites.contains(CipherSuite.C_SCSV)) {
@@ -1193,7 +1193,7 @@
         // exclude SCSV for secure renegotiation
         if (secureRenegotiation && cipherSuites.contains(CipherSuite.C_SCSV)) {
             Collection<CipherSuite> cipherList =
-                        new ArrayList<>(cipherSuites.size() - 1);
+                        new ArrayList<CipherSuite>(cipherSuites.size() - 1);
             for (CipherSuite suite : cipherSuites.collection()) {
                 if (suite != CipherSuite.C_SCSV) {
                     cipherList.add(suite);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java	2011-07-12 16:56:06.782261293 +0100
@@ -258,7 +258,7 @@
     // add server_name extension
     void addServerNameIndicationExtension(String hostname) {
         // We would have checked that the hostname ia a FQDN.
-        ArrayList<String> hostnames = new ArrayList<>(1);
+        ArrayList<String> hostnames = new ArrayList<String>(1);
         hostnames.add(hostname);
 
         try {
@@ -434,7 +434,7 @@
 
     CertificateMsg(HandshakeInStream input) throws IOException {
         int chainLen = input.getInt24();
-        List<Certificate> v = new ArrayList<>(4);
+        List<Certificate> v = new ArrayList<Certificate>(4);
 
         CertificateFactory cf = null;
         while (chainLen > 0) {
@@ -1334,7 +1334,7 @@
 
         // read the certificate_authorities
         int len = input.getInt16();
-        ArrayList<DistinguishedName> v = new ArrayList<>();
+        ArrayList<DistinguishedName> v = new ArrayList<DistinguishedName>();
         while (len >= 3) {
             DistinguishedName dn = new DistinguishedName(input);
             v.add(dn);
@@ -1725,7 +1725,7 @@
     // Note that this will prevent the Spi classes from being GC'd. We assume
     // that is not a problem.
     private final static Map<Class,Object> methodCache =
-                                        new ConcurrentHashMap<>();
+        new ConcurrentHashMap<Class,Object>();
 
     private static void digestKey(MessageDigest md, SecretKey key) {
         try {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/Handshaker.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/Handshaker.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/Handshaker.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/Handshaker.java	2011-07-12 16:56:06.806261691 +0100
@@ -569,7 +569,7 @@
                 activeProtocols = getActiveProtocols();
             }
 
-            ArrayList<CipherSuite> suites = new ArrayList<>();
+            ArrayList<CipherSuite> suites = new ArrayList<CipherSuite>();
             if (!(activeProtocols.collection().isEmpty()) &&
                     activeProtocols.min.v != ProtocolVersion.NONE.v) {
                 for (CipherSuite suite : enabledCipherSuites.collection()) {
@@ -614,7 +614,7 @@
      */
     ProtocolList getActiveProtocols() {
         if (activeProtocols == null) {
-            ArrayList<ProtocolVersion> protocols = new ArrayList<>(4);
+            ArrayList<ProtocolVersion> protocols = new ArrayList<ProtocolVersion>(4);
             for (ProtocolVersion protocol : enabledProtocols.collection()) {
                 boolean found = false;
                 for (CipherSuite suite : enabledCipherSuites.collection()) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/HelloExtensions.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/HelloExtensions.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/HelloExtensions.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/HelloExtensions.java	2011-07-12 16:56:06.806261691 +0100
@@ -169,7 +169,7 @@
         return name;
     }
 
-    static List<ExtensionType> knownExtensions = new ArrayList<>(9);
+    static List<ExtensionType> knownExtensions = new ArrayList<ExtensionType>(9);
 
     static ExtensionType get(int id) {
         for (ExtensionType ext : knownExtensions) {
@@ -673,7 +673,7 @@
     }
 
     public String toString() {
-        List<String> list = new ArrayList<>();
+        List<String> list = new ArrayList<String>();
         for (byte format : formats) {
             list.add(toString(format));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ProtocolList.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/ProtocolList.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ProtocolList.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/ProtocolList.java	2011-07-12 16:56:06.806261691 +0100
@@ -79,7 +79,7 @@
             throw new IllegalArgumentException("Protocols may not be null");
         }
 
-        ArrayList<ProtocolVersion> versions = new ArrayList<>(3);
+        ArrayList<ProtocolVersion> versions = new ArrayList<ProtocolVersion>(3);
         for (int i = 0; i < names.length; i++ ) {
             ProtocolVersion version = ProtocolVersion.valueOf(names[i]);
             if (versions.contains(version) == false) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java	2011-07-12 16:56:06.806261691 +0100
@@ -153,7 +153,7 @@
     static Collection<SignatureAndHashAlgorithm>
             getSupportedAlgorithms(AlgorithmConstraints constraints) {
 
-        Collection<SignatureAndHashAlgorithm> supported = new ArrayList<>();
+        Collection<SignatureAndHashAlgorithm> supported = new ArrayList<SignatureAndHashAlgorithm>();
         synchronized (priorityMap) {
             for (SignatureAndHashAlgorithm sigAlg : priorityMap.values()) {
                 if (sigAlg.priority <= SUPPORTED_ALG_PRIORITY_MAX_NUM &&
@@ -170,7 +170,7 @@
     // Get supported algorithm collection from an untrusted collection
     static Collection<SignatureAndHashAlgorithm> getSupportedAlgorithms(
             Collection<SignatureAndHashAlgorithm> algorithms ) {
-        Collection<SignatureAndHashAlgorithm> supported = new ArrayList<>();
+        Collection<SignatureAndHashAlgorithm> supported = new ArrayList<SignatureAndHashAlgorithm>();
         for (SignatureAndHashAlgorithm sigAlg : algorithms) {
             if (sigAlg.priority <= SUPPORTED_ALG_PRIORITY_MAX_NUM) {
                 supported.add(sigAlg);
@@ -182,7 +182,7 @@
 
     static String[] getAlgorithmNames(
             Collection<SignatureAndHashAlgorithm> algorithms) {
-        ArrayList<String> algorithmNames = new ArrayList<>();
+        ArrayList<String> algorithmNames = new ArrayList<String>();
         if (algorithms != null) {
             for (SignatureAndHashAlgorithm sigAlg : algorithms) {
                 algorithmNames.add(sigAlg.algorithm);
@@ -195,7 +195,7 @@
 
     static Set<String> getHashAlgorithmNames(
             Collection<SignatureAndHashAlgorithm> algorithms) {
-        Set<String> algorithmNames = new HashSet<>();
+        Set<String> algorithmNames = new HashSet<String>();
         if (algorithms != null) {
             for (SignatureAndHashAlgorithm sigAlg : algorithms) {
                 if (sigAlg.hash.value > 0) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLAlgorithmConstraints.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLAlgorithmConstraints.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLAlgorithmConstraints.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLAlgorithmConstraints.java	2011-07-12 16:56:06.806261691 +0100
@@ -261,7 +261,7 @@
 
         protected Set<String> decomposes(KeyExchange keyExchange,
                         boolean forCertPathOnly) {
-            Set<String> components = new HashSet<>();
+            Set<String> components = new HashSet<String>();
             switch (keyExchange) {
                 case K_NULL:
                     if (!forCertPathOnly) {
@@ -356,7 +356,7 @@
         }
 
         protected Set<String> decomposes(BulkCipher bulkCipher) {
-            Set<String> components = new HashSet<>();
+            Set<String> components = new HashSet<String>();
 
             if (bulkCipher.transformation != null) {
                 components.addAll(super.decomposes(bulkCipher.transformation));
@@ -366,7 +366,7 @@
         }
 
         protected Set<String> decomposes(MacAlg macAlg) {
-            Set<String> components = new HashSet<>();
+            Set<String> components = new HashSet<String>();
 
             if (macAlg == CipherSuite.M_MD5) {
                 components.add("MD5");
@@ -407,7 +407,7 @@
                 }
 
                 if (cipherSuite != null) {
-                    Set<String> components = new HashSet<>();
+                    Set<String> components = new HashSet<String>();
 
                     if(cipherSuite.keyExchange != null) {
                         components.addAll(
@@ -448,7 +448,7 @@
                 }
 
                 if (cipherSuite != null) {
-                    Set<String> components = new HashSet<>();
+                    Set<String> components = new HashSet<String>();
 
                     if(cipherSuite.keyExchange != null) {
                         components.addAll(
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLContextImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLContextImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLContextImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLContextImpl.java	2011-07-12 16:56:06.862262617 +0100
@@ -325,7 +325,7 @@
         Collection<CipherSuite> allowedCipherSuites =
                                     CipherSuite.allowedCipherSuites();
 
-        ArrayList<CipherSuite> suites = new ArrayList<>();
+        ArrayList<CipherSuite> suites = new ArrayList<CipherSuite>();
         if (!(protocols.collection().isEmpty()) &&
                 protocols.min.v != ProtocolVersion.NONE.v) {
             for (CipherSuite suite : allowedCipherSuites) {
@@ -532,7 +532,7 @@
                 return defaultKeyManagers;
             }
 
-            final Map<String,String> props = new HashMap<>();
+            final Map<String,String> props = new HashMap<String,String>();
             AccessController.doPrivileged(
                         new PrivilegedExceptionAction<Object>() {
                 public Object run() throws Exception {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java	2011-07-12 16:56:06.806261691 +0100
@@ -618,7 +618,7 @@
      * key and the calling security context. This is important since
      * sessions can be shared across different protection domains.
      */
-    private Hashtable<SecureKey, Object> table = new Hashtable<>();
+    private Hashtable<SecureKey, Object> table = new Hashtable<SecureKey, Object>();
 
     /**
      * Assigns a session value.  Session change events are given if
@@ -686,7 +686,7 @@
      */
     public String[] getValueNames() {
         Enumeration<SecureKey> e;
-        Vector<Object> v = new Vector<>();
+        Vector<Object> v = new Vector<Object>();
         SecureKey key;
         Object securityCtx = SecureKey.getCurrentSecurityContext();
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SunX509KeyManagerImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SunX509KeyManagerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SunX509KeyManagerImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SunX509KeyManagerImpl.java	2011-07-12 16:56:06.806261691 +0100
@@ -337,7 +337,7 @@
 
         X500Principal[] x500Issuers = (X500Principal[])issuers;
         // the algorithm below does not produce duplicates, so avoid Set
-        List<String> aliases = new ArrayList<>();
+        List<String> aliases = new ArrayList<String>();
 
         for (Map.Entry<String,X509Credentials> entry :
                                                 credentialsMap.entrySet()) {
@@ -397,7 +397,7 @@
      * possible. Principals that cannot be converted are ignored.
      */
     private static X500Principal[] convertPrincipals(Principal[] principals) {
-        List<X500Principal> list = new ArrayList<>(principals.length);
+        List<X500Principal> list = new ArrayList<X500Principal>(principals.length);
         for (int i = 0; i < principals.length; i++) {
             Principal p = principals[i];
             if (p instanceof X500Principal) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/TrustManagerFactoryImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/TrustManagerFactoryImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/TrustManagerFactoryImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/TrustManagerFactoryImpl.java	2011-07-12 16:56:06.806261691 +0100
@@ -134,7 +134,7 @@
         FileInputStream fis = null;
         String defaultTrustStoreType;
         String defaultTrustStoreProvider;
-        final HashMap<String,String> props = new HashMap<>();
+        final HashMap<String,String> props = new HashMap<String,String>();
         final String sep = File.separator;
         KeyStore ks = null;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/X509KeyManagerImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/X509KeyManagerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/X509KeyManagerImpl.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/X509KeyManagerImpl.java	2011-07-12 16:56:06.806261691 +0100
@@ -307,7 +307,7 @@
                 (keyTypes.length == 0) || (keyTypes[0] == null)) {
             return null;
         }
-        List<KeyType> list = new ArrayList<>(keyTypes.length);
+        List<KeyType> list = new ArrayList<KeyType>(keyTypes.length);
         for (String keyType : keyTypes) {
             list.add(new KeyType(keyType));
         }
@@ -429,7 +429,7 @@
     // make a Set out of the array
     private Set<Principal> getIssuerSet(Principal[] issuers) {
         if ((issuers != null) && (issuers.length != 0)) {
-            return new HashSet<>(Arrays.asList(issuers));
+            return new HashSet<Principal>(Arrays.asList(issuers));
         } else {
             return null;
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/JarSigner.java openjdk-boot/jdk/src/share/classes/sun/security/tools/JarSigner.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/JarSigner.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/tools/JarSigner.java	2011-07-12 16:56:06.810261758 +0100
@@ -123,14 +123,14 @@
     boolean token = false; // token-based keystore
     String jarfile;  // jar files to sign or verify
     String alias;    // alias to sign jar with
-    List<String> ckaliases = new ArrayList<>(); // aliases in -verify
+    List<String> ckaliases = new ArrayList<String>(); // aliases in -verify
     char[] storepass; // keystore password
     boolean protectedPath; // protected authentication path
     String storetype; // keystore type
     String providerName; // provider name
     Vector<String> providers = null; // list of providers
     // arguments for provider constructors
-    HashMap<String,String> providerArgs = new HashMap<>();
+    HashMap<String,String> providerArgs = new HashMap<String,String>();
     char[] keypass; // private key password
     String sigfile; // name of .SF file
     String sigalg; // name of signature algorithm
@@ -567,7 +567,7 @@
 
         try {
             jf = new JarFile(jarName, true);
-            Vector<JarEntry> entriesVec = new Vector<>();
+            Vector<JarEntry> entriesVec = new Vector<JarEntry>();
             byte[] buffer = new byte[8192];
 
             Enumeration<JarEntry> entries = jf.entries();
@@ -594,7 +594,7 @@
             // The map to record display info, only used when -verbose provided
             //      key: signer info string
             //      value: the list of files with common key
-            Map<String,List<String>> output = new LinkedHashMap<>();
+            Map<String,List<String>> output = new LinkedHashMap<String,List<String>>();
 
             if (man != null) {
                 if (verbose != null) System.out.println();
@@ -946,7 +946,7 @@
             .append(signTimeForm.format(source)).append("]").toString();
     }
 
-    private Map<CodeSigner,Integer> cacheForInKS = new IdentityHashMap<>();
+    private Map<CodeSigner,Integer> cacheForInKS = new IdentityHashMap<CodeSigner,Integer>();
 
     private int inKeyStoreForOneSigner(CodeSigner signer) {
         if (cacheForInKS.containsKey(signer)) {
@@ -989,7 +989,7 @@
         return result;
     }
 
-    Hashtable<Certificate, String> storeHash = new Hashtable<>();
+    Hashtable<Certificate, String> storeHash = new Hashtable<Certificate,String>();
 
     int inKeyStore(CodeSigner[] signers) {
 
@@ -1119,7 +1119,7 @@
              *   generated one. (This may invalidate existing signatures!)
              */
             BASE64Encoder encoder = new JarBASE64Encoder();
-            Vector<ZipEntry> mfFiles = new Vector<>();
+            Vector<ZipEntry> mfFiles = new Vector<ZipEntry>();
 
             boolean wasSigned = false;
 
@@ -1476,7 +1476,7 @@
         return false;
     }
 
-    Map<CodeSigner,String> cacheForSignerInfo = new IdentityHashMap<>();
+    Map<CodeSigner,String> cacheForSignerInfo = new IdentityHashMap<CodeSigner,String>();
 
     /**
      * Returns a string of singer info, with a newline at the end
@@ -1600,7 +1600,7 @@
                     }
                 }
             }
-            Set<TrustAnchor> tas = new HashSet<>();
+            Set<TrustAnchor> tas = new HashSet<TrustAnchor>();
             try {
                 KeyStore caks = KeyTool.getCacertsKeyStore();
                 if (caks != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/KeyTool.java openjdk-boot/jdk/src/share/classes/sun/security/tools/KeyTool.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/KeyTool.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/tools/KeyTool.java	2011-07-12 16:56:06.810261758 +0100
@@ -152,11 +152,11 @@
     private KeyStore caks = null; // "cacerts" keystore
     private char[] srcstorePass = null;
     private String srcstoretype = null;
-    private Set<char[]> passwords = new HashSet<>();
+    private Set<char[]> passwords = new HashSet<char[]>();
     private String startDate = null;
 
-    private List<String> ids = new ArrayList<>();   // used in GENCRL
-    private List<String> v3ext = new ArrayList<>();
+    private List<String> ids = new ArrayList<String>();   // used in GENCRL
+    private List<String> v3ext = new ArrayList<String>();
 
     enum Command {
         CERTREQ("Generates.a.certificate.request",
@@ -2089,7 +2089,7 @@
      */
     public static List<CRL> readCRLsFromCert(X509Certificate cert)
             throws Exception {
-        List<CRL> crls = new ArrayList<>();
+        List<CRL> crls = new ArrayList<CRL>();
         CRLDistributionPointsExtension ext =
                 X509CertImpl.toImpl(cert).getCRLDistributionPointsExtension();
         if (ext == null) return crls;
@@ -2256,7 +2256,7 @@
         if (jarfile != null) {
             JarFile jf = new JarFile(jarfile, true);
             Enumeration<JarEntry> entries = jf.entries();
-            Set<CodeSigner> ss = new HashSet<>();
+            Set<CodeSigner> ss = new HashSet<CodeSigner>();
             byte[] buffer = new byte[8192];
             int pos = 0;
             while (entries.hasMoreElements()) {
@@ -3331,7 +3331,7 @@
         }
 
         // start building chain
-        Vector<Certificate> chain = new Vector<>(2);
+        Vector<Certificate> chain = new Vector<Certificate>(2);
         if (buildChain((X509Certificate)certToVerify, chain, certs)) {
             Certificate[] newChain = new Certificate[chain.size()];
             // buildChain() returns chain with self-signed root-cert first and
@@ -3857,7 +3857,7 @@
                         break;
                     case 2:     // EKU
                         if(value != null) {
-                            Vector<ObjectIdentifier> v = new Vector<>();
+                            Vector<ObjectIdentifier> v = new Vector<ObjectIdentifier>();
                             for (String s: value.split(",")) {
                                 int p = oneOf(s,
                                         "anyExtendedKeyUsage",
@@ -3927,7 +3927,7 @@
                         }
                         if(value != null) {
                             List<AccessDescription> accessDescriptions =
-                                    new ArrayList<>();
+                                    new ArrayList<AccessDescription>();
                             String[] ps = value.split(",");
                             for(String item: ps) {
                                 colonpos = item.indexOf(':');
@@ -4211,7 +4211,7 @@
     }
 
     public static <A,B> Pair<A,B> of(A a, B b) {
-        return new Pair<>(a,b);
+        return new Pair<A,B>(a,b);
     }
 }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/policytool/PolicyTool.java openjdk-boot/jdk/src/share/classes/sun/security/tools/policytool/PolicyTool.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/policytool/PolicyTool.java	2011-06-11 00:38:10.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/tools/policytool/PolicyTool.java	2011-07-12 16:56:06.810261758 +0100
@@ -643,7 +643,7 @@
         Class<?> pc = Class.forName(type, true,
                 Thread.currentThread().getContextClassLoader());
         Constructor<?> c = null;
-        Vector<String> objects = new Vector<>(2);
+        Vector<String> objects = new Vector<String>(2);
         if (name != null) objects.add(name);
         if (actions != null) objects.add(actions);
         switch (objects.size()) {
@@ -1722,7 +1722,7 @@
                         new PolicyParser.GrantEntry(signedby, codebase);
 
         // get the new Principals
-        LinkedList<PolicyParser.PrincipalEntry> prins = new LinkedList<>();
+        LinkedList<PolicyParser.PrincipalEntry> prins = new LinkedList<PolicyParser.PrincipalEntry>();
         TaggedList prinList = (TaggedList)getComponent(PE_PRIN_LIST);
         for (int i = 0; i < prinList.getItemCount(); i++) {
             prins.add((PolicyParser.PrincipalEntry)prinList.getObject(i));
@@ -1730,7 +1730,7 @@
         ge.principals = prins;
 
         // get the new Permissions
-        Vector<PolicyParser.PermissionEntry> perms = new Vector<>();
+        Vector<PolicyParser.PermissionEntry> perms = new Vector<PolicyParser.PermissionEntry>();
         TaggedList permList = (TaggedList)getComponent(PE_PERM_LIST);
         for (int i = 0; i < permList.getItemCount(); i++) {
             perms.addElement((PolicyParser.PermissionEntry)permList.getObject(i));
@@ -3647,7 +3647,7 @@
  * This is a java.awt.List that bind an Object to each String it holds.
  */
 class TaggedList extends List {
-    private java.util.List<Object> data = new LinkedList<>();
+    private java.util.List<Object> data = new LinkedList<Object>();
     public TaggedList(int i, boolean b) {
         super(i, b);
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/tools/native2ascii/Main.java openjdk-boot/jdk/src/share/classes/sun/tools/native2ascii/Main.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/tools/native2ascii/Main.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/tools/native2ascii/Main.java	2011-07-12 16:56:06.810261758 +0100
@@ -94,7 +94,7 @@
      * Run the converter
      */
     public synchronized boolean convert(String argv[]){
-        List<String> v = new ArrayList<>(2);
+        List<String> v = new ArrayList<String>(2);
         File outputFile = null;
         boolean createOutputFile = false;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/InternalLocaleBuilder.java openjdk-boot/jdk/src/share/classes/sun/util/locale/InternalLocaleBuilder.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/InternalLocaleBuilder.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/locale/InternalLocaleBuilder.java	2011-07-12 16:56:06.818261891 +0100
@@ -113,7 +113,7 @@
         }
         // Use case insensitive string to prevent duplication
         if (uattributes == null) {
-            uattributes = new HashSet<>(4);
+            uattributes = new HashSet<CaseInsensitiveString>(4);
         }
         uattributes.add(new CaseInsensitiveString(attribute));
         return this;
@@ -157,7 +157,7 @@
                 }
             }
             if (ukeywords == null) {
-                ukeywords = new HashMap<>(4);
+                ukeywords = new HashMap<CaseInsensitiveString,String>(4);
             }
             ukeywords.put(cikey, type);
         }
@@ -211,7 +211,7 @@
                 setUnicodeLocaleExtension(val);
             } else {
                 if (extensions == null) {
-                    extensions = new HashMap<>(4);
+                    extensions = new HashMap<CaseInsensitiveChar,String>(4);
                 }
                 extensions.put(key, val);
             }
@@ -262,7 +262,7 @@
                 }
 
                 if (extensions == null) {
-                    extensions = new ArrayList<>(4);
+                    extensions = new ArrayList<String>(4);
                 }
                 extensions.add(sb.toString());
             } else {
@@ -313,7 +313,7 @@
         clearExtensions();
 
         if (!LocaleUtils.isEmpty(bcpExtensions)) {
-            Set<CaseInsensitiveChar> done = new HashSet<>(bcpExtensions.size());
+            Set<CaseInsensitiveChar> done = new HashSet<CaseInsensitiveChar>(bcpExtensions.size());
             for (String bcpExt : bcpExtensions) {
                 CaseInsensitiveChar key = new CaseInsensitiveChar(bcpExt);
                 // ignore duplicates
@@ -323,7 +323,7 @@
                         setUnicodeLocaleExtension(bcpExt.substring(2));
                     } else {
                         if (extensions == null) {
-                            extensions = new HashMap<>(4);
+                            extensions = new HashMap<CaseInsensitiveChar,String>(4);
                         }
                         extensions.put(key, bcpExt.substring(2));
                     }
@@ -334,7 +334,7 @@
         if (privateuse != null && privateuse.length() > 0) {
             // privateuse string contains prefix, e.g. "x-abc-def"
             if (extensions == null) {
-                extensions = new HashMap<>(1);
+                extensions = new HashMap<CaseInsensitiveChar,String>(1);
             }
             extensions.put(new CaseInsensitiveChar(privateuse), privateuse.substring(2));
         }
@@ -442,19 +442,19 @@
                     UnicodeLocaleExtension ue = (UnicodeLocaleExtension)e;
                     for (String uatr : ue.getUnicodeLocaleAttributes()) {
                         if (uattributes == null) {
-                            uattributes = new HashSet<>(4);
+                            uattributes = new HashSet<CaseInsensitiveString>(4);
                         }
                         uattributes.add(new CaseInsensitiveString(uatr));
                     }
                     for (String ukey : ue.getUnicodeLocaleKeys()) {
                         if (ukeywords == null) {
-                            ukeywords = new HashMap<>(4);
+                            ukeywords = new HashMap<CaseInsensitiveString,String>(4);
                         }
                         ukeywords.put(new CaseInsensitiveString(ukey), ue.getUnicodeLocaleType(ukey));
                     }
                 } else {
                     if (extensions == null) {
-                        extensions = new HashMap<>(4);
+                        extensions = new HashMap<CaseInsensitiveChar,String>(4);
                     }
                     extensions.put(new CaseInsensitiveChar(key), e.getValue());
                 }
@@ -604,7 +604,7 @@
                 break;
             }
             if (uattributes == null) {
-                uattributes = new HashSet<>(4);
+                uattributes = new HashSet<CaseInsensitiveString>(4);
             }
             uattributes.add(new CaseInsensitiveString(itr.current()));
             itr.next();
@@ -622,7 +622,7 @@
                     assert(typeStart == -1 || typeEnd != -1);
                     type = (typeStart == -1) ? "" : subtags.substring(typeStart, typeEnd);
                     if (ukeywords == null) {
-                        ukeywords = new HashMap<>(4);
+                        ukeywords = new HashMap<CaseInsensitiveString,String>(4);
                     }
                     ukeywords.put(key, type);
 
@@ -652,7 +652,7 @@
                     assert(typeStart == -1 || typeEnd != -1);
                     type = (typeStart == -1) ? "" : subtags.substring(typeStart, typeEnd);
                     if (ukeywords == null) {
-                        ukeywords = new HashMap<>(4);
+                        ukeywords = new HashMap<CaseInsensitiveString,String>(4);
                     }
                     ukeywords.put(key, type);
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LanguageTag.java openjdk-boot/jdk/src/share/classes/sun/util/locale/LanguageTag.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LanguageTag.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/locale/LanguageTag.java	2011-07-12 16:56:06.818261891 +0100
@@ -62,7 +62,7 @@
     // Map contains grandfathered tags and its preferred mappings from
     // http://www.ietf.org/rfc/rfc5646.txt
     // Keys are lower-case strings.
-    private static final Map<String, String[]> GRANDFATHERED = new HashMap<>();
+    private static final Map<String, String[]> GRANDFATHERED = new HashMap<String,String[]>();
 
     static {
         // grandfathered = irregular           ; non-redundant tags registered
@@ -257,7 +257,7 @@
             }
             found = true;
             if (extlangs.isEmpty()) {
-                extlangs = new ArrayList<>(3);
+                extlangs = new ArrayList<String>(3);
             }
             extlangs.add(s);
             sts.parseLength = itr.currentEnd();
@@ -322,7 +322,7 @@
             }
             found = true;
             if (variants.isEmpty()) {
-                variants = new ArrayList<>(3);
+                variants = new ArrayList<String>(3);
             }
             variants.add(s);
             sts.parseLength = itr.currentEnd();
@@ -365,7 +365,7 @@
                 }
 
                 if (extensions.isEmpty()) {
-                    extensions = new ArrayList<>(4);
+                    extensions = new ArrayList<String>(4);
                 }
                 extensions.add(sb.toString());
                 found = true;
@@ -462,7 +462,7 @@
                     break;
                 }
                 if (variants == null) {
-                    variants = new ArrayList<>();
+                    variants = new ArrayList<String>();
                 }
                 variants.add(var);  // Do not canonicalize!
                 varitr.next();
@@ -503,7 +503,7 @@
                     privateuse = ext.getValue();
                 } else {
                     if (extensions == null) {
-                        extensions = new ArrayList<>();
+                        extensions = new ArrayList<String>();
                     }
                     extensions.add(locextKey.toString() + SEP + ext.getValue());
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LocaleExtensions.java openjdk-boot/jdk/src/share/classes/sun/util/locale/LocaleExtensions.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LocaleExtensions.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/locale/LocaleExtensions.java	2011-07-12 16:56:06.818261891 +0100
@@ -81,7 +81,7 @@
         }
 
         // Build extension map
-        SortedMap<Character, Extension> map = new TreeMap<>();
+        SortedMap<Character, Extension> map = new TreeMap<Character,Extension>();
         if (hasExtension) {
             for (Entry<CaseInsensitiveChar, String> ext : extensions.entrySet()) {
                 char key = LocaleUtils.toLower(ext.getKey().value());
@@ -104,14 +104,14 @@
             SortedMap<String, String> ukmap = null;
 
             if (hasUAttributes) {
-                uaset = new TreeSet<>();
+                uaset = new TreeSet<String>();
                 for (CaseInsensitiveString cis : uattributes) {
                     uaset.add(LocaleUtils.toLowerString(cis.value()));
                 }
             }
 
             if (hasUKeywords) {
-                ukmap = new TreeMap<>();
+                ukmap = new TreeMap<String,String>();
                 for (Entry<CaseInsensitiveString, String> kwd : ukeywords.entrySet()) {
                     String key = LocaleUtils.toLowerString(kwd.getKey().value());
                     String type = LocaleUtils.toLowerString(kwd.getValue());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java openjdk-boot/jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java	2011-07-12 16:56:06.818261891 +0100
@@ -38,14 +38,14 @@
 
 public abstract class LocaleObjectCache<K, V> {
     private ConcurrentMap<K, CacheEntry<K, V>> map;
-    private ReferenceQueue<V> queue = new ReferenceQueue<>();
+    private ReferenceQueue<V> queue = new ReferenceQueue<V>();
 
     public LocaleObjectCache() {
         this(16, 0.75f, 16);
     }
 
     public LocaleObjectCache(int initialCapacity, float loadFactor, int concurrencyLevel) {
-        map = new ConcurrentHashMap<>(initialCapacity, loadFactor, concurrencyLevel);
+        map = new ConcurrentHashMap<K, CacheEntry<K,V>>(initialCapacity, loadFactor, concurrencyLevel);
     }
 
     public V get(K key) {
@@ -64,7 +64,7 @@
                 return null;
             }
 
-            CacheEntry<K, V> newEntry = new CacheEntry<>(key, newVal, queue);
+            CacheEntry<K, V> newEntry = new CacheEntry<K,V>(key, newVal, queue);
 
             while (value == null) {
                 cleanStaleEntries();
@@ -81,7 +81,7 @@
     }
 
     protected V put(K key, V value) {
-        CacheEntry<K, V> entry = new CacheEntry<>(key, value, queue);
+        CacheEntry<K, V> entry = new CacheEntry<K,V>(key, value, queue);
         CacheEntry<K, V> oldEntry = map.put(key, entry);
         return (oldEntry == null) ? null : oldEntry.get();
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/logging/PlatformLogger.java openjdk-boot/jdk/src/share/classes/sun/util/logging/PlatformLogger.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/logging/PlatformLogger.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/logging/PlatformLogger.java	2011-07-12 16:56:06.810261758 +0100
@@ -113,7 +113,7 @@
 
     // Table of known loggers.  Maps names to PlatformLoggers.
     private static Map<String,WeakReference<PlatformLogger>> loggers =
-        new HashMap<>();
+        new HashMap<String,WeakReference<PlatformLogger>>();
 
     /**
      * Returns a PlatformLogger of a given name.
@@ -126,7 +126,7 @@
         }
         if (log == null) {
             log = new PlatformLogger(name);
-            loggers.put(name, new WeakReference<>(log));
+            loggers.put(name, new WeakReference<PlatformLogger>(log));
         }
         return log;
     }
@@ -469,7 +469,7 @@
      */
     static class JavaLogger extends LoggerProxy {
         private static final Map<Integer, Object> levelObjects =
-            new HashMap<>();
+            new HashMap<Integer, Object>();
 
         static {
             if (LoggingSupport.isAvailable()) {
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/Demo.java openjdk-boot/jdk/src/share/demo/nio/zipfs/Demo.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/Demo.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/Demo.java	2011-07-12 16:56:06.810261758 +0100
@@ -151,7 +151,7 @@
         }
 
         Action action = Action.valueOf(args[0]);
-        Map<String, Object> env = env = new HashMap<>();
+        Map<String, Object> env = env = new HashMap<String,Object>();
         if (action == Action.create)
             env.put("create", "true");
         try (FileSystem fs = provider.newFileSystem(Paths.get(args[1]), env)) {
@@ -647,9 +647,9 @@
 
     private static void fchCopy(Path src, Path dst) throws IOException
     {
-        Set<OpenOption> read = new HashSet<>();
+        Set<OpenOption> read = new HashSet<OpenOption>();
         read.add(READ);
-        Set<OpenOption> openwrite = new HashSet<>();
+        Set<OpenOption> openwrite = new HashSet<OpenOption>();
         openwrite.add(CREATE_NEW);
         openwrite.add(WRITE);
 
@@ -667,9 +667,9 @@
 
     private static void chCopy(Path src, Path dst) throws IOException
     {
-        Set<OpenOption> read = new HashSet<>();
+        Set<OpenOption> read = new HashSet<OpenOption>();
         read.add(READ);
-        Set<OpenOption> openwrite = new HashSet<>();
+        Set<OpenOption> openwrite = new HashSet<OpenOption>();
         openwrite.add(CREATE_NEW);
         openwrite.add(WRITE);
 
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipCoder.java openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipCoder.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipCoder.java	2011-03-14 22:10:33.000000000 +0000
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipCoder.java	2011-07-12 16:56:06.810261758 +0100
@@ -133,8 +133,8 @@
         return new ZipCoder(Charset.defaultCharset());
     }
 
-    private final ThreadLocal<CharsetDecoder> decTL = new ThreadLocal<>();
-    private final ThreadLocal<CharsetEncoder> encTL = new ThreadLocal<>();
+    private final ThreadLocal<CharsetDecoder> decTL = new ThreadLocal<CharsetDecoder>();
+    private final ThreadLocal<CharsetEncoder> encTL = new ThreadLocal<CharsetEncoder>();r
 
     private CharsetDecoder decoder() {
         CharsetDecoder dec = decTL.get();
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileAttributeView.java openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileAttributeView.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileAttributeView.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileAttributeView.java	2011-07-12 16:56:06.810261758 +0100
@@ -125,7 +125,7 @@
         throws IOException
     {
         ZipFileAttributes zfas = readAttributes();
-        LinkedHashMap<String, Object> map = new LinkedHashMap<>();
+        LinkedHashMap<String, Object> map = new LinkedHashMap<String,Object>();
         if ("*".equals(attributes)) {
             for (AttrID id : AttrID.values()) {
                 try {
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystem.java openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystem.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystem.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystem.java	2011-07-12 16:56:06.810261758 +0100
@@ -147,7 +147,7 @@
 
     @Override
     public Iterable<Path> getRootDirectories() {
-        ArrayList<Path> pathArr = new ArrayList<>();
+        ArrayList<Path> pathArr = new ArrayList<Path>();
         pathArr.add(new ZipPath(this, new byte[]{'/'}));
         return pathArr;
     }
@@ -192,7 +192,7 @@
 
     @Override
     public Iterable<FileStore> getFileStores() {
-        ArrayList<FileStore> list = new ArrayList<>(1);
+        ArrayList<FileStore> list = new ArrayList<FileStore>(1);
         list.add(new ZipFileStore(new ZipPath(this, new byte[]{'/'})));
         return list;
     }
@@ -258,7 +258,7 @@
             endWrite();
         }
         if (!streams.isEmpty()) {       // unlock and close all remaining streams
-            Set<InputStream> copy = new HashSet<>(streams);
+            Set<InputStream> copy = new HashSet<InputStream>(streams);
             for (InputStream is: copy)
                 is.close();
         }
@@ -386,7 +386,7 @@
             IndexNode inode = getInode(path);
             if (inode == null)
                 throw new NotDirectoryException(getString(path));
-            List<Path> list = new ArrayList<>();
+            List<Path> list = new ArrayList<Path>();
             IndexNode child = inode.child;
             while (child != null) {
                 ZipPath zp = toZipPath(child.name);
@@ -815,7 +815,7 @@
 
     // the ex-channel and ex-path that need to close when their outstanding
     // input streams are all closed by the obtainers.
-    private Set<ExChannelCloser> exChClosers = new HashSet<>();
+    private Set<ExChannelCloser> exChClosers = new HashSet<ExChannelCloser>();
 
     private Set<Path> tmppaths = Collections.synchronizedSet(new HashSet<Path>());
     private Path getTempPathForEntry(byte[] path) throws IOException {
@@ -1012,7 +1012,7 @@
     private byte[] initCEN() throws IOException {
         end = findEND();
         if (end.endpos == 0) {
-            inodes = new LinkedHashMap<>(10);
+            inodes = new LinkedHashMap<IndexNode,IndexNode>(10);
             locpos = 0;
             buildNodeTree();
             return null;         // only END header present
@@ -1033,7 +1033,7 @@
             zerror("read CEN tables failed");
         }
         // Iterate through the entries in the central directory
-        inodes = new LinkedHashMap<>(end.centot + 1);
+        inodes = new LinkedHashMap<IndexNode,IndexNode>(end.centot + 1);
         int pos = 0;
         int limit = cen.length - ENDHDR;
         while (pos < limit) {
@@ -1180,7 +1180,7 @@
             return;
         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
         OutputStream os = Files.newOutputStream(tmpFile, WRITE);
-        ArrayList<Entry> elist = new ArrayList<>(inodes.size());
+        ArrayList<Entry> elist = new ArrayList<Entry>(inodes.size());
         long written = 0;
         byte[] buf = new byte[8192];
         Entry e = null;
@@ -1592,7 +1592,7 @@
     // Maxmum number of de/inflater we cache
     private final int MAX_FLATER = 20;
     // List of available Inflater objects for decompression
-    private final List<Inflater> inflaters = new ArrayList<>();
+    private final List<Inflater> inflaters = new ArrayList<Inflater>();
 
     // Gets an inflater from the list of available inflaters or allocates
     // a new one.
@@ -1621,7 +1621,7 @@
     }
 
     // List of available Deflater objects for compression
-    private final List<Deflater> deflaters = new ArrayList<>();
+    private final List<Deflater> deflaters = new ArrayList<Deflater>();
 
     // Gets an deflater from the list of available deflaters or allocates
     // a new one.
@@ -2331,7 +2331,7 @@
     private void buildNodeTree() throws IOException {
         beginWrite();
         try {
-            HashSet<IndexNode> dirs = new HashSet<>();
+            HashSet<IndexNode> dirs = new HashSet<IndexNode>();
             IndexNode root = new IndexNode(ROOTPATH, -1);
             inodes.put(root, root);
             dirs.add(root);
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystemProvider.java openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystemProvider.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystemProvider.java	2011-06-11 00:38:11.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystemProvider.java	2011-07-12 16:56:06.810261758 +0100
@@ -53,7 +53,7 @@
 public class ZipFileSystemProvider extends FileSystemProvider {
 
 
-    private final Map<Path, ZipFileSystem> filesystems = new HashMap<>();
+    private final Map<Path, ZipFileSystem> filesystems = new HashMap<Path,ZipFileSystem>();
 
     public ZipFileSystemProvider() {}
 
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/java/lang/ProcessEnvironment.java openjdk-boot/jdk/src/solaris/classes/java/lang/ProcessEnvironment.java
--- openjdk-boot.orig/jdk/src/solaris/classes/java/lang/ProcessEnvironment.java	2011-06-11 00:38:13.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/java/lang/ProcessEnvironment.java	2011-07-12 16:56:06.814261825 +0100
@@ -68,7 +68,7 @@
         // We cache the C environment.  This means that subsequent calls
         // to putenv/setenv from C will not be visible from Java code.
         byte[][] environ = environ();
-        theEnvironment = new HashMap<>(environ.length/2 + 3);
+        theEnvironment = new HashMap<Variable,Value>(environ.length/2 + 3);
         // Read environment variables back to front,
         // so that earlier variables override later ones.
         for (int i = environ.length-1; i > 0; i-=2)
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java openjdk-boot/jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java
--- openjdk-boot.orig/jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java	2011-07-12 15:23:26.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java	2011-07-12 16:56:06.814261825 +0100
@@ -354,7 +354,7 @@
      * log against that map.  The resulting map is then written back
      * to the disk.
      */
-    final List<Change> changeLog = new ArrayList<>();
+    final List<Change> changeLog = new ArrayList<Change>();
 
     /**
      * Represents a change to a preference.
@@ -507,7 +507,7 @@
         });
         if (newNode) {
             // These 2 things guarantee node will get wrtten at next flush/sync
-            prefsCache = new TreeMap<>();
+            prefsCache = new TreeMap<String, String>();
             nodeCreate = new NodeCreate();
             changeLog.add(nodeCreate);
         }
@@ -550,7 +550,7 @@
             loadCache();
         } catch(Exception e) {
             // assert lastSyncTime == 0;
-            prefsCache = new TreeMap<>();
+            prefsCache = new TreeMap<String, String>();
         }
     }
 
@@ -567,7 +567,7 @@
             AccessController.doPrivileged(
                 new PrivilegedExceptionAction<Void>() {
                 public Void run() throws BackingStoreException {
-                    Map<String, String> m = new TreeMap<>();
+                    Map<String, String> m = new TreeMap<String, String>();
                     long newLastSyncTime = 0;
                     FileInputStream fis = null;
                     try {
@@ -581,7 +581,7 @@
                             prefsFile.renameTo( new File(
                                                     prefsFile.getParentFile(),
                                                   "IncorrectFormatPrefs.xml"));
-                            m = new TreeMap<>();
+                            m = new TreeMap<String, String>();
                         } else if (e instanceof FileNotFoundException) {
                         getLogger().warning("Prefs file removed in background "
                                            + prefsFile.getPath());
@@ -662,7 +662,7 @@
         return AccessController.doPrivileged(
             new PrivilegedAction<String[]>() {
                 public String[] run() {
-                    List<String> result = new ArrayList<>();
+                    List<String> result = new ArrayList<String>();
                     File[] dirContents = dir.listFiles();
                     if (dirContents != null) {
                         for (int i = 0; i < dirContents.length; i++)
@@ -810,7 +810,7 @@
         } else if (lastSyncTime != 0 && !dir.exists()) {
             // This node was removed in the background.  Playback any changes
             // against a virgin (empty) Map.
-            prefsCache = new TreeMap<>();
+            prefsCache = new TreeMap<String, String>();
             replayChanges();
         }
         if (!changeLog.isEmpty()) {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/net/dns/ResolverConfigurationImpl.java openjdk-boot/jdk/src/solaris/classes/sun/net/dns/ResolverConfigurationImpl.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/net/dns/ResolverConfigurationImpl.java	2011-04-14 01:30:00.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/net/dns/ResolverConfigurationImpl.java	2011-07-12 16:56:06.814261825 +0100
@@ -60,7 +60,7 @@
                                           int maxperkeyword,
                                           int maxkeywords)
     {
-        LinkedList<String> ll = new LinkedList<>();
+        LinkedList<String> ll = new LinkedList<String>();
 
         try {
             BufferedReader in =
@@ -200,7 +200,7 @@
         // no local domain so try fallback (RPC) domain or
         // hostname
 
-        sl = new LinkedList<>();
+        sl = new LinkedList<String>();
         String domain = fallbackDomain0();
         if (domain != null && domain.length() > 0) {
             sl.add(domain);
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/cs/ext/CompoundTextSupport.java openjdk-boot/jdk/src/solaris/classes/sun/nio/cs/ext/CompoundTextSupport.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/cs/ext/CompoundTextSupport.java	2011-04-14 01:30:00.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/cs/ext/CompoundTextSupport.java	2011-07-12 16:56:06.814261825 +0100
@@ -153,12 +153,12 @@
 
     static {
         HashMap<ControlSequence, String> tSequenceToEncodingMap =
-            new HashMap<>(33, 1.0f);
+            new HashMap<ControlSequence, String>(33, 1.0f);
         HashMap<ControlSequence, Boolean> tHighBitsMap =
-            new HashMap<>(31, 1.0f);
+            new HashMap<ControlSequence, Boolean>(31, 1.0f);
         HashMap<String, ControlSequence> tEncodingToSequenceMap =
-            new HashMap<>(21, 1.0f);
-        ArrayList<String> tEncodings = new ArrayList<>(21);
+            new HashMap<String, ControlSequence>(21, 1.0f);
+        ArrayList<String> tEncodings = new ArrayList<String>(21);
 
         if (!(isEncodingSupported("US-ASCII") &&
               isEncodingSupported("ISO-8859-1")))
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java	2011-06-11 00:38:13.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java	2011-07-12 16:56:06.814261825 +0100
@@ -53,7 +53,7 @@
         static final Set<String> supportedFileAttributeViews =
             supportedFileAttributeViews();
         private static Set<String> supportedFileAttributeViews() {
-            Set<String> result = new HashSet<>();
+            Set<String> result = new HashSet<String>();
             result.addAll(standardFileAttributeViews());
             // additional Linux-specific views
             result.add("dos");
@@ -76,7 +76,7 @@
      * Returns object to iterate over the mount entries in the given fstab file.
      */
     Iterable<UnixMountEntry> getMountEntries(String fstab) {
-        ArrayList<UnixMountEntry> entries = new ArrayList<>();
+        ArrayList<UnixMountEntry> entries = new ArrayList<UnixMountEntry>();
         try {
             long fp = setmntent(fstab.getBytes(), "r".getBytes());
             try {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java	2011-06-11 00:38:13.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java	2011-07-12 16:56:06.814261825 +0100
@@ -63,7 +63,7 @@
 
     // Parses buffer as array of NULL-terminated C strings.
     private List<String> asList(long address, int size) {
-        List<String> list = new ArrayList<>();
+        List<String> list = new ArrayList<String>();
         int start = 0;
         int pos = 0;
         while (pos < size) {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java	2011-06-11 00:38:13.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java	2011-07-12 16:56:06.814261825 +0100
@@ -198,7 +198,7 @@
      * Decode the buffer, returning an ACL
      */
     private static List<AclEntry> decode(long address, int n) {
-        ArrayList<AclEntry> acl = new ArrayList<>(n);
+        ArrayList<AclEntry> acl = new ArrayList<AclEntry>(n);
         for (int i=0; i<n; i++) {
             long offset = address + i*SIZEOF_ACE_T;
 
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisFileSystem.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisFileSystem.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisFileSystem.java	2011-06-11 00:38:13.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisFileSystem.java	2011-07-12 16:56:06.814261825 +0100
@@ -76,7 +76,7 @@
         static final Set<String> supportedFileAttributeViews =
             supportedFileAttributeViews();
         private static Set<String> supportedFileAttributeViews() {
-            Set<String> result = new HashSet<>();
+            Set<String> result = new HashSet<String>();
             result.addAll(standardFileAttributeViews());
             // additional Solaris-specific views
             result.add("acl");
@@ -101,7 +101,7 @@
      */
     @Override
     Iterable<UnixMountEntry> getMountEntries() {
-        ArrayList<UnixMountEntry> entries = new ArrayList<>();
+        ArrayList<UnixMountEntry> entries = new ArrayList<UnixMountEntry>();
         try {
             UnixPath mnttab = new UnixPath(this, "/etc/mnttab");
             long fp = fopen(mnttab, "r");
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java	2011-06-11 00:38:13.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java	2011-07-12 16:56:06.814261825 +0100
@@ -83,7 +83,7 @@
                 }
 
                 // read list of extended attributes
-                List<String> list = new ArrayList<>();
+                List<String> list = new ArrayList<String>();
                 try {
                     byte[] name;
                     while ((name = readdir(dp)) != null) {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributes.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributes.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributes.java	2011-06-11 00:38:13.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributes.java	2011-07-12 16:56:06.814261825 +0100
@@ -194,7 +194,7 @@
     @Override
     public Set<PosixFilePermission> permissions() {
         int bits = (st_mode & UnixConstants.S_IAMB);
-        HashSet<PosixFilePermission> perms = new HashSet<>();
+        HashSet<PosixFilePermission> perms = new HashSet<PosixFilePermission>();
 
         if ((bits & UnixConstants.S_IRUSR) > 0)
             perms.add(PosixFilePermission.OWNER_READ);
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/java/lang/ProcessEnvironment.java openjdk-boot/jdk/src/windows/classes/java/lang/ProcessEnvironment.java
--- openjdk-boot.orig/jdk/src/windows/classes/java/lang/ProcessEnvironment.java	2011-06-11 00:38:15.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/java/lang/ProcessEnvironment.java	2011-07-12 16:56:06.814261825 +0100
@@ -250,7 +250,8 @@
                                    envblock.substring(eql+1,end));
         }
 
-        theCaseInsensitiveEnvironment = new TreeMap<>(nameComparator);
+        theCaseInsensitiveEnvironment
+            = new TreeMap<String,String>(nameComparator);
         theCaseInsensitiveEnvironment.putAll(theEnvironment);
     }
 
@@ -295,7 +296,8 @@
     // Only for use by ProcessImpl.start()
     String toEnvironmentBlock() {
         // Sort Unicode-case-insensitively by name
-        List<Map.Entry<String,String>> list = new ArrayList<>(entrySet());
+        List<Map.Entry<String,String>> list
+            = new ArrayList<Map.Entry<String,String>>(entrySet());
         Collections.sort(list, entryComparator);
 
         StringBuilder sb = new StringBuilder(size()*30);
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/net/dns/ResolverConfigurationImpl.java openjdk-boot/jdk/src/windows/classes/sun/net/dns/ResolverConfigurationImpl.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/net/dns/ResolverConfigurationImpl.java	2011-04-14 01:30:00.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/net/dns/ResolverConfigurationImpl.java	2011-07-12 16:56:06.814261825 +0100
@@ -63,7 +63,7 @@
     // Parse string that consists of token delimited by space or commas
     // and return LinkedHashMap
     private LinkedList<String> stringToList(String str) {
-        LinkedList<String> ll = new LinkedList<>();
+        LinkedList<String> ll = new LinkedList<String>();
 
         // comma and space are valid delimites
         StringTokenizer st = new StringTokenizer(str, ", ");
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsFileSystem.java openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsFileSystem.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsFileSystem.java	2011-06-11 00:38:15.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsFileSystem.java	2011-07-12 16:56:06.814261825 +0100
@@ -128,7 +128,7 @@
         }
 
         // iterate over roots, ignoring those that the security manager denies
-        ArrayList<Path> result = new ArrayList<>();
+        ArrayList<Path> result = new ArrayList<Path>();
         SecurityManager sm = System.getSecurityManager();
         for (int i = 0; i <= 25; i++) {  // 0->A, 1->B, 2->C...
             if ((drives & (1 << i)) != 0) {
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsPath.java openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsPath.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsPath.java	2011-06-11 00:38:15.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsPath.java	2011-07-12 16:56:06.814261825 +0100
@@ -575,7 +575,7 @@
     // generate offset array
     private void initOffsets() {
         if (offsets == null) {
-            ArrayList<Integer> list = new ArrayList<>();
+            ArrayList<Integer> list = new ArrayList<Integer>();
             if (isEmpty()) {
                 // empty path considered to have one name element
                 list.add(0);
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsSecurityDescriptor.java openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsSecurityDescriptor.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsSecurityDescriptor.java	2011-06-11 00:38:15.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsSecurityDescriptor.java	2011-07-12 16:56:06.814261825 +0100
@@ -378,7 +378,7 @@
             AclInformation aclInfo = GetAclInformation(aclAddress);
             aceCount = aclInfo.aceCount();
         }
-        ArrayList<AclEntry> result = new ArrayList<>(aceCount);
+        ArrayList<AclEntry> result = new ArrayList<AclEntry>(aceCount);
 
         // decode each of the ACEs to AclEntry objects
         for (int i=0; i<aceCount; i++) {
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsUserDefinedFileAttributeView.java openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsUserDefinedFileAttributeView.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsUserDefinedFileAttributeView.java	2011-06-11 00:38:15.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsUserDefinedFileAttributeView.java	2011-07-12 16:56:06.814261825 +0100
@@ -65,7 +65,7 @@
 
     // enumerates the file streams using FindFirstStream/FindNextStream APIs.
     private List<String> listUsingStreamEnumeration() throws IOException {
-        List<String> list = new ArrayList<>();
+        List<String> list = new ArrayList<String>();
         try {
             FirstStream first = FindFirstStream(file.getPathForWin32Calls());
             if (first != null) {
@@ -114,7 +114,7 @@
         NativeBuffer buffer = null;
 
         // result with names of alternative data streams
-        final List<String> list = new ArrayList<>();
+        final List<String> list = new ArrayList<String>();
 
         try {
             buffer = NativeBuffers.getNativeBuffer(BUFFER_SIZE);
@@ -216,7 +216,7 @@
         // wrap with channel
         FileChannel fc = null;
         try {
-            Set<OpenOption> opts = new HashSet<>();
+            Set<OpenOption> opts = new HashSet<OpenOption>();
             opts.add(READ);
             if (!followLinks)
                 opts.add(WindowsChannelFactory.OPEN_REPARSE_POINT);
@@ -243,7 +243,7 @@
         // wrap with channel
         FileChannel fc = null;
         try {
-            Set<OpenOption> opts = new HashSet<>();
+            Set<OpenOption> opts = new HashSet<OpenOption>();
             opts.add(READ);
             if (!followLinks)
                 opts.add(WindowsChannelFactory.OPEN_REPARSE_POINT);
@@ -298,7 +298,7 @@
             x.rethrowAsIOException(file);
         }
         try {
-            Set<OpenOption> opts = new HashSet<>();
+            Set<OpenOption> opts = new HashSet<OpenOption>();
             if (!followLinks)
                 opts.add(WindowsChannelFactory.OPEN_REPARSE_POINT);
             opts.add(CREATE);
diff -Nru openjdk-boot.orig/jdk/test/java/io/Serializable/NPEProvoker/NPEProvoker.java openjdk-boot/jdk/test/java/io/Serializable/NPEProvoker/NPEProvoker.java
--- openjdk-boot.orig/jdk/test/java/io/Serializable/NPEProvoker/NPEProvoker.java	2011-06-11 00:38:16.000000000 +0100
+++ openjdk-boot/jdk/test/java/io/Serializable/NPEProvoker/NPEProvoker.java	2011-07-12 16:56:06.814261825 +0100
@@ -56,7 +56,7 @@
     public static void main(String[] args) {
         System.err.println("\n Regression test for bug 6541870\n");
         try {
-            ArrayList<NPEProvoker> list = new ArrayList<>();
+            ArrayList<NPEProvoker> list = new ArrayList<NPEProvoker>();
             list.add(new NPEProvoker());
             ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ObjectOutputStream oos = new ObjectOutputStream(baos);
diff -Nru openjdk-boot.orig/jdk/test/java/lang/instrument/ilib/InjectBytecodes.java openjdk-boot/jdk/test/java/lang/instrument/ilib/InjectBytecodes.java
--- openjdk-boot.orig/jdk/test/java/lang/instrument/ilib/InjectBytecodes.java	2011-06-11 00:38:17.000000000 +0100
+++ openjdk-boot/jdk/test/java/lang/instrument/ilib/InjectBytecodes.java	2011-07-12 16:56:06.814261825 +0100
@@ -50,7 +50,7 @@
     private final Injector[] after  = new Injector[256];
     private final String className;
     private final String methodName;
-    private final Map<Integer,byte[]> snippets = new HashMap<>();
+    private final Map<Integer,byte[]> snippets = new HashMap<Integer,byte[]>();
 
     private int pos;
     private int newPos;
diff -Nru openjdk-boot.orig/jdk/test/java/lang/instrument/ilib/Inject.java openjdk-boot/jdk/test/java/lang/instrument/ilib/Inject.java
--- openjdk-boot.orig/jdk/test/java/lang/instrument/ilib/Inject.java	2011-06-11 00:38:17.000000000 +0100
+++ openjdk-boot/jdk/test/java/lang/instrument/ilib/Inject.java	2011-07-12 16:56:06.814261825 +0100
@@ -107,7 +107,7 @@
     class IndexedInjector implements TrackerInjector {
         int counter = 0;
         int tracker;
-        List<Info> infoList = new ArrayList<>();
+        List<Info> infoList = new ArrayList<Info>();
 
         public int stackSize(int currentSize) {
             return currentSize + 1;
diff -Nru openjdk-boot.orig/jdk/test/java/lang/reflect/Generics/TestPlainArrayNotGeneric.java openjdk-boot/jdk/test/java/lang/reflect/Generics/TestPlainArrayNotGeneric.java
--- openjdk-boot.orig/jdk/test/java/lang/reflect/Generics/TestPlainArrayNotGeneric.java	2011-06-11 00:38:17.000000000 +0100
+++ openjdk-boot/jdk/test/java/lang/reflect/Generics/TestPlainArrayNotGeneric.java	2011-07-12 16:56:06.814261825 +0100
@@ -103,7 +103,7 @@
         }
     }
 
-    private static final Set<Type> checking = new HashSet<>();
+    private static final Set<Type> checking = new HashSet<Type>();
 
     private static void check(Type t, String what) {
         if (t == null || !checking.add(t))
diff -Nru openjdk-boot.orig/jdk/test/java/util/logging/ClassLoaderLeakTest.java openjdk-boot/jdk/test/java/util/logging/ClassLoaderLeakTest.java
--- openjdk-boot.orig/jdk/test/java/util/logging/ClassLoaderLeakTest.java	2011-06-11 00:38:18.000000000 +0100
+++ openjdk-boot/jdk/test/java/util/logging/ClassLoaderLeakTest.java	2011-07-12 16:56:06.814261825 +0100
@@ -89,7 +89,7 @@
 
          MyClassLoader appClassLoader = new MyClassLoader(urls, "test0");
          WeakReference<MyClassLoader> ref =
-                 new WeakReference<>(appClassLoader);
+                 new WeakReference<MyClassLoader>(appClassLoader);
 
 
          Thread appThread = new Thread(appsThreadGroup, launcher, "AppThread-0");
diff -Nru openjdk-boot.orig/jdk/test/java/util/Random/DistinctSeeds.java openjdk-boot/jdk/test/java/util/Random/DistinctSeeds.java
--- openjdk-boot.orig/jdk/test/java/util/Random/DistinctSeeds.java	2011-06-11 00:38:17.000000000 +0100
+++ openjdk-boot/jdk/test/java/util/Random/DistinctSeeds.java	2011-07-12 16:56:06.818261891 +0100
@@ -59,7 +59,7 @@
             }
         }
         final int threadCount = 2;
-        List<RandomCollector> collectors = new ArrayList<>();
+        List<RandomCollector> collectors = new ArrayList<RandomCollector>();
         List<Thread> threads = new ArrayList<Thread>();
         for (int i = 0; i < threadCount; i++) {
             RandomCollector r = new RandomCollector();
diff -r 483d8dacfbd8 src/share/classes/sun/net/www/URLConnection.java
--- openjdk-boot/jdk/src/share/classes/sun/net/www/URLConnection.java	Mon Jul 11 22:06:00 2011 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/www/URLConnection.java	Tue Jul 12 17:25:03 2011 +0100
@@ -239,7 +239,7 @@
         url = null;
     }
 
-    private static HashMap<String,Void> proxiedHosts = new HashMap<>();
+    private static HashMap<String,Void> proxiedHosts = new HashMap<String,Void>();
 
     public synchronized static void setProxiedHost(String host) {
         proxiedHosts.put(host.toLowerCase(), null);
