diff -Nru openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/encoding/CachedCodeBase.java openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/encoding/CachedCodeBase.java
--- openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/encoding/CachedCodeBase.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/encoding/CachedCodeBase.java	2018-05-20 04:52:08.123913888 +0100
@@ -58,7 +58,7 @@
     private CorbaConnection conn;
 
     private static Object iorMapLock = new Object();
-    private static Hashtable<IOR,CodeBase> iorMap = new Hashtable<>();
+    private static Hashtable<IOR,CodeBase> iorMap = new Hashtable<IOR,CodeBase>();
 
     public static synchronized void cleanCache( ORB orb ) {
         synchronized (iorMapLock) {
diff -Nru openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java
--- openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java	2018-05-20 04:38:34.416808053 +0100
+++ openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java	2018-05-20 04:52:08.123913888 +0100
@@ -481,7 +481,7 @@
             while (cls != fnscl) {
                 ProtectionDomain pd = cls.getProtectionDomain();
                 if (pd != null) {
-                    if (pds == null) pds = new HashSet<>();
+                    if (pds == null) pds = new HashSet<ProtectionDomain>();
                     pds.add(pd);
                 }
                 cls = cls.getSuperclass();
@@ -489,7 +489,7 @@
                     // that's not supposed to happen
                     // make a ProtectionDomain with no permission.
                     // should we throw instead?
-                    if (pds == null) pds = new HashSet<>();
+                    if (pds == null) pds = new HashSet<ProtectionDomain>();
                     else pds.clear();
                     pds.add(noPermissionsDomain());
                     break;
diff -Nru openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/io/OutputStreamHook.java openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/io/OutputStreamHook.java
--- openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/io/OutputStreamHook.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/io/OutputStreamHook.java	2018-05-20 04:52:08.123913888 +0100
@@ -50,7 +50,7 @@
      */
     private class HookPutFields extends ObjectOutputStream.PutField
     {
-        private Map<String,Object> fields = new HashMap<>();
+        private Map<String,Object> fields = new HashMap<String,Object>();
 
         /**
          * Put the value of the named boolean field into the persistent field.
diff -Nru openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/ior/IORTypeCheckRegistryImpl.java openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/ior/IORTypeCheckRegistryImpl.java
--- openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/ior/IORTypeCheckRegistryImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/ior/IORTypeCheckRegistryImpl.java	2018-05-20 04:52:08.123913888 +0100
@@ -103,7 +103,7 @@
         Set<String> _iorTypeNames = null;
         if (filterProperty != null) {
             String[] tempIorClassNames = filterProperty.split(";");
-            _iorTypeNames = Collections.unmodifiableSet(new HashSet<>(Arrays
+            _iorTypeNames = Collections.unmodifiableSet(new HashSet<String>(Arrays
                     .asList(tempIorClassNames)));
             if (theOrb.orbInitDebugFlag) {
                 dprintConfiguredIorTypeNames();
@@ -119,7 +119,7 @@
         for (Class<?> _stubClass : builtInCorbaStubTypes) {
             tempBuiltinIorTypeNames[i++] = _stubClass.getName();
         }
-        return Collections.unmodifiableSet(new HashSet<>(Arrays
+        return Collections.unmodifiableSet(new HashSet<String>(Arrays
                 .asList(tempBuiltinIorTypeNames)));
     }
 
@@ -160,7 +160,7 @@
             org.omg.PortableServer._ServantActivatorStub.class,
             org.omg.PortableServer.ServantLocator.class,
             org.omg.PortableServer._ServantLocatorStub.class};
-        return new HashSet<>(
+        return new HashSet<Class<?>>(
                 Arrays.asList(tempBuiltinCorbaStubTypes));
     }
 
diff -Nru openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java
--- openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/orb/ORBImpl.java	2018-05-20 04:52:08.123913888 +0100
@@ -1323,7 +1323,7 @@
     protected void shutdownServants(boolean wait_for_completion) {
         Set<ObjectAdapterFactory> oaset;
         synchronized (this) {
-            oaset = new HashSet<>(requestDispatcherRegistry.getObjectAdapterFactories());
+            oaset = new HashSet<ObjectAdapterFactory>(requestDispatcherRegistry.getObjectAdapterFactories());
         }
 
         for (ObjectAdapterFactory oaf : oaset)
diff -Nru openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl.java openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl.java
--- openjdk-boot.orig/corba/src/share/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/corba/src/share/classes/com/sun/corba/se/impl/orbutil/threadpool/ThreadPoolImpl.java	2018-05-20 04:52:08.123913888 +0100
@@ -108,7 +108,7 @@
     private ThreadGroup threadGroup;
 
     Object workersLock = new Object();
-    List<WorkerThread> workers = new ArrayList<>();
+    List<WorkerThread> workers = new ArrayList<WorkerThread>();
 
     /**
      * This constructor is used to create an unbounded threadpool
@@ -154,7 +154,7 @@
         // Copy to avoid concurrent modification problems.
         List<WorkerThread> copy = null;
         synchronized (workersLock) {
-            copy = new ArrayList<>(workers);
+            copy = new ArrayList<WorkerThread>(workers);
         }
 
         for (WorkerThread wt : copy) {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/lib/ExsltSets.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/lib/ExsltSets.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/lib/ExsltSets.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/lib/ExsltSets.java	2018-05-20 04:52:08.123913888 +0100
@@ -192,7 +192,7 @@
     NodeSet dist = new NodeSet();
     dist.setShouldCacheNodes(true);
 
-    Map<String, Node> stringTable = new HashMap<>();
+    Map<String, Node> stringTable = new HashMap<String,Node>();
 
     for (int i = 0; i < nl.getLength(); i++)
     {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/utils/XMLSecurityManager.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/utils/XMLSecurityManager.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/utils/XMLSecurityManager.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/utils/XMLSecurityManager.java	2018-05-20 04:52:08.123913888 +0100
@@ -420,7 +420,7 @@
     }
 
     // Array list to store printed warnings for each SAX parser used
-    private static final CopyOnWriteArrayList<String> printedWarnings = new CopyOnWriteArrayList<>();
+    private static final CopyOnWriteArrayList<String> printedWarnings = new CopyOnWriteArrayList<String>();
 
     /**
      * Prints out warnings if a parser does not support the specified feature/property.
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java	2018-05-20 04:52:08.123913888 +0100
@@ -220,7 +220,7 @@
   public Map<String, Object> getEnvironmentHash()
   {
     // Setup a hash to store various environment information in
-    Map<String, Object> hash = new HashMap<>();
+    Map<String, Object> hash = new HashMap<String,Object>();
 
     // Call various worker methods to fill in the hash
     //  These are explicitly separate for maintenance and so
@@ -523,7 +523,7 @@
   {
 
     if (null == h)
-      h = new HashMap<>();
+	h = new HashMap<String, Object>();
 
     // Grab java version for later use
     try
@@ -620,7 +620,7 @@
             || (0 == jars.length))
       return null;
 
-    List<Map> v = new ArrayList<>();
+    List<Map> v = new ArrayList<Map>();
     StringTokenizer st = new StringTokenizer(cp, File.pathSeparator);
 
     while (st.hasMoreTokens())
@@ -641,7 +641,7 @@
             // If any requested jarName exists, report on
             //  the details of that .jar file
             try {
-                Map<String, String> h = new HashMap<>(2);
+                Map<String, String> h = new HashMap<String,String>(2);
                 // Note "-" char is looked for in appendFoundJars
                 h.put(jars[i] + "-path", f.getAbsolutePath());
 
@@ -660,7 +660,7 @@
                 /* no-op, don't add it  */
             }
           } else {
-            Map<String, String> h = new HashMap<>(2);
+	    Map<String, String> h = new HashMap<String,String>(2);
             // Note "-" char is looked for in appendFoundJars
             h.put(jars[i] + "-path", WARNING + " Classpath entry: "
                     + filename + " does not exist");
@@ -737,7 +737,7 @@
   {
 
     if (null == h)
-      h = new HashMap<>();
+	h = new HashMap<String,Object>();
 
     Class clazz = null;
 
@@ -768,7 +768,7 @@
   {
 
     if (null == h)
-      h = new HashMap<>();
+      h = new HashMap<String,Object>();
 
     try
     {
@@ -854,7 +854,7 @@
   {
 
     if (null == h)
-      h = new HashMap<>();
+	h = new HashMap<String, Object>();
 
     try
     {
@@ -915,7 +915,7 @@
   {
 
     if (null == h)
-      h = new HashMap<>();
+	h = new HashMap<String, Object>();
 
     try
     {
@@ -945,7 +945,7 @@
   {
 
     if (null == h)
-      h = new HashMap<>();
+	h = new HashMap<String, Object>();
 
     final String DOM_CLASS = "org.w3c.dom.Document";
     final String DOM_LEVEL3_METHOD = "getDoctype";  // no parameter
@@ -980,7 +980,7 @@
   {
 
     if (null == h)
-      h = new HashMap<>();
+	h = new HashMap<String, Object>();
 
     final String DOM_LEVEL2_CLASS = "org.w3c.dom.Document";
     final String DOM_LEVEL2_METHOD = "createElementNS";  // String, String
@@ -1056,7 +1056,7 @@
   {
 
     if (null == h)
-      h = new HashMap<>();
+	h = new HashMap<String, Object>();
 
     final String SAX_VERSION1_CLASS = "org.xml.sax.Parser";
     final String SAX_VERSION1_METHOD = "parse";  // String
@@ -1146,7 +1146,7 @@
    */
   static
   {
-    Map<Long, String> jarVersions = new HashMap<>();
+      Map<Long, String> jarVersions = new HashMap<Long, String>();
     jarVersions.put(new Long(857192), "xalan.jar from xalan-j_1_1");
     jarVersions.put(new Long(440237), "xalan.jar from xalan-j_1_2");
     jarVersions.put(new Long(436094), "xalan.jar from xalan-j_1_2_1");
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/CastExpr.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/CastExpr.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/CastExpr.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/CastExpr.java	2018-05-20 04:52:08.123913888 +0100
@@ -51,7 +51,7 @@
     /**
      * Legal conversions between internal types.
      */
-    private static final MultiHashtable<Type, Type> InternalTypeMap = new MultiHashtable<>();
+    private static final MultiHashtable<Type, Type> InternalTypeMap = new MultiHashtable<Type, Type>();
 
     static {
         // Possible type conversions between internal types
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java	2018-05-20 04:52:08.123913888 +0100
@@ -139,7 +139,7 @@
     private boolean       _isStatic = false;
 
     // Legal conversions between internal and Java types.
-    private static final MultiHashtable<Type, JavaType> _internal2Java = new MultiHashtable<>();
+    private static final MultiHashtable<Type, JavaType> _internal2Java = new MultiHashtable<Type, JavaType>();
 
     // Legal conversions between Java and internal types.
     private static final Map<Class<?>, Type> JAVA2INTERNAL;
@@ -254,9 +254,9 @@
 
         _internal2Java.makeUnmodifiable();
 
-        Map<Class<?>, Type> java2Internal = new HashMap<>();
-        Map<String, String> extensionNamespaceTable = new HashMap<>();
-        Map<String, String> extensionFunctionTable = new HashMap<>();
+        Map<Class<?>, Type> java2Internal = new HashMap<Class<?>,Type>();
+        Map<String, String> extensionNamespaceTable = new HashMap<String,String>();
+        Map<String, String> extensionFunctionTable = new HashMap<String,String>();
 
         // Possible conversions between Java and internal types
         java2Internal.put(Boolean.TYPE, Type.Boolean);
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/LiteralElement.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/LiteralElement.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/LiteralElement.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/LiteralElement.java	2018-05-20 04:52:08.127913824 +0100
@@ -107,7 +107,7 @@
 
         // Check if we have any declared namespaces
         if (_accessedPrefixes == null) {
-            _accessedPrefixes = new Hashtable<>();
+            _accessedPrefixes = new Hashtable<String,String>();
         }
         else {
             if (!declared) {
@@ -169,7 +169,7 @@
      */
     public void addAttribute(SyntaxTreeNode attribute) {
         if (_attributeElements == null) {
-            _attributeElements = new ArrayList<>(2);
+            _attributeElements = new ArrayList<SyntaxTreeNode>(2);
         }
         _attributeElements.add(attribute);
     }
@@ -179,7 +179,7 @@
      */
     public void setFirstAttribute(SyntaxTreeNode attribute) {
         if (_attributeElements == null) {
-            _attributeElements = new ArrayList<>(2);
+            _attributeElements = new ArrayList<SyntaxTreeNode>(2);
         }
         _attributeElements.add(0, attribute);
     }
@@ -205,7 +205,7 @@
      * to _ANY_ namespace URI. Used by literal result elements to determine
      */
     public Set<Map.Entry<String, String>> getNamespaceScope(SyntaxTreeNode node) {
-        Map<String, String> all = new HashMap<>();
+        Map<String, String> all = new HashMap<String,String>();
 
         while (node != null) {
             Map<String, String> mapping = node.getPrefixMapping();
@@ -445,7 +445,7 @@
                  }
                  else if (node instanceof XslAttribute) {
                      if (attrsTable == null) {
-                        attrsTable = new HashMap<>();
+			 attrsTable = new HashMap<String,SyntaxTreeNode>();
                          for (int k = 0; k < i; k++) {
                              SyntaxTreeNode n = _attributeElements.get(k);
                              if (n instanceof LiteralAttribute) {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Mode.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Mode.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Mode.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Mode.java	2018-05-20 04:52:08.127913824 +0100
@@ -129,22 +129,22 @@
     /**
      * A mapping between templates and test sequences.
      */
-    private Map<Template, Object> _neededTemplates = new HashMap<>();
+    private Map<Template, Object> _neededTemplates = new HashMap<Template,Object>();
 
     /**
      * A mapping between named templates and Mode objects.
      */
-    private Map<Template, Mode> _namedTemplates = new HashMap<>();
+    private Map<Template, Mode> _namedTemplates = new HashMap<Template,Mode>();
 
     /**
      * A mapping between templates and instruction handles.
      */
-    private Map<Template, InstructionHandle> _templateIHs = new HashMap<>();
+    private Map<Template, InstructionHandle> _templateIHs = new HashMap<Template,InstructionHandle>();
 
     /**
      * A mapping between templates and instruction lists.
      */
-    private Map<Template, InstructionList> _templateILs = new HashMap<>();
+    private Map<Template, InstructionList> _templateILs = new HashMap<Template,InstructionList>();
 
     /**
      * A reference to the pattern matching the root node.
@@ -196,7 +196,7 @@
 
     public String functionName(int min, int max) {
         if (_importLevels == null) {
-            _importLevels = new HashMap<>();
+            _importLevels = new HashMap<Integer,Integer>();
         }
         _importLevels.put(max, min);
         return _methodName + '_' + max;
@@ -1074,10 +1074,10 @@
         final Vector names      = xsltc.getNamesIndex();
 
         // Clear some datastructures
-        _namedTemplates = new HashMap<>();
-        _neededTemplates = new HashMap<>();
-        _templateIHs = new HashMap<>();
-        _templateILs = new HashMap<>();
+        _namedTemplates = new HashMap<Template,Mode>();
+        _neededTemplates = new HashMap<Template,Object>();
+        _templateIHs = new HashMap<Template,InstructionHandle>();
+        _templateILs = new HashMap<Template,InstructionList>();
         _patternGroups = new Vector[32];
         _rootPattern = null;
 
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java	2018-05-20 04:52:08.127913824 +0100
@@ -102,11 +102,11 @@
     }
 
     public void init() {
-        _qNames              = new HashMap<>(512);
-        _namespaces          = new HashMap<>();
-        _instructionClasses  = new HashMap<>();
-        _instructionAttrs    = new HashMap<>();
-        _variableScope       = new HashMap<>();
+        _qNames              = new HashMap<String,QName>(512);
+        _namespaces          = new HashMap<String,Map>();
+        _instructionClasses  = new HashMap<String,String>();
+        _instructionAttrs    = new HashMap<String,String[]>();
+        _variableScope       = new HashMap<String,Object>();
         _template            = null;
         _errors              = new Vector();
         _warnings            = new Vector();
@@ -317,7 +317,7 @@
 
             if (space == null) {
                 final QName name = new QName(namespace, prefix, localname);
-                _namespaces.put(namespace, space = new HashMap<>());
+                _namespaces.put(namespace, space = new HashMap<String,QName>());
                 space.put(lexicalQName, name);
                 return name;
             }
@@ -1238,7 +1238,7 @@
      */
     public void startPrefixMapping(String prefix, String uri) {
         if (_prefixMapping == null) {
-            _prefixMapping = new HashMap<>();
+            _prefixMapping = new HashMap<String,String>();
         }
         _prefixMapping.put(prefix, uri);
     }
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Stylesheet.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Stylesheet.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Stylesheet.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Stylesheet.java	2018-05-20 04:52:08.127913824 +0100
@@ -122,7 +122,7 @@
     /**
      * Mapping between mode names and Mode instances.
      */
-    private final Map<String, Mode> _modes = new HashMap<>();
+    private final Map<String, Mode> _modes = new HashMap<String, Mode>();
 
     /**
      * A reference to the default Mode object.
@@ -132,7 +132,7 @@
     /**
      * Mapping between extension URIs and their prefixes.
      */
-    private final Map<String, String> _extensions = new HashMap<>();
+    private final Map<String, String> _extensions = new HashMap<String,String>();
 
     /**
      * Reference to the stylesheet from which this stylesheet was
@@ -165,7 +165,7 @@
     /**
      * Mapping between key names and Key objects (needed by Key/IdPattern).
      */
-    private Map<String, Key> _keys = new HashMap<>();
+    private Map<String, Key> _keys = new HashMap<String,Key>();
 
     /**
      * A reference to the SourceLoader set by the user (a URIResolver
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SymbolTable.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SymbolTable.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SymbolTable.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SymbolTable.java	2018-05-20 04:52:08.127913824 +0100
@@ -38,8 +38,8 @@
 final class SymbolTable {
 
     // These maps are used for all stylesheets
-    private final Map<String, Stylesheet> _stylesheets = new HashMap<>();
-    private final Map<String, Vector> _primops     = new HashMap<>();
+    private final Map<String, Stylesheet> _stylesheets = new HashMap<String,Stylesheet>();
+    private final Map<String, Vector> _primops     = new HashMap<String,Vector>();
 
     // These maps are used for some stylesheets
     private Map<String, VariableBase> _variables = null;
@@ -57,7 +57,7 @@
     }
 
     public void addDecimalFormatting(QName name, DecimalFormatting symbols) {
-        if (_decimalFormats == null) _decimalFormats = new HashMap<>();
+        if (_decimalFormats == null) _decimalFormats = new HashMap<String,DecimalFormatting>();
         _decimalFormats.put(name.getStringRep(), symbols);
     }
 
@@ -67,7 +67,7 @@
     }
 
     public void addKey(QName name, Key key) {
-        if (_keys == null) _keys = new HashMap<>();
+        if (_keys == null) _keys = new HashMap<String,Key>();
         _keys.put(name.getStringRep(), key);
     }
 
@@ -81,7 +81,7 @@
 
     public Template addTemplate(Template template) {
         final QName name = template.getName();
-        if (_templates == null) _templates = new HashMap<>();
+        if (_templates == null) _templates = new HashMap<String,Template>();
         return _templates.put(name.getStringRep(), template);
     }
 
@@ -91,13 +91,13 @@
     }
 
     public Variable addVariable(Variable variable) {
-        if (_variables == null) _variables = new HashMap<>();
+        if (_variables == null) _variables = new HashMap<String,VariableBase>();
         final String name = variable.getName().getStringRep();
         return (Variable)_variables.put(name, variable);
     }
 
     public Param addParam(Param parameter) {
-        if (_variables == null) _variables = new HashMap<>();
+        if (_variables == null) _variables = new HashMap<String,VariableBase>();
         final String name = parameter.getName().getStringRep();
         return (Param)_variables.put(name, parameter);
     }
@@ -123,7 +123,7 @@
     }
 
     public AttributeSet addAttributeSet(AttributeSet atts) {
-        if (_attributeSets == null) _attributeSets = new HashMap<>();
+        if (_attributeSets == null) _attributeSets = new HashMap<String,AttributeSet>();
         return _attributeSets.put(atts.getName().getStringRep(), atts);
     }
 
@@ -181,7 +181,7 @@
      * Adds an alias for a namespace prefix
      */
     public void addPrefixAlias(String prefix, String alias) {
-        if (_aliases == null) _aliases = new HashMap<>();
+        if (_aliases == null) _aliases = new HashMap<String,String>();
         _aliases.put(prefix,alias);
     }
 
@@ -202,7 +202,7 @@
         if (uri == null) return;
 
         // Create a new map of exlcuded URIs if none exists
-        if (_excludedURI == null) _excludedURI = new HashMap<>();
+        if (_excludedURI == null) _excludedURI = new HashMap<String,Integer>();
 
         // Register the namespace URI
         Integer refcnt = _excludedURI.get(uri);
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SyntaxTreeNode.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SyntaxTreeNode.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SyntaxTreeNode.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SyntaxTreeNode.java	2018-05-20 04:52:08.127913824 +0100
@@ -70,7 +70,7 @@
     protected SyntaxTreeNode _parent;          // Parent node
     private Stylesheet       _stylesheet;      // Stylesheet ancestor node
     private Template         _template;        // Template ancestor node
-    private final List<SyntaxTreeNode> _contents = new ArrayList<>(2); // Child nodes
+    private final List<SyntaxTreeNode> _contents = new ArrayList<SyntaxTreeNode>(2); // Child nodes
 
     // Element description data
     protected QName _qname;                    // The element QName
@@ -243,7 +243,7 @@
      */
     protected void addPrefixMapping(String prefix, String uri) {
         if (_prefixMapping == null)
-            _prefixMapping = new HashMap<>();
+            _prefixMapping = new HashMap<String,String>();
         _prefixMapping.put(prefix, uri);
     }
 
@@ -435,7 +435,7 @@
             final QName varOrParamName = updateScope(parser, child);
             if (varOrParamName != null) {
                 if (locals == null) {
-                    locals = new ArrayList<>(2);
+                    locals = new ArrayList<QName>(2);
                 }
                 locals.add(varOrParamName);
             }
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java	2018-05-20 04:52:08.127913824 +0100
@@ -127,7 +127,7 @@
                  * times. Note that patterns whose kernels are "*", "node()"
                  * and "@*" can between shared by test sequences.
                  */
-        private Map<Pattern, InstructionList> _preCompiled = new HashMap<>();
+    private Map<Pattern, InstructionList> _preCompiled = new HashMap<Pattern,InstructionList>();
 
 
     public MethodGenerator(int access_flags, Type return_type,
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MultiHashtable.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MultiHashtable.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MultiHashtable.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MultiHashtable.java	2018-05-20 04:52:08.127913824 +0100
@@ -37,7 +37,7 @@
 public final class MultiHashtable<K,V> {
     static final long serialVersionUID = -6151608290510033572L;
 
-    private final Map<K, Set<V>> map = new HashMap<>();
+    private final Map<K, Set<V>> map = new HashMap<K,Set<V>>();
     private boolean modifiable = true;
 
     /**
@@ -52,7 +52,7 @@
         if (modifiable) {
             Set<V> set = map.get(key);
             if (set == null) {
-                set = new HashSet<>();
+                set = new HashSet<V>();
                 map.put(key, set);
             }
             set.add(value);
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java	2018-05-20 04:52:08.127913824 +0100
@@ -171,7 +171,7 @@
         _parser = new Parser(this, _overrideDefaultParser);
         _xmlFeatures = featureManager;
         _extensionClassLoader = null;
-        _externalExtensionFunctions = new HashMap<>();
+        _externalExtensionFunctions = new HashMap<String, Class>();
     }
 
     /**
@@ -304,13 +304,13 @@
      */
     private void reset() {
         _nextGType      = DTM.NTYPES;
-        _elements       = new HashMap<>();
-        _attributes     = new HashMap<>();
-        _namespaces     = new HashMap<>();
+        _elements       = new HashMap<String, Integer>();
+        _attributes     = new HashMap<String, Integer>();
+        _namespaces     = new HashMap<String, Integer>();
         _namespaces.put("",new Integer(_nextNSType));
         _namesIndex     = new Vector(128);
         _namespaceIndex = new Vector(32);
-        _namespacePrefixes = new HashMap<>();
+        _namespacePrefixes = new HashMap<String, Integer>();
         _stylesheet     = null;
         _parser.init();
         //_variableSerial     = 1;
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DocumentCache.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DocumentCache.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DocumentCache.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DocumentCache.java	2018-05-20 04:52:08.127913824 +0100
@@ -169,7 +169,7 @@
         _count = 0;
         _current = 0;
         _size  = size;
-        _references = new HashMap<>(_size+2);
+        _references = new HashMap<String,CachedDocument>(_size+2);
         _URIs = new String[_size];
 
         try {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMWSFilter.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMWSFilter.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMWSFilter.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMWSFilter.java	2018-05-20 04:52:08.127913824 +0100
@@ -60,7 +60,7 @@
      */
     public DOMWSFilter(AbstractTranslet translet) {
         m_translet = translet;
-        m_mappings = new HashMap<>();
+        m_mappings = new HashMap<DTM,short[]>();
 
         if (translet instanceof StripFilter) {
             m_filter = (StripFilter) translet;
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/KeyIndex.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/KeyIndex.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/KeyIndex.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/KeyIndex.java	2018-05-20 04:52:08.127913824 +0100
@@ -59,7 +59,7 @@
     /**
      * A mapping from a document node to the mapping between values and nodesets
      */
-    private Map<Integer, Map> _rootToIndexMap = new HashMap<>();
+    private Map<Integer, Map> _rootToIndexMap = new HashMap<Integer,Map>();
 
     /**
      * The node set associated to the current value passed
@@ -93,7 +93,7 @@
     public void add(String value, int node, int rootNode) {
         if (_currentDocumentNode != rootNode) {
             _currentDocumentNode = rootNode;
-            _index = new HashMap<>();
+            _index = new HashMap<String,IntegerArray>();
             _rootToIndexMap.put(rootNode, _index);
         }
 
@@ -180,7 +180,7 @@
                 Map<String, IntegerArray> index = _rootToIndexMap.get(root);
 
                 if (index == null) {
-                    index = new HashMap<>();
+                    index = new HashMap<String,IntegerArray>();
                     _rootToIndexMap.put(root, index);
                 } else {
                     nodes = index.get(id);
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/MultiDOM.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/MultiDOM.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/MultiDOM.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/MultiDOM.java	2018-05-20 04:52:08.127913824 +0100
@@ -56,7 +56,7 @@
     private int _free;
     private int _size;
 
-    private Map<String, Integer> _documents = new HashMap<>();
+    private Map<String, Integer> _documents = new HashMap<String,Integer>();
 
     private final class AxisIterator extends DTMAxisIteratorBase {
         // constitutive data
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SAXImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SAXImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SAXImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SAXImpl.java	2018-05-20 04:52:08.127913824 +0100
@@ -114,7 +114,7 @@
     private int _namesSize = -1;
 
     // Namespace related stuff
-    private Map<Integer, Integer> _nsIndex = new HashMap<>();
+    private Map<Integer, Integer> _nsIndex = new HashMap<Integer,Integer>();
 
     // The initial size of the text buffer
     private int _size = 0;
@@ -747,7 +747,7 @@
             else {
                 _document = node.getOwnerDocument();
             }
-            _node2Ids = new HashMap<>();
+            _node2Ids = new HashMap<Node,Integer>();
         }
     }
 
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/AbstractTranslet.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/AbstractTranslet.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/AbstractTranslet.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/AbstractTranslet.java	2018-05-20 04:52:08.127913824 +0100
@@ -279,7 +279,7 @@
      */
     public void addDecimalFormat(String name, DecimalFormatSymbols symbols) {
         // Instanciate map for formatting symbols if needed
-        if (_formatSymbols == null) _formatSymbols = new HashMap<>();
+        if (_formatSymbols == null) _formatSymbols = new HashMap<String,DecimalFormat>();
 
         // The name cannot be null - use empty string instead
         if (name == null) name = EMPTYSTRING;
@@ -468,7 +468,7 @@
      * @return a KeyIndex.
      */
     private KeyIndex buildKeyIndexHelper(String name) {
-        if (_keyIndexes == null) _keyIndexes = new HashMap<>();
+        if (_keyIndexes == null) _keyIndexes = new HashMap<String,KeyIndex>();
 
         KeyIndex index = _keyIndexes.get(name);
         if (index == null) {
@@ -712,7 +712,7 @@
     private Map<String, Class<?>> _auxClasses = null;
 
     public void addAuxiliaryClass(Class auxClass) {
-        if (_auxClasses == null) _auxClasses = new HashMap<>();
+        if (_auxClasses == null) _auxClasses = new HashMap<String,Class<?>>();
         _auxClasses.put(auxClass.getName(), auxClass);
     }
 
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/DOM2SAX.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/DOM2SAX.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/DOM2SAX.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/DOM2SAX.java	2018-05-20 04:52:08.131913761 +0100
@@ -58,7 +58,7 @@
     private ContentHandler _sax = null;
     private LexicalHandler _lex = null;
     private SAXImpl _saxImpl = null;
-    private Map<String, Stack> _nsPrefixes = new HashMap<>();
+    private Map<String, Stack> _nsPrefixes = new HashMap<String,Stack>();
 
     public DOM2SAX(Node root) {
         _dom = root;
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java	2018-05-20 04:52:08.131913761 +0100
@@ -407,7 +407,7 @@
             _class = new Class[classCount];
 
             if (classCount > 1) {
-                _auxClasses = new HashMap<>();
+                _auxClasses = new HashMap<String,Class<?>>();
             }
 
             for (int i = 0; i < classCount; i++) {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java	2018-05-20 04:52:08.131913761 +0100
@@ -1180,7 +1180,7 @@
 
         if (_isIdentity) {
             if (_parameters == null) {
-                _parameters = new HashMap<>();
+                _parameters = new HashMap<String,Object>();
             }
             _parameters.put(name, value);
         }
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/CoreDocumentImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/CoreDocumentImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/CoreDocumentImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/CoreDocumentImpl.java	2018-05-20 04:52:08.131913761 +0100
@@ -393,7 +393,7 @@
 
             if (identifiers != null) {
                 // Build a reverse mapping from element to identifier.
-                reversedIdentifiers = new HashMap<>(identifiers.size());
+                reversedIdentifiers = new HashMap<Node,String>(identifiers.size());
                 for (String elementId : identifiers.keySet()) {
                     reversedIdentifiers.put(identifiers.get(elementId), elementId);
                 }
@@ -1504,7 +1504,7 @@
         // Node numbers are negative, from -1 to -n
         int num;
         if (nodeTable == null) {
-            nodeTable = new HashMap<>();
+            nodeTable = new HashMap<Node,Integer>();
             num = --nodeCounter;
             nodeTable.put(node, new Integer(num));
         } else {
@@ -1609,7 +1609,7 @@
                     String elementId = reversedIdentifiers.get(source);
                     if (elementId != null) {
                         if (identifiers == null) {
-                            identifiers = new HashMap<>();
+                            identifiers = new HashMap<String,Node>();
                         }
 
                         identifiers.put(elementId, newElement);
@@ -2032,7 +2032,7 @@
         }
 
         if (identifiers == null) {
-            identifiers = new HashMap<>();
+            identifiers = new HashMap<String,Node>();
         }
 
         identifiers.put(idName, element);
@@ -2360,13 +2360,13 @@
         } else {
             Map<String, UserDataRecord> t;
             if (nodeUserData == null) {
-                nodeUserData = new HashMap<>();
-                t = new HashMap<>();
+                nodeUserData = new HashMap<Node,Map<String,UserDataRecord>>();
+                t = new HashMap<String,UserDataRecord>();
                 nodeUserData.put(n, t);
             } else {
                 t = nodeUserData.get(n);
                 if (t == null) {
-                    t = new HashMap<>();
+                    t = new HashMap<String,UserDataRecord>();
                     nodeUserData.put(n, t);
                 }
             }
@@ -2434,7 +2434,7 @@
      */
     void setUserDataTable(Node n, Map<String, UserDataRecord> data) {
         if (nodeUserData == null) {
-            nodeUserData = new HashMap<>();
+            nodeUserData = new HashMap<Node,Map<String,UserDataRecord>>();
         }
 
         if (data != null) {
@@ -2788,15 +2788,15 @@
         // Convert Maps to Hashtables
         Hashtable<Node, Hashtable<String, UserDataRecord>> nud = null;
         if (nodeUserData != null) {
-            nud = new Hashtable<>();
+            nud = new Hashtable<Node, Hashtable<String,UserDataRecord>>();
             for (Map.Entry<Node, Map<String, UserDataRecord>> e : nodeUserData.entrySet()) {
                 //e.getValue() will not be null since an entry is always put with a non-null value
-                nud.put(e.getKey(), new Hashtable<>(e.getValue()));
+                nud.put(e.getKey(), new Hashtable<String,UserDataRecord>(e.getValue()));
             }
         }
 
-        Hashtable<String, Node> ids = (identifiers == null)? null : new Hashtable<>(identifiers);
-        Hashtable<Node, Integer> nt = (nodeTable == null)? null : new Hashtable<>(nodeTable);
+        Hashtable<String, Node> ids = (identifiers == null)? null : new Hashtable<String,Node>(identifiers);
+        Hashtable<Node, Integer> nt = (nodeTable == null)? null : new Hashtable<Node,Integer>(nodeTable);
 
         // Write serialized fields
         ObjectOutputStream.PutField pf = out.putFields();
@@ -2858,13 +2858,13 @@
 
         //convert Hashtables back to HashMaps
         if (nud != null) {
-            nodeUserData = new HashMap<>();
+            nodeUserData = new HashMap<Node,Map<String,UserDataRecord>>();
             for (Map.Entry<Node, Hashtable<String, UserDataRecord>> e : nud.entrySet()) {
-                nodeUserData.put(e.getKey(), new HashMap<>(e.getValue()));
+                nodeUserData.put(e.getKey(), new HashMap<String,UserDataRecord>(e.getValue()));
             }
         }
 
-        if (ids != null) identifiers = new HashMap<>(ids);
-        if (nt != null) nodeTable = new HashMap<>(nt);
+        if (ids != null) identifiers = new HashMap<String,Node>(ids);
+        if (nt != null) nodeTable = new HashMap<Node,Integer>(nt);
     }
 } // class CoreDocumentImpl
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/DeferredDocumentImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/DeferredDocumentImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/DeferredDocumentImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/DeferredDocumentImpl.java	2018-05-20 04:52:08.131913761 +0100
@@ -2059,7 +2059,7 @@
 
         // create Map
         if (identifiers == null) {
-            identifiers = new HashMap<>();
+            identifiers = new HashMap<String,Node>();
         }
 
         // save ID and its associated element
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentImpl.java	2018-05-20 04:52:08.131913761 +0100
@@ -249,7 +249,7 @@
                                                      filter,
                                                      entityReferenceExpansion);
         if (iterators == null) {
-            iterators = new ArrayList<>();
+            iterators = new ArrayList<NodeIterator>();
         }
 
         iterators.add(iterator);
@@ -320,7 +320,7 @@
     public Range createRange() {
 
         if (ranges == null) {
-            ranges = new ArrayList<>();
+            ranges = new ArrayList<Range>();
         }
 
         Range range = new RangeImpl(this);
@@ -460,7 +460,7 @@
      */
     private void setEventListeners(NodeImpl n, List<LEntry> listeners) {
         if (eventListeners == null) {
-            eventListeners = new HashMap<>();
+            eventListeners = new HashMap<NodeImpl,List<LEntry>>();
         }
         if (listeners == null) {
             eventListeners.remove(n);
@@ -551,7 +551,7 @@
 
         List<LEntry> nodeListeners = getEventListeners(node);
         if(nodeListeners == null) {
-            nodeListeners = new ArrayList<>();
+            nodeListeners = new ArrayList<LEntry>();
             setEventListeners(node, nodeListeners);
         }
         nodeListeners.add(new LEntry(type, listener, useCapture));
@@ -626,7 +626,7 @@
         if (nodeListeners == null) {
             return;
         }
-        setEventListeners(tgt, new ArrayList<>(nodeListeners));
+        setEventListeners(tgt, new ArrayList<LEntry>(nodeListeners));
     }
 
     /**
@@ -716,7 +716,7 @@
         // is issued to the Element rather than the Attr
         // and causes a _second_ DOMSubtreeModified in the Element's
         // tree.
-        List<Node> pv = new ArrayList<>(10);
+        List<Node> pv = new ArrayList<Node>(10);
         Node p = node;
         Node n = p.getParentNode();
         while (n != null) {
@@ -1334,14 +1334,14 @@
      */
     private void writeObject(ObjectOutputStream out) throws IOException {
         // Convert Maps to Hashtables, Lists to Vectors
-        Vector<NodeIterator> it = (iterators == null)? null : new Vector<>(iterators);
-        Vector<Range> r = (ranges == null)? null : new Vector<>(ranges);
+        Vector<NodeIterator> it = (iterators == null)? null : new Vector<NodeIterator>(iterators);
+        Vector<Range> r = (ranges == null)? null : new Vector<Range>(ranges);
 
         Hashtable<NodeImpl, Vector<LEntry>> el = null;
         if (eventListeners != null) {
-            el = new Hashtable<>();
+            el = new Hashtable<NodeImpl,Vector<LEntry>>();
             for (Map.Entry<NodeImpl, List<LEntry>> e : eventListeners.entrySet()) {
-                 el.put(e.getKey(), new Vector<>(e.getValue()));
+                 el.put(e.getKey(), new Vector<LEntry>(e.getValue()));
             }
         }
 
@@ -1367,12 +1367,12 @@
         mutationEvents = gf.get("mutationEvents", false);
 
         //convert Hashtables back to HashMaps and Vectors to Lists
-        if (it != null) iterators = new ArrayList<>(it);
-        if (r != null) ranges = new ArrayList<>(r);
+        if (it != null) iterators = new ArrayList<NodeIterator>(it);
+        if (r != null) ranges = new ArrayList<Range>(r);
         if (el != null) {
-            eventListeners = new HashMap<>();
+            eventListeners = new HashMap<NodeImpl,List<LEntry>>();
             for (Map.Entry<NodeImpl, Vector<LEntry>> e : el.entrySet()) {
-                 eventListeners.put(e.getKey(), new ArrayList<>(e.getValue()));
+                 eventListeners.put(e.getKey(), new ArrayList<LEntry>(e.getValue()));
             }
         }
     }
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentTypeImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentTypeImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentTypeImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentTypeImpl.java	2018-05-20 04:52:08.131913761 +0100
@@ -478,7 +478,7 @@
     public Object setUserData(String key,
     Object data, UserDataHandler handler) {
         if(userData == null)
-            userData = new HashMap<>();
+            userData = new HashMap<String,UserDataRecord>();
         if (data == null) {
             if (userData != null) {
                 UserDataRecord udr = userData.remove(key);
@@ -519,7 +519,7 @@
      */
     private void writeObject(ObjectOutputStream out) throws IOException {
         // Convert the HashMap to Hashtable
-        Hashtable<String, UserDataRecord> ud = (userData == null)? null : new Hashtable<>(userData);
+        Hashtable<String, UserDataRecord> ud = (userData == null)? null : new Hashtable<String,UserDataRecord>(userData);
 
         // Write serialized fields
         ObjectOutputStream.PutField pf = out.putFields();
@@ -553,6 +553,6 @@
                 (Hashtable<String, UserDataRecord>)gf.get("userData", null);
 
         //convert the Hashtable back to HashMap
-        if (ud != null) userData = new HashMap<>(ud);
+        if (ud != null) userData = new HashMap<String,UserDataRecord>(ud);
     }
 } // class DocumentTypeImpl
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/LCount.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/LCount.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/dom/LCount.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/dom/LCount.java	2018-05-20 04:52:08.131913761 +0100
@@ -37,7 +37,7 @@
 
 class LCount
 {
-    static final java.util.Map<String, LCount> lCounts=new java.util.concurrent.ConcurrentHashMap<>();
+    static final java.util.Map<String, LCount> lCounts=new java.util.concurrent.ConcurrentHashMap<String,LCount>();
     public int captures=0,bubbles=0,defaults, total=0;
 
     static LCount lookup(String evtName)
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammarBucket.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammarBucket.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammarBucket.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammarBucket.java	2018-05-20 04:52:08.131913761 +0100
@@ -62,7 +62,7 @@
 
     /** Default constructor. */
     public DTDGrammarBucket() {
-        fGrammars = new HashMap<>();
+        fGrammars = new HashMap<XMLDTDDescription,DTDGrammar>();
     } // <init>()
 
     //
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammar.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammar.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammar.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammar.java	2018-05-20 04:52:08.131913761 +0100
@@ -210,13 +210,13 @@
     // other information
 
     /** Element index mapping table. */
-    private final Map<String, Integer> fElementIndexMap = new HashMap<>();
+    private final Map<String, Integer> fElementIndexMap = new HashMap<String,Integer>();
 
     /** Entity index mapping table. */
-    private final Map<String, Integer> fEntityIndexMap = new HashMap<>();
+    private final Map<String, Integer> fEntityIndexMap = new HashMap<String,Integer>();
 
     /** Notation index mapping table. */
-    private final Map<String, Integer> fNotationIndexMap = new HashMap<>();
+    private final Map<String, Integer> fNotationIndexMap = new HashMap<String,Integer>();
 
     // temp variables
 
@@ -250,7 +250,7 @@
     private XMLContentSpec fContentSpec = new XMLContentSpec();
 
     /** table of XMLElementDecl   */
-    Map<String, XMLElementDecl> fElementDeclTab = new HashMap<>();
+    Map<String, XMLElementDecl> fElementDeclTab = new HashMap<String,XMLElementDecl>();
 
     /** Children content model operation stack. */
     private short[] fOpStack = null;
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/DTDDVFactoryImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/DTDDVFactoryImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/DTDDVFactoryImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/DTDDVFactoryImpl.java	2018-05-20 04:52:08.131913761 +0100
@@ -38,7 +38,7 @@
 
     static final Map<String, DatatypeValidator> fBuiltInTypes;
     static {
-        Map<String, DatatypeValidator> builtInTypes = new HashMap<>();
+        Map<String, DatatypeValidator> builtInTypes = new HashMap<String,DatatypeValidator>();
         DatatypeValidator dvTemp;
 
         builtInTypes.put("string", new StringDatatypeValidator());
@@ -75,7 +75,7 @@
      */
     @Override
     public Map<String, DatatypeValidator> getBuiltInTypes() {
-        return new HashMap<>(fBuiltInTypes);
+        return new HashMap<String,DatatypeValidator>(fBuiltInTypes);
     }
 
 }// DTDDVFactoryImpl
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/XML11DTDDVFactoryImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/XML11DTDDVFactoryImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/XML11DTDDVFactoryImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/XML11DTDDVFactoryImpl.java	2018-05-20 04:52:08.131913761 +0100
@@ -37,7 +37,7 @@
 
     static Map<String, DatatypeValidator> XML11BUILTINTYPES;
     static {
-        Map<String, DatatypeValidator> xml11BuiltInTypes = new HashMap<>();
+        Map<String, DatatypeValidator> xml11BuiltInTypes = new HashMap<String,DatatypeValidator>();
         xml11BuiltInTypes.put("XML11ID", new XML11IDDatatypeValidator());
         DatatypeValidator dvTemp = new XML11IDREFDatatypeValidator();
         xml11BuiltInTypes.put("XML11IDREF", dvTemp);
@@ -72,7 +72,7 @@
      */
     @Override
     public Map<String, DatatypeValidator> getBuiltInTypes() {
-        final HashMap<String, DatatypeValidator> toReturn = new HashMap<>(fBuiltInTypes);
+        final HashMap<String, DatatypeValidator> toReturn = new HashMap<String,DatatypeValidator>(fBuiltInTypes);
         toReturn.putAll(XML11BUILTINTYPES);
         return toReturn;
     }
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java	2018-05-20 04:52:08.131913761 +0100
@@ -364,7 +364,7 @@
     // entities
 
     /** Entities. */
-    protected Map<String, Entity> fEntities = new HashMap<>();
+    protected Map<String, Entity> fEntities = new HashMap<String,Entity>();
 
     /** Entity stack. */
     protected Stack fEntityStack = new Stack();
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLErrorReporter.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLErrorReporter.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLErrorReporter.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLErrorReporter.java	2018-05-20 04:52:08.131913761 +0100
@@ -192,7 +192,7 @@
         //       caller to specify the location of the error being
         //       reported. -Ac
 
-        fMessageFormatters = new HashMap<>();
+        fMessageFormatters = new HashMap<String,MessageFormatter>();
 
     } // <init>()
 
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/ParserForXMLSchema.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/ParserForXMLSchema.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/ParserForXMLSchema.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/ParserForXMLSchema.java	2018-05-20 04:52:08.135913698 +0100
@@ -374,8 +374,8 @@
     static private Map<String, Token> ranges2 = null;
     static synchronized protected RangeToken getRange(String name, boolean positive) {
         if (ranges == null) {
-            ranges = new HashMap<>();
-            ranges2 = new HashMap<>();
+            ranges = new HashMap<String,Token>();
+            ranges2 = new HashMap<String,Token>();
 
             Token tok = Token.createRange();
             setupRange(tok, SPACES);
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/Token.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/Token.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/Token.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/Token.java	2018-05-20 04:52:08.135913698 +0100
@@ -593,8 +593,8 @@
     }
 
     // ------------------------------------------------------
-    private final static Map<String, Token> categories = new HashMap<>();
-    private final static Map<String, Token> categories2 = new HashMap<>();
+    private final static Map<String, Token> categories = new HashMap<String,Token>();
+    private final static Map<String, Token> categories2 = new HashMap<String,Token>();
     private static final String[] categoryNames = {
         "Cn", "Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Me", "Mc", "Nd",
         "Nl", "No", "Zs", "Zl", "Zp", "Cc", "Cf", null, "Co", "Cs",
@@ -1445,7 +1445,7 @@
         @Override
         void addChild(Token tok) {
             if (tok == null)  return;
-            if (this.children == null)  this.children = new ArrayList<>();
+            if (this.children == null)  this.children = new ArrayList<Token>();
             if (this.type == UNION) {
                 this.children.add(tok);
                 return;
@@ -1552,7 +1552,7 @@
          */
         private void writeObject(ObjectOutputStream out) throws IOException {
             // Convert List to Vector
-            Vector<Token> vChildren = (children == null)? null : new Vector<>(children);
+            Vector<Token> vChildren = (children == null)? null : new Vector<Token>(children);
 
             // Write serialized fields
             ObjectOutputStream.PutField pf = out.putFields();
@@ -1568,7 +1568,7 @@
             Vector<Token> vChildren = (Vector<Token>)gf.get("children", null);
 
             //convert Vector back to List
-            if (vChildren != null) children = new ArrayList<>(vChildren);
+            if (vChildren != null) children = new ArrayList<Token>(vChildren);
         }
     }
 }
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java	2018-05-20 04:52:08.135913698 +0100
@@ -859,10 +859,10 @@
         private SymbolTable fSymbolTable;
 
         // REVISIT: Code something better here. -Ac
-        private Map<String, Integer> fSymbolMapping = new HashMap<>();
+        private Map<String, Integer> fSymbolMapping = new HashMap<String,Integer>();
 
         // REVISIT: Code something better here. -Ac
-        private Map<Integer, String> fTokenNames = new HashMap<>();
+        private Map<Integer, String> fTokenNames = new HashMap<Integer,String>();
 
         /**
          * Current position in the token list.
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/SubstitutionGroupHandler.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/SubstitutionGroupHandler.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/SubstitutionGroupHandler.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/SubstitutionGroupHandler.java	2018-05-20 04:52:08.135913698 +0100
@@ -176,10 +176,10 @@
     // - a Vector, which contains all elements that has this element as their
     //   substitution group affilication
     // - an array of OneSubGroup, which contains its substitution group before block.
-    Map<XSElementDecl, Object> fSubGroupsB = new HashMap<>();
+    Map<XSElementDecl, Object> fSubGroupsB = new HashMap<XSElementDecl,Object>();
     private static final OneSubGroup[] EMPTY_VECTOR = new OneSubGroup[0];
     // The real substitution groups (after "block")
-    Map<XSElementDecl, XSElementDecl[]> fSubGroups = new HashMap<>();
+    Map<XSElementDecl, XSElementDecl[]> fSubGroups = new HashMap<XSElementDecl,XSElementDecl[]>();
 
     /**
      * clear the internal registry of substitutionGroup information
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java	2018-05-20 04:52:08.135913698 +0100
@@ -463,7 +463,7 @@
 
     // Constructors
     public XSDHandler(){
-        fHiddenNodes = new HashMap<>();
+        fHiddenNodes = new HashMap<Node,String>();
         fSchemaParser = new SchemaDOMParser(new SchemaParsingConfig());
     }
 
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java	2018-05-20 04:52:08.135913698 +0100
@@ -490,7 +490,7 @@
 
     /** Schema Grammar Description passed,  to give a chance to application to supply the Grammar */
     protected final XSDDescription fXSDDescription = new XSDDescription();
-    protected final Map<String, XMLSchemaLoader.LocationArray> fLocationPairs = new HashMap<>();
+    protected final Map<String, XMLSchemaLoader.LocationArray> fLocationPairs = new HashMap<String,XMLSchemaLoader.LocationArray>();
 
 
     // handlers
@@ -3992,7 +3992,7 @@
          * elements.
          */
         protected final Map<LocalIDKey, ValueStoreBase>
-                fIdentityConstraint2ValueStoreMap = new HashMap<>();
+	    fIdentityConstraint2ValueStoreMap = new HashMap<LocalIDKey,ValueStoreBase>();
 
         // sketch of algorithm:
         // - when a constraint is first encountered, its
@@ -4014,9 +4014,9 @@
         // the fGlobalIDConstraintMap contains descendants+self.
         // keyrefs can only match descendants+self.
         protected final Stack<Map<IdentityConstraint, ValueStoreBase>>
-                fGlobalMapStack = new Stack<>();
+	    fGlobalMapStack = new Stack<Map<IdentityConstraint,ValueStoreBase>>();
         protected final Map<IdentityConstraint, ValueStoreBase>
-                fGlobalIDConstraintMap = new HashMap<>();
+	    fGlobalIDConstraintMap = new HashMap<IdentityConstraint,ValueStoreBase>();
 
         //
         // Constructors
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl.java	2018-05-20 04:52:08.135913698 +0100
@@ -102,7 +102,7 @@
 
         // Create the Map if none existed before
         if (attributes == null) {
-            attributes = new HashMap<>();
+            attributes = new HashMap<String,Object>();
         }
 
         attributes.put(name, value);
@@ -191,7 +191,7 @@
     public void setFeature(String name, boolean value)
         throws ParserConfigurationException {
         if (features == null) {
-            features = new HashMap<>();
+            features = new HashMap<String,Boolean>();
         }
         // If this is the secure processing feature, save it then return.
         if (name.equals(XMLConstants.FEATURE_SECURE_PROCESSING)) {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl.java	2018-05-20 04:52:08.135913698 +0100
@@ -186,7 +186,7 @@
 
     private void putInFeatures(String name, boolean value){
          if (features == null) {
-            features = new HashMap<>();
+	     features = new HashMap<String,Boolean>();
         }
         features.put(name, value ? Boolean.TRUE : Boolean.FALSE);
     }
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/parsers/XMLGrammarPreparser.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/parsers/XMLGrammarPreparser.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/parsers/XMLGrammarPreparser.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/parsers/XMLGrammarPreparser.java	2018-05-20 04:52:08.135913698 +0100
@@ -85,7 +85,7 @@
     private static final Map<String, String> KNOWN_LOADERS;
 
     static {
-        Map<String, String> loaders = new HashMap<>();
+        Map<String, String> loaders = new HashMap<String,String>();
         loaders.put(XMLGrammarDescription.XML_SCHEMA,
             "com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaLoader");
         loaders.put(XMLGrammarDescription.XML_DTD,
@@ -130,7 +130,7 @@
     public XMLGrammarPreparser (SymbolTable symbolTable) {
         fSymbolTable = symbolTable;
 
-        fLoaders = new HashMap<>();
+        fLoaders = new HashMap<String,XMLGrammarLoader>();
         fErrorReporter = new XMLErrorReporter();
         setLocale(Locale.getDefault());
         fEntityResolver = new XMLEntityManager();
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/util/AugmentationsImpl.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/util/AugmentationsImpl.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/util/AugmentationsImpl.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/util/AugmentationsImpl.java	2018-05-20 04:52:08.135913698 +0100
@@ -241,7 +241,7 @@
     }
 
     class LargeContainer extends AugmentationsItemsContainer {
-        final Map<Object, Object> fAugmentations = new HashMap<>();
+        final Map<Object, Object> fAugmentations = new HashMap<Object,Object>();
 
         public Object getItem(Object key) {
             return fAugmentations.get(key);
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMErrorHandlerWrapper.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMErrorHandlerWrapper.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMErrorHandlerWrapper.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMErrorHandlerWrapper.java	2018-05-20 04:52:08.135913698 +0100
@@ -294,7 +294,7 @@
 
             // REVISIT: do well-formedness issues involving XML declaration <?xml ... ?> need to be added to hash table (no XML declaration node in DOM, but Document includes xmlEncoding, xmlStandalone, xmlVersion, etc.
 
-            Map<XMLErrorCode, String> aDOMErrorTypeTable = new HashMap<>();
+            Map<XMLErrorCode, String> aDOMErrorTypeTable = new HashMap<XMLErrorCode,String>();
             aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInCDSect"), "wf-invalid-character");
             aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInContent"), "wf-invalid-character");
             aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "TwoColonsInQName"), "wf-invalid-character-in-node-name");
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/util/EncodingMap.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/util/EncodingMap.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/util/EncodingMap.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/util/EncodingMap.java	2018-05-20 04:52:08.135913698 +0100
@@ -489,8 +489,8 @@
     //
 
     static {
-        Map<String, String> aIANA2JavaMap = new HashMap<>();
-        Map<String, String> aJava2IANAMap = new HashMap<>();
+        Map<String, String> aIANA2JavaMap = new HashMap<String,String>();
+        Map<String, String> aJava2IANAMap = new HashMap<String,String>();
 
         // add IANA to Java encoding mappings.
         aIANA2JavaMap.put("BIG5",            "Big5");
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/utils/XMLLimitAnalyzer.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/utils/XMLLimitAnalyzer.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/utils/XMLLimitAnalyzer.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/utils/XMLLimitAnalyzer.java	2018-05-20 04:52:08.135913698 +0100
@@ -144,7 +144,7 @@
 
         Map<String, Integer> cache;
         if (caches[index] == null) {
-            cache = new HashMap<>(10);
+            cache = new HashMap<String,Integer>(10);
             caches[index] = cache;
         } else {
             cache = caches[index];
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/utils/XMLSecurityManager.java openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/utils/XMLSecurityManager.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xerces/internal/utils/XMLSecurityManager.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xerces/internal/utils/XMLSecurityManager.java	2018-05-20 04:52:08.139913634 +0100
@@ -502,7 +502,7 @@
     }
 
     // Array list to store printed warnings for each SAX parser used
-    private static final CopyOnWriteArrayList<String> printedWarnings = new CopyOnWriteArrayList<>();
+    private static final CopyOnWriteArrayList<String> printedWarnings = new CopyOnWriteArrayList<String>();
 
     /**
      * Prints out warnings if a parser does not support the specified feature/property.
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/CustomStringPool.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/CustomStringPool.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/CustomStringPool.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/CustomStringPool.java	2018-05-20 04:52:08.139913634 +0100
@@ -47,7 +47,7 @@
  */
 public class CustomStringPool extends DTMStringPool {
 
-    final Map<String, Integer> m_stringToInt = new HashMap<>();
+    final Map<String, Integer> m_stringToInt = new HashMap<String,Integer>();
     public static final int NULL = -1;
 
     public CustomStringPool() {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/sax2dtm/SAX2DTM.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/sax2dtm/SAX2DTM.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/sax2dtm/SAX2DTM.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/sax2dtm/SAX2DTM.java	2018-05-20 04:52:08.139913634 +0100
@@ -162,7 +162,7 @@
    * This table holds the ID string to node associations, for
    * XML IDs.
    */
-  protected Map<String, Integer> m_idAttributes = new HashMap<>();
+  protected Map<String, Integer> m_idAttributes = new HashMap<String,Integer>();
 
   /**
    * fixed dom-style names.
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogEntry.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogEntry.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogEntry.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogEntry.java	2018-05-20 04:52:08.139913634 +0100
@@ -59,7 +59,7 @@
    * (e.g., 'BASE' or 'SYSTEM') to their type (1, 2, etc.).
    * Names are case sensitive.
    */
-  protected static final Map<String, Integer> entryTypes = new ConcurrentHashMap<>();
+  protected static final Map<String, Integer> entryTypes = new ConcurrentHashMap<String,Integer>();
 
   /** The entryTypes vector maps catalog entry types to the
       number of arguments they're required to have. */
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java	2018-05-20 04:52:08.139913634 +0100
@@ -341,7 +341,7 @@
    * vector. This allows the Catalog to quickly locate the reader
    * for a particular MIME type.</p>
    */
-  protected Map<String, Integer> readerMap = new HashMap<>();
+  protected Map<String, Integer> readerMap = new HashMap<String,Integer>();
 
   /**
    * A vector of CatalogReaders.
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/helpers/BootstrapResolver.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/helpers/BootstrapResolver.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/helpers/BootstrapResolver.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/helpers/BootstrapResolver.java	2018-05-20 04:52:08.139913634 +0100
@@ -63,13 +63,13 @@
   public static final String xmlCatalogSysId = "http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd";
 
   /** Private hash used for public identifiers. */
-  private final Map<String, String> publicMap = new HashMap<>();
+  private final Map<String, String> publicMap = new HashMap<String,String>();
 
   /** Private hash used for system identifiers. */
-  private final Map<String, String> systemMap = new HashMap<>();
+  private final Map<String, String> systemMap = new HashMap<String,String>();
 
   /** Private hash used for URIs. */
-  private final Map<String, String> uriMap = new HashMap<>();
+  private final Map<String, String> uriMap = new HashMap<String,String>();
 
   /** Constructor. */
   public BootstrapResolver() {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/DOMCatalogReader.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/DOMCatalogReader.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/DOMCatalogReader.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/DOMCatalogReader.java	2018-05-20 04:52:08.139913634 +0100
@@ -78,7 +78,7 @@
    * or "{namespaceuri}elementname". The former is used if the
    * namespace URI is null.</p>
    */
-  protected Map<String, String> namespaceMap = new HashMap<>();
+  protected Map<String, String> namespaceMap = new HashMap<String,String>();
 
   /**
    * Add a new parser to the reader.
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/SAXCatalogReader.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/SAXCatalogReader.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/SAXCatalogReader.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/SAXCatalogReader.java	2018-05-20 04:52:08.139913634 +0100
@@ -89,7 +89,7 @@
      * or "{namespaceuri}elementname". The former is used if the
      * namespace URI is null.</p>
      */
-  protected Map<String, String> namespaceMap = new HashMap<>();
+  protected Map<String, String> namespaceMap = new HashMap<String,String>();
 
   /** The parser in use for the current catalog. */
   private SAXCatalogParser saxParser = null;
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/serialize/BaseMarkupSerializer.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/serialize/BaseMarkupSerializer.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/serialize/BaseMarkupSerializer.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/serialize/BaseMarkupSerializer.java	2018-05-20 04:52:08.139913634 +0100
@@ -820,7 +820,7 @@
         throws SAXException
     {
         if ( _prefixes == null )
-            _prefixes = new HashMap<>();
+            _prefixes = new HashMap<String,String>();
         _prefixes.put( uri, prefix == null ? "" : prefix );
     }
 
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLdtd.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLdtd.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLdtd.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLdtd.java	2018-05-20 04:52:08.139913634 +0100
@@ -371,8 +371,8 @@
         if ( _byName != null )
             return;
         try {
-            _byName = new HashMap<>();
-            _byChar = new HashMap<>();
+            _byName = new HashMap<String,Integer>();
+            _byChar = new HashMap<Integer,String>();
             is = HTMLdtd.class.getResourceAsStream( ENTITIES_RESOURCE );
             if ( is == null ) {
                 throw new RuntimeException(
@@ -471,7 +471,7 @@
 
     static
     {
-        _elemDefs = new HashMap<>();
+        _elemDefs = new HashMap<String,Integer>();
         defineElement( "ADDRESS", CLOSE_P );
         defineElement( "AREA", EMPTY );
         defineElement( "BASE",  EMPTY | ALLOWED_HEAD );
@@ -525,7 +525,7 @@
         defineElement( "TR", ELEM_CONTENT | OPT_CLOSING | CLOSE_TABLE );
         defineElement( "UL", ELEM_CONTENT | CLOSE_P );
 
-        _boolAttrs = new HashMap<>();
+        _boolAttrs = new HashMap<String,String[]>();
         defineBoolean( "AREA", "href" );
         defineBoolean( "BUTTON", "disabled" );
         defineBoolean( "DIR", "compact" );
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/serializer/AttributesImplSerializer.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/serializer/AttributesImplSerializer.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/serializer/AttributesImplSerializer.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/serializer/AttributesImplSerializer.java	2018-05-20 04:52:08.139913634 +0100
@@ -48,7 +48,7 @@
      * The keys to the hashtable to find the index are either
      * "prefix:localName"  or "{uri}localName".
      */
-    private final Map<String, Integer> m_indexFromQName = new HashMap<>();
+    private final Map<String, Integer> m_indexFromQName = new HashMap<String,Integer>();
 
     private final StringBuffer m_buff = new StringBuffer();
 
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/serializer/Encodings.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/serializer/Encodings.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/serializer/Encodings.java	2018-05-20 04:38:34.416808053 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/serializer/Encodings.java	2018-05-20 04:52:08.139913634 +0100
@@ -297,8 +297,8 @@
     //
     private final static class EncodingInfos {
         // These maps are final and not modified after initialization.
-        private final Map<String, EncodingInfo> _encodingTableKeyJava = new HashMap<>();
-        private final Map<String, EncodingInfo> _encodingTableKeyMime = new HashMap<>();
+        private final Map<String, EncodingInfo> _encodingTableKeyJava = new HashMap<String, EncodingInfo>();
+        private final Map<String, EncodingInfo> _encodingTableKeyMime = new HashMap<String, EncodingInfo>();
         // This map will be added to after initialization: make sure it's
         // thread-safe. This map should not be used frequently - only in cases
         // where the mapping requested was not declared in the Encodings.properties
@@ -449,7 +449,7 @@
 
                 // create instances of EncodingInfo from the loaded mapping
                 Enumeration keys = props.keys();
-                Map<String, EncodingInfo> canonicals = new HashMap<>();
+                Map<String, EncodingInfo> canonicals = new HashMap<String, EncodingInfo>();
                 while (keys.hasMoreElements()) {
                     final String javaName = (String) keys.nextElement();
                     final String[] mimes = parseMimeTypes(props.getProperty(javaName));
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/utils/ElemDesc.java openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/utils/ElemDesc.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xml/internal/utils/ElemDesc.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xml/internal/utils/ElemDesc.java	2018-05-20 04:52:08.139913634 +0100
@@ -159,7 +159,7 @@
   {
 
     if (null == m_attrs)
-      m_attrs = new HashMap<>();
+	m_attrs = new HashMap<String,Integer>();
 
     m_attrs.put(name, flags);
   }
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/org/apache/xpath/internal/compiler/Keywords.java openjdk-boot/jaxp/src/com/sun/org/apache/xpath/internal/compiler/Keywords.java
--- openjdk-boot.orig/jaxp/src/com/sun/org/apache/xpath/internal/compiler/Keywords.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/org/apache/xpath/internal/compiler/Keywords.java	2018-05-20 04:52:08.139913634 +0100
@@ -333,10 +333,10 @@
     public static final String FUNC_DOCLOCATION_STRING = "document-location";
 
     static {
-        Map<String, Integer> keywords = new HashMap<>();
-        Map<String, Integer> axisnames = new HashMap<>();
-        Map<String, Integer> nodetests = new HashMap<>();
-        Map<String, Integer> nodetypes = new HashMap<>();
+        Map<String, Integer> keywords = new HashMap<String,Integer>();
+        Map<String, Integer> axisnames = new HashMap<String,Integer>();
+        Map<String, Integer> nodetests = new HashMap<String,Integer>();
+        Map<String, Integer> nodetypes = new HashMap<String,Integer>();
 
         axisnames.put(FROM_ANCESTORS_STRING, OpCodes.FROM_ANCESTORS);
         axisnames.put(FROM_ANCESTORS_OR_SELF_STRING, OpCodes.FROM_ANCESTORS_OR_SELF);
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/xml/internal/stream/dtd/nonvalidating/DTDGrammar.java openjdk-boot/jaxp/src/com/sun/xml/internal/stream/dtd/nonvalidating/DTDGrammar.java
--- openjdk-boot.orig/jaxp/src/com/sun/xml/internal/stream/dtd/nonvalidating/DTDGrammar.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/xml/internal/stream/dtd/nonvalidating/DTDGrammar.java	2018-05-20 04:52:08.139913634 +0100
@@ -140,7 +140,7 @@
     private int fAttributeDeclNextAttributeDeclIndex[][] = new int[INITIAL_CHUNK_COUNT][];
 
     /** Element index mapping table. */
-    private final Map<String, Integer> fElementIndexMap = new HashMap<>();
+    private final Map<String, Integer> fElementIndexMap = new HashMap<String,Integer>();
 
     /** Temporary qualified name. */
     private final QName fQName = new QName();
@@ -156,7 +156,7 @@
 
 
     /** table of XMLElementDecl   */
-    Map<String, XMLElementDecl> fElementDeclTab = new HashMap<>();
+    Map<String, XMLElementDecl> fElementDeclTab = new HashMap<String,XMLElementDecl>();
 
     /** Default constructor. */
     public DTDGrammar(SymbolTable symbolTable) {
diff -Nru openjdk-boot.orig/jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java openjdk-boot/jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java
--- openjdk-boot.orig/jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java	2018-05-20 04:52:08.139913634 +0100
@@ -63,7 +63,7 @@
     protected boolean fWarnDuplicateEntityDef;
 
     /** Entities. */
-    protected Map<String, Entity> fEntities = new HashMap<>();
+    protected Map<String, Entity> fEntities = new HashMap<String,Entity>();
 
     protected Entity.ScannedEntity fCurrentEntity ;
 
diff -Nru openjdk-boot.orig/jaxp/src/org/xml/sax/helpers/NamespaceSupport.java openjdk-boot/jaxp/src/org/xml/sax/helpers/NamespaceSupport.java
--- openjdk-boot.orig/jaxp/src/org/xml/sax/helpers/NamespaceSupport.java	2018-05-17 02:55:36.000000000 +0100
+++ openjdk-boot/jaxp/src/org/xml/sax/helpers/NamespaceSupport.java	2018-05-20 04:52:08.139913634 +0100
@@ -465,7 +465,7 @@
      */
     public Enumeration getPrefixes (String uri)
     {
-        List<String> prefixes = new ArrayList<>();
+        List<String> prefixes = new ArrayList<String>();
         Enumeration allPrefixes = getPrefixes();
         while (allPrefixes.hasMoreElements()) {
             String prefix = (String)allPrefixes.nextElement();
@@ -621,7 +621,7 @@
                 copyTables();
             }
             if (declarations == null) {
-                declarations = new ArrayList<>();
+                declarations = new ArrayList<String>();
             }
 
             prefix = prefix.intern();
@@ -809,17 +809,17 @@
         private void copyTables ()
         {
             if (prefixTable != null) {
-                prefixTable = new HashMap<>(prefixTable);
+                prefixTable = new HashMap<String,String>(prefixTable);
             } else {
-                prefixTable = new HashMap<>();
+                prefixTable = new HashMap<String,String>();
             }
             if (uriTable != null) {
-                uriTable = new HashMap<>(uriTable);
+                uriTable = new HashMap<String,String>(uriTable);
             } else {
-                uriTable = new HashMap<>();
+                uriTable = new HashMap<String,String>();
             }
-            elementNameTable = new HashMap<>();
-            attributeNameTable = new HashMap<>();
+            elementNameTable = new HashMap<String,String[]>();
+            attributeNameTable = new HashMap<String,String[]>();
             declSeen = true;
         }
 
diff -Nru openjdk-boot.orig/jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/exception/JAXWSExceptionBase.java openjdk-boot/jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/exception/JAXWSExceptionBase.java
--- openjdk-boot.orig/jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/exception/JAXWSExceptionBase.java	2018-05-17 02:55:37.000000000 +0100
+++ openjdk-boot/jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/exception/JAXWSExceptionBase.java	2018-05-20 04:52:08.139913634 +0100
@@ -131,7 +131,7 @@
                 args[i] = in.readObject();
             }
         } else {
-            List<Object> argList = new ArrayList<>(Math.min(len, 1024));
+            List<Object> argList = new ArrayList<Object>(Math.min(len, 1024));
             for (int i = 0; i < len; i++) {
                 argList.add(in.readObject());
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/beans/decoder/DocumentHandler.java openjdk-boot/jdk/src/share/classes/com/sun/beans/decoder/DocumentHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/beans/decoder/DocumentHandler.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/beans/decoder/DocumentHandler.java	2018-05-20 04:52:08.139913634 +0100
@@ -63,9 +63,10 @@
  */
 public final class DocumentHandler extends DefaultHandler {
     private final AccessControlContext acc = AccessController.getContext();
-    private final Map<String, Class<? extends ElementHandler>> handlers = new HashMap<>();
-    private final Map<String, Object> environment = new HashMap<>();
-    private final List<Object> objects = new ArrayList<>();
+    private final Map<String, Class<? extends ElementHandler>> handlers =
+					      new HashMap<String, Class<? extends ElementHandler>>();
+    private final Map<String, Object> environment = new HashMap<String, Object>();
+    private final List<Object> objects = new ArrayList<Object>();
 
     private Reference<ClassLoader> loader;
     private ExceptionListener listener;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/beans/TypeResolver.java openjdk-boot/jdk/src/share/classes/com/sun/beans/TypeResolver.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/beans/TypeResolver.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/beans/TypeResolver.java	2018-05-20 04:52:08.139913634 +0100
@@ -46,7 +46,7 @@
  */
 public final class TypeResolver {
 
-    private static final WeakCache<Type, Map<Type, Type>> CACHE = new WeakCache<>();
+    private static final WeakCache<Type, Map<Type, Type>> CACHE = new WeakCache<Type, Map<Type, Type>>();
 
     /**
      * Replaces the given {@code type} in an inherited method
@@ -181,7 +181,7 @@
             synchronized (CACHE) {
                 map = CACHE.get(actual);
                 if (map == null) {
-                    map = new HashMap<>();
+                    map = new HashMap<Type, Type>();
                     prepare(map, actual);
                     CACHE.put(actual, map);
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/beans/util/Cache.java openjdk-boot/jdk/src/share/classes/com/sun/beans/util/Cache.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/beans/util/Cache.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/beans/util/Cache.java	2018-05-20 04:52:08.139913634 +0100
@@ -45,7 +45,7 @@
     private final Kind keyKind; // a reference kind for the cache keys
     private final Kind valueKind; // a reference kind for the cache values
 
-    private final ReferenceQueue<Object> queue = new ReferenceQueue<>(); // queue for references to remove
+    private final ReferenceQueue<Object> queue = new ReferenceQueue<Object>(); // queue for references to remove
 
     private volatile CacheEntry<K,V>[] table = newTable(1 << 3); // table's length MUST be a power of two
     private int threshold = 6; // the next size value at which to resize
@@ -126,7 +126,7 @@
             }
             V value = create(key);
             Objects.requireNonNull(value, "value");
-            this.table[index] = new CacheEntry<>(hash, key, value, this.table[index]);
+            this.table[index] = new CacheEntry<K,V>(hash, key, value, this.table[index]);
             if (++this.size >= this.threshold) {
                 if (this.table.length == MAXIMUM_CAPACITY) {
                     this.threshold = Integer.MAX_VALUE;
@@ -405,21 +405,21 @@
     public static enum Kind {
         STRONG {
             <T> Ref<T> create(Object owner, T value, ReferenceQueue<? super T> queue) {
-                return new Strong<>(owner, value);
+                return new Strong<T>(owner, value);
             }
         },
         SOFT {
             <T> Ref<T> create(Object owner, T referent, ReferenceQueue<? super T> queue) {
                 return (referent == null)
-                        ? new Strong<>(owner, referent)
-                        : new Soft<>(owner, referent, queue);
+                        ? new Strong<T>(owner, referent)
+                        : new Soft<T>(owner, referent, queue);
             }
         },
         WEAK {
             <T> Ref<T> create(Object owner, T referent, ReferenceQueue<? super T> queue) {
                 return (referent == null)
-                        ? new Strong<>(owner, referent)
-                        : new Weak<>(owner, referent, queue);
+                        ? new Strong<T>(owner, referent)
+                        : new Weak<T>(owner, referent, queue);
             }
         };
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Attribute.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Attribute.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Attribute.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Attribute.java	2018-05-20 04:52:08.143913571 +0100
@@ -103,9 +103,9 @@
         return this.def.compareTo(that.def);
     }
 
-    private static final Map<List<Attribute>, List<Attribute>> canonLists = new HashMap<>();
-    private static final Map<Layout, Attribute> attributes = new HashMap<>();
-    private static final Map<Layout, Attribute> standardDefs = new HashMap<>();
+    private static final Map<List<Attribute>, List<Attribute>> canonLists = new HashMap<List<Attribute>, List<Attribute>>();
+    private static final Map<Layout, Attribute> attributes = new HashMap<Layout, Attribute>();
+    private static final Map<Layout, Attribute> standardDefs = new HashMap<Layout, Attribute>();
 
     // Canonicalized lists of trivial attrs (Deprecated, etc.)
     // are used by trimToSize, in order to reduce footprint
@@ -115,7 +115,7 @@
         synchronized (canonLists) {
             List<Attribute> cl = canonLists.get(al);
             if (cl == null) {
-                cl = new ArrayList<>(al.size());
+                cl = new ArrayList<Attribute>(al.size());
                 cl.addAll(al);
                 cl = Collections.unmodifiableList(cl);
                 canonLists.put(al, cl);
@@ -336,9 +336,9 @@
 
         public void addAttribute(Attribute a) {
             if (attributes == null)
-                attributes = new ArrayList<>(3);
+                attributes = new ArrayList<Attribute>(3);
             else if (!(attributes instanceof ArrayList))
-                attributes = new ArrayList<>(attributes);  // unfreeze it
+                attributes = new ArrayList<Attribute>(attributes);  // unfreeze it
             attributes.add(a);
         }
 
@@ -346,7 +346,7 @@
             if (attributes == null)       return null;
             if (!attributes.contains(a))  return null;
             if (!(attributes instanceof ArrayList))
-                attributes = new ArrayList<>(attributes);  // unfreeze it
+                attributes = new ArrayList<Attribute>(attributes);  // unfreeze it
             attributes.remove(a);
             return a;
         }
@@ -838,7 +838,7 @@
     */
     static //private
     Layout.Element[] tokenizeLayout(Layout self, int curCble, String layout) {
-        List<Layout.Element> col = new ArrayList<>(layout.length());
+        List<Layout.Element> col = new ArrayList<Layout.Element>(layout.length());
         tokenizeLayout(self, curCble, layout, col);
         Layout.Element[] res = new Layout.Element[col.size()];
         col.toArray(res);
@@ -903,7 +903,7 @@
             case 'T': // union: 'T' any_int union_case* '(' ')' '[' body ']'
                 kind = EK_UN;
                 i = tokenizeSInt(e, layout, i);
-                List<Layout.Element> cases = new ArrayList<>();
+                List<Layout.Element> cases = new ArrayList<Layout.Element>();
                 for (;;) {
                     // Keep parsing cases until we hit the default case.
                     if (layout.charAt(i++) != '(')
@@ -1057,7 +1057,7 @@
     }
     static //private
     String[] splitBodies(String layout) {
-        List<String> bodies = new ArrayList<>();
+        List<String> bodies = new ArrayList<String>();
         // Parse several independent layout bodies:  "[foo][bar]...[baz]"
         for (int i = 0; i < layout.length(); i++) {
             if (layout.charAt(i++) != '[')
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java	2018-05-20 04:38:34.956799495 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/BandStructure.java	2018-05-20 04:52:08.143913571 +0100
@@ -257,7 +257,7 @@
         assert(basicCodings[_meta_default] == null);
         assert(basicCodings[_meta_canon_min] != null);
         assert(basicCodings[_meta_canon_max] != null);
-        Map<Coding, Integer> map = new HashMap<>();
+        Map<Coding, Integer> map = new HashMap<Coding, Integer>();
         for (int i = 0; i < basicCodings.length; i++) {
             Coding c = basicCodings[i];
             if (c == null)  continue;
@@ -1067,8 +1067,8 @@
 
     // Bootstrap support for CPRefBands.  These are needed to record
     // intended CP indexes, before the CP has been created.
-    private final List<CPRefBand> allKQBands = new ArrayList<>();
-    private List<Object[]> needPredefIndex = new ArrayList<>();
+    private final List<CPRefBand> allKQBands = new ArrayList<CPRefBand>();
+    private List<Object[]> needPredefIndex = new ArrayList<Object[]>();
 
 
     int encodeRef(Entry e, Index ix) {
@@ -1705,7 +1705,7 @@
     protected int attrClassFileVersionMask;
 
     // Mapping from Attribute.Layout to Band[] (layout element bands).
-    protected Map<Attribute.Layout, Band[]> attrBandTable = new HashMap<>();
+    protected Map<Attribute.Layout, Band[]> attrBandTable = new HashMap<Attribute.Layout, Band[]>();
 
     // Well-known attributes:
     protected final Attribute.Layout attrCodeEmpty;
@@ -1714,16 +1714,16 @@
     protected final Attribute.Layout attrConstantValue;
 
     // Mapping from Attribute.Layout to Integer (inverse of attrDefs)
-    Map<Attribute.Layout, Integer> attrIndexTable = new HashMap<>();
+    Map<Attribute.Layout, Integer> attrIndexTable = new HashMap<Attribute.Layout, Integer>();
 
     // Mapping from attribute index (<32 are flag bits) to attributes.
     protected List<List<Attribute.Layout>> attrDefs =
-            new FixedList<>(ATTR_CONTEXT_LIMIT);
+            new FixedList<List<Attribute.Layout>>(ATTR_CONTEXT_LIMIT);
     {
         for (int i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
             assert(attrIndexLimit[i] == 0);
             attrIndexLimit[i] = 32;  // just for the sake of predefs.
-            attrDefs.set(i, new ArrayList<>(Collections.nCopies(
+            attrDefs.set(i, new ArrayList<Attribute.Layout>(Collections.nCopies(
                     attrIndexLimit[i], (Attribute.Layout)null)));
 
         }
@@ -1913,7 +1913,7 @@
 
     protected List<Attribute.Layout> getPredefinedAttrs(int ctype) {
         assert(attrIndexLimit[ctype] != 0);
-        List<Attribute.Layout> res = new ArrayList<>(attrIndexLimit[ctype]);
+        List<Attribute.Layout> res = new ArrayList<Attribute.Layout>(attrIndexLimit[ctype]);
         // Remove nulls and non-predefs.
         for (int ai = 0; ai < attrIndexLimit[ctype]; ai++) {
             if (testBit(attrDefSeen[ctype], 1L<<ai))  continue;
@@ -2537,7 +2537,7 @@
     // DEBUG ONLY:  Record something about the band order.
     boolean notePrevForAssert(Band b, Band p) {
         if (prevForAssertMap == null)
-            prevForAssertMap = new HashMap<>();
+            prevForAssertMap = new HashMap<Band, Band>();
         prevForAssertMap.put(b, p);
         return true;
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/ClassReader.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/ClassReader.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/ClassReader.java	2018-05-20 04:38:34.316809638 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/ClassReader.java	2018-05-20 04:52:08.143913571 +0100
@@ -466,7 +466,7 @@
 
     void readInnerClasses(Class cls) throws IOException {
         int nc = readUnsignedShort();
-        ArrayList<InnerClass> ics = new ArrayList<>(nc);
+        ArrayList<InnerClass> ics = new ArrayList<InnerClass>(nc);
         for (int i = 0; i < nc; i++) {
             InnerClass ic =
                 new InnerClass(readClassRef(),
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/CodingChooser.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/CodingChooser.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/CodingChooser.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/CodingChooser.java	2018-05-20 04:52:08.143913571 +0100
@@ -743,9 +743,9 @@
         // Steps 1/2/3 are interdependent, and may be iterated.
         // Steps 4 and 5 may be decided independently afterward.
         int[] LValuesCoded = PopulationCoding.LValuesCoded;
-        List<Coding> bestFits = new ArrayList<>();
-        List<Coding> fullFits = new ArrayList<>();
-        List<Coding> longFits = new ArrayList<>();
+        List<Coding> bestFits = new ArrayList<Coding>();
+        List<Coding> fullFits = new ArrayList<Coding>();
+        List<Coding> longFits = new ArrayList<Coding>();
         final int PACK_TO_MAX_S = 1;
         if (bestPopFVC <= 255) {
             bestFits.add(BandStructure.BYTE1);
@@ -785,7 +785,7 @@
                 }
             }
         }
-        List<Coding> allFits = new ArrayList<>();
+        List<Coding> allFits = new ArrayList<Coding>();
         for (Iterator<Coding> i = bestFits.iterator(),
                       j = fullFits.iterator(),
                       k = longFits.iterator();
@@ -1230,10 +1230,10 @@
         Histogram hist = getValueHistogram();
         int fVlen = stressLen(hist.getTotalLength());
         if (fVlen == 0)  return coding;
-        List<Integer> popvals = new ArrayList<>();
+        List<Integer> popvals = new ArrayList<Integer>();
         if (stress.nextBoolean()) {
             // Build the population from the value list.
-            Set<Integer> popset = new HashSet<>();
+            Set<Integer> popset = new HashSet<Integer>();
             for (int i = start; i < end; i++) {
                 if (popset.add(values[i]))  popvals.add(values[i]);
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Coding.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Coding.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Coding.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Coding.java	2018-05-20 04:52:08.143913571 +0100
@@ -402,7 +402,7 @@
     private static Map<Coding, Coding> codeMap;
 
     private static synchronized Coding of(int B, int H, int S, int del) {
-        if (codeMap == null)  codeMap = new HashMap<>();
+        if (codeMap == null)  codeMap = new HashMap<Coding, Coding>();
         Coding x0 = new Coding(B, H, S, del);
         Coding x1 = codeMap.get(x0);
         if (x1 == null)  codeMap.put(x0, x1 = x0);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java	2018-05-20 04:52:08.143913571 +0100
@@ -917,7 +917,7 @@
     public static
     Index[] partition(Index ix, int[] keys) {
         // %%% Should move this into class Index.
-        List<List<Entry>> parts = new ArrayList<>();
+        List<List<Entry>> parts = new ArrayList<List<Entry>>();
         Entry[] cpMap = ix.cpMap;
         assert(keys.length == cpMap.length);
         for (int i = 0; i < keys.length; i++) {
@@ -928,7 +928,7 @@
             }
             List<Entry> part = parts.get(key);
             if (part == null) {
-                parts.set(key, part = new ArrayList<>());
+                parts.set(key, part = new ArrayList<Entry>());
             }
             part.add(cpMap[i]);
         }
@@ -1137,7 +1137,7 @@
     void completeReferencesIn(Set<Entry> cpRefs, boolean flattenSigs) {
         cpRefs.remove(null);
         for (ListIterator<Entry> work =
-                 new ArrayList<>(cpRefs).listIterator(cpRefs.size());
+                 new ArrayList<Entry>(cpRefs).listIterator(cpRefs.size());
              work.hasPrevious(); ) {
             Entry e = work.previous();
             work.remove();          // pop stack
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Driver.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Driver.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Driver.java	2018-05-20 04:38:34.956799495 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Driver.java	2018-05-20 04:52:08.143913571 +0100
@@ -61,7 +61,7 @@
                 ResourceBundle.getBundle("com.sun.java.util.jar.pack.DriverResource");
 
     public static void main(String[] ava) throws IOException {
-        List<String> av = new ArrayList<>(Arrays.asList(ava));
+        List<String> av = new ArrayList<String>(Arrays.asList(ava));
 
         boolean doPack   = true;
         boolean doUnpack = false;
@@ -84,7 +84,7 @@
         }
 
         // Collect engine properties here:
-        Map<String,String> engProps = new HashMap<>();
+        Map<String,String> engProps = new HashMap<String, String>();
         engProps.put(verboseProp, System.getProperty(verboseProp));
 
         String optionMap;
@@ -98,7 +98,7 @@
         }
 
         // Collect argument properties here:
-        Map<String,String> avProps = new HashMap<>();
+        Map<String,String> avProps = new HashMap<String, String>();
         try {
             for (;;) {
                 String state = parseCommandOptions(av, optionMap, avProps);
@@ -533,7 +533,7 @@
         String resultString = null;
 
         // Convert options string into optLines dictionary.
-        TreeMap<String,String[]> optmap = new TreeMap<>();
+        TreeMap<String,String[]> optmap = new TreeMap<String,String[]>();
     loadOptmap:
         for (String optline : options.split("\n")) {
             String[] words = optline.split("\\p{Space}+");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/FixedList.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/FixedList.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/FixedList.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/FixedList.java	2018-05-20 04:52:08.143913571 +0100
@@ -45,7 +45,7 @@
     private final ArrayList<E> flist;
 
     protected FixedList(int capacity) {
-        flist = new ArrayList<>(capacity);
+        flist = new ArrayList<E>(capacity);
         // initialize the list to null
         for (int i = 0 ; i < capacity ; i++) {
             flist.add(null);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Fixups.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Fixups.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Fixups.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Fixups.java	2018-05-20 04:52:08.143913571 +0100
@@ -126,11 +126,11 @@
     public void setBytes(byte[] newBytes) {
         if (bytes == newBytes)  return;
         ArrayList<Fixup> old = null;
-        assert((old = new ArrayList<>(this)) != null);
+        assert((old = new ArrayList<Fixup>(this)) != null);
         if (bytes == null || newBytes == null) {
             // One or the other representations is deficient.
             // Construct a checkpoint.
-            ArrayList<Fixup> save = new ArrayList<>(this);
+            ArrayList<Fixup> save = new ArrayList<Fixup>(this);
             clear();
             bytes = newBytes;
             addAll(save);
@@ -138,7 +138,7 @@
             // assume newBytes is some sort of bitwise copy of the old bytes
             bytes = newBytes;
         }
-        assert(old.equals(new ArrayList<>(this)));
+        assert(old.equals(new ArrayList<Fixup>(this)));
     }
 
     static final int LOC_SHIFT = 1;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Package.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Package.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Package.java	2018-05-20 04:38:34.316809638 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Package.java	2018-05-20 04:52:08.143913571 +0100
@@ -112,7 +112,7 @@
     public static final Attribute.Layout attrSourceFileSpecial;
     public static final Map<Attribute.Layout, Attribute> attrDefs;
     static {
-        Map<Layout, Attribute> ad = new HashMap<>(3);
+        Map<Layout, Attribute> ad = new HashMap<Layout, Attribute>(3);
         attrCodeEmpty = Attribute.define(ad, ATTR_CONTEXT_METHOD,
                                          "Code", "").layout();
         attrInnerClassesEmpty = Attribute.define(ad, ATTR_CONTEXT_CLASS,
@@ -181,7 +181,7 @@
         }
     }
 
-    ArrayList<Package.Class> classes = new ArrayList<>();
+    ArrayList<Package.Class> classes = new ArrayList<Package.Class>();
 
     public List<Package.Class> getClasses() {
         return classes;
@@ -263,7 +263,7 @@
             if (olda == null)
                 return;  // no SourceFile attr.
             String obvious = getObviousSourceFile();
-            List<Entry> ref = new ArrayList<>(1);
+            List<Entry> ref = new ArrayList<Entry>(1);
             olda.visitRefs(this, VRM_PACKAGE, ref);
             Utf8Entry sfName = (Utf8Entry) ref.get(0);
             Attribute a = olda;
@@ -291,7 +291,7 @@
             if (a != olda) {
                 if (verbose > 2)
                     Utils.log.fine("recoding obvious SourceFile="+obvious);
-                List<Attribute> newAttrs = new ArrayList<>(getAttributes());
+                List<Attribute> newAttrs = new ArrayList<Attribute>(getAttributes());
                 int where = newAttrs.indexOf(olda);
                 newAttrs.set(where, a);
                 setAttributes(newAttrs);
@@ -321,7 +321,7 @@
         }
 
         public void setInnerClasses(Collection<InnerClass> ics) {
-            innerClasses = (ics == null) ? null : new ArrayList<>(ics);
+            innerClasses = (ics == null) ? null : new ArrayList<InnerClass>(ics);
             // Edit the attribute list, if necessary.
             Attribute a = getAttribute(attrInnerClassesEmpty);
             if (innerClasses != null && a == null)
@@ -340,7 +340,7 @@
          *  with that of Package.this.allInnerClasses.
          */
         public List<InnerClass> computeGloballyImpliedICs() {
-            Set<Entry> cpRefs = new HashSet<>();
+            Set<Entry> cpRefs = new HashSet<Entry>();
             {   // This block temporarily displaces this.innerClasses.
                 ArrayList<InnerClass> innerClassesSaved = innerClasses;
                 innerClasses = null;  // ignore for the moment
@@ -349,7 +349,7 @@
             }
             ConstantPool.completeReferencesIn(cpRefs, true);
 
-            Set<Entry> icRefs = new HashSet<>();
+            Set<Entry> icRefs = new HashSet<Entry>();
             for (Entry e : cpRefs) {
                 // Restrict cpRefs to InnerClasses entries only.
                 if (!(e instanceof ClassEntry))  continue;
@@ -365,7 +365,7 @@
             // This loop is structured this way so as to accumulate
             // entries into impliedICs in an order which reflects
             // the order of allInnerClasses.
-            ArrayList<InnerClass> impliedICs = new ArrayList<>();
+            ArrayList<InnerClass> impliedICs = new ArrayList<InnerClass>();
             for (InnerClass ic : allInnerClasses) {
                 // This one is locally relevant if it describes
                 // a member of the current class, or if the current
@@ -408,8 +408,8 @@
                 // Diff is A since I is empty.
             }
             // (I*A) is non-trivial
-            Set<InnerClass> center = new HashSet<>(actualICs);
-            center.retainAll(new HashSet<>(impliedICs));
+            Set<InnerClass> center = new HashSet<InnerClass>(actualICs);
+            center.retainAll(new HashSet<InnerClass>(impliedICs));
             impliedICs.addAll(actualICs);
             impliedICs.removeAll(center);
             // Diff is now I^A = (I+A)-(I*A).
@@ -538,7 +538,7 @@
                 super(flags, descriptor);
                 assert(!descriptor.isMethod());
                 if (fields == null)
-                    fields = new ArrayList<>();
+                    fields = new ArrayList<Field>();
                 boolean added = fields.add(this);
                 assert(added);
                 order = fields.size();
@@ -563,7 +563,7 @@
                 super(flags, descriptor);
                 assert(descriptor.isMethod());
                 if (methods == null)
-                    methods = new ArrayList<>();
+                    methods = new ArrayList<Method>();
                 boolean added = methods.add(this);
                 assert(added);
             }
@@ -728,14 +728,14 @@
     }
 
     // What non-class files are in this unit?
-    ArrayList<File> files = new ArrayList<>();
+    ArrayList<File> files = new ArrayList<File>();
 
     public List<File> getFiles() {
         return files;
     }
 
     public List<File> getClassStubs() {
-        List<File> classStubs = new ArrayList<>(classes.size());
+        List<File> classStubs = new ArrayList<File>(classes.size());
         for (Class cls : classes) {
             assert(cls.file.isClassStub());
             classStubs.add(cls.file);
@@ -749,7 +749,7 @@
         int modtime = NO_MODTIME;
         int options = 0;  // random flag bits, such as deflate_hint
         Class stubClass;  // if this is a stub, here's the class
-        ArrayList<byte[]> prepend = new ArrayList<>();  // list of byte[]
+        ArrayList<byte[]> prepend = new ArrayList<byte[]>();  // list of byte[]
         java.io.ByteArrayOutputStream append = new ByteArrayOutputStream();
 
         File(Utf8Entry name) {
@@ -852,7 +852,7 @@
         public InputStream getInputStream() {
             InputStream in = new ByteArrayInputStream(append.toByteArray());
             if (prepend.isEmpty())  return in;
-            List<InputStream> isa = new ArrayList<>(prepend.size()+1);
+            List<InputStream> isa = new ArrayList<InputStream>(prepend.size()+1);
             for (byte[] bytes : prepend) {
                 isa.add(new ByteArrayInputStream(bytes));
             }
@@ -888,7 +888,7 @@
     }
 
     // Is there a globally declared table of inner classes?
-    List<InnerClass> allInnerClasses = new ArrayList<>();
+    List<InnerClass> allInnerClasses = new ArrayList<InnerClass>();
     Map<ClassEntry, InnerClass>   allInnerClassesByThis;
 
     public
@@ -903,7 +903,7 @@
         allInnerClasses.addAll(ics);
 
         // Make an index:
-        allInnerClassesByThis = new HashMap<>(allInnerClasses.size());
+        allInnerClassesByThis = new HashMap<ClassEntry,InnerClass>(allInnerClasses.size());
         for (InnerClass ic : allInnerClasses) {
             Object pic = allInnerClassesByThis.put(ic.thisClass, ic);
             assert(pic == null);  // caller must ensure key uniqueness!
@@ -1290,7 +1290,7 @@
 
     // Use this before writing the class files.
     void ensureAllClassFiles() {
-        Set<File> fileSet = new HashSet<>(files);
+        Set<File> fileSet = new HashSet<File>(files);
         for (Class cls : classes) {
             // Add to the end of ths list:
             if (!fileSet.contains(cls.file))
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageReader.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageReader.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageReader.java	2018-05-20 04:38:34.956799495 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageReader.java	2018-05-20 04:52:08.143913571 +0100
@@ -686,7 +686,7 @@
         cp_Signature_classes.expectLength(getIntTotal(numSigClasses));
         cp_Signature_classes.readFrom(in);
         cp_Signature_classes.setIndex(getCPIndex(CONSTANT_Class));
-        utf8Signatures = new HashMap<>();
+        utf8Signatures = new HashMap<Utf8Entry, SignatureEntry>();
         for (int i = 0; i < cpMap.length; i++) {
             Utf8Entry formRef = (Utf8Entry) cp_Signature_form.getRef();
             ClassEntry[] classRefs = new ClassEntry[numSigClasses[i]];
@@ -892,7 +892,7 @@
         ic_name.expectLength(longICCount);
         ic_name.readFrom(in);
         ic_flags.resetForSecondPass();
-        List<InnerClass> icList = new ArrayList<>(numInnerClasses);
+        List<InnerClass> icList = new ArrayList<InnerClass>(numInnerClasses);
         for (int i = 0; i < numInnerClasses; i++) {
             int flags = ic_flags.getInt();
             boolean longForm = (flags & ACC_IC_LONG_FORM) != 0;
@@ -934,7 +934,7 @@
 
     void readLocalInnerClasses(Class cls) throws IOException {
         int nc = class_InnerClasses_N.getInt();
-        List<InnerClass> localICs = new ArrayList<>(nc);
+        List<InnerClass> localICs = new ArrayList<InnerClass>(nc);
         for (int i = 0; i < nc; i++) {
             ClassEntry thisClass = (ClassEntry) class_InnerClasses_RC.getRef();
             int        flags     =              class_InnerClasses_F.getInt();
@@ -1062,7 +1062,7 @@
 
     Entry[] reconstructLocalCPMap(Class cls) {
         Set<Entry> ldcRefs = ldcRefMap.get(cls);
-        Set<Entry> cpRefs = new HashSet<>();
+        Set<Entry> cpRefs = new HashSet<Entry>();
 
         // look for constant pool entries:
         cls.visitRefs(VRM_CLASSIC, cpRefs);
@@ -1167,7 +1167,7 @@
         method_descr.expectLength(totalNM);
         if (verbose > 1)  Utils.log.fine("expecting #fields="+totalNF+" and #methods="+totalNM+" in #classes="+numClasses);
 
-        List<Class.Field> fields = new ArrayList<>(totalNF);
+        List<Class.Field> fields = new ArrayList<Class.Field>(totalNF);
         field_descr.readFrom(in);
         for (int i = 0; i < classes.length; i++) {
             Class c = classes[i];
@@ -1183,7 +1183,7 @@
         countAndReadAttrs(ATTR_CONTEXT_FIELD, fields);
         fields = null;  // release to GC
 
-        List<Class.Method> methods = new ArrayList<>(totalNM);
+        List<Class.Method> methods = new ArrayList<Class.Method>(totalNM);
         method_descr.readFrom(in);
         for (int i = 0; i < classes.length; i++) {
             Class c = classes[i];
@@ -1206,10 +1206,10 @@
 
     Code[] allCodes;
     List<Code> codesWithFlags;
-    Map<Class, Set<Entry>> ldcRefMap = new HashMap<>();
+    Map<Class, Set<Entry>> ldcRefMap = new HashMap<Class, Set<Entry>>();
 
     Code[] buildCodeAttrs(List<Class.Method> methods) {
-        List<Code> codes = new ArrayList<>(methods.size());
+        List<Code> codes = new ArrayList<Code>(methods.size());
         for (Class.Method m : methods) {
             if (m.getAttribute(attrCodeEmpty) != null) {
                 m.code = new Code(m);
@@ -1233,7 +1233,7 @@
         boolean attrsOK = testBit(archiveOptions, AO_HAVE_ALL_CODE_FLAGS);
         code_headers.expectLength(allCodes.length);
         code_headers.readFrom(in);
-        List<Code> longCodes = new ArrayList<>(allCodes.length / 10);
+        List<Code> longCodes = new ArrayList<Code>(allCodes.length / 10);
         for (int i = 0; i < allCodes.length; i++) {
             Code c = allCodes[i];
             int sc = code_headers.getByte();
@@ -1472,7 +1472,7 @@
                 bits -= (1L<<ai);
                 nfa += 1;
             }
-            List<Attribute> ha = new ArrayList<>(nfa + noa);
+            List<Attribute> ha = new ArrayList<Attribute>(nfa + noa);
             h.attributes = ha;
             bits = attrBits;  // iterate again
             for (int ai = 0; bits != 0; ai++) {
@@ -1596,7 +1596,7 @@
     void readAttrs(int ctype, Collection<? extends Attribute.Holder> holders)
             throws IOException {
         // Decode band values into attributes.
-        Set<Attribute.Layout> sawDefs = new HashSet<>();
+        Set<Attribute.Layout> sawDefs = new HashSet<Attribute.Layout>();
         ByteArrayOutputStream buf = new ByteArrayOutputStream();
         for (final Attribute.Holder h : holders) {
             if (h.attributes == null)  continue;
@@ -1799,7 +1799,7 @@
         // scratch buffer for collecting code::
         byte[] buf = new byte[1<<12];
         // record of all switch opcodes (these are variable-length)
-        List<Integer> allSwitchOps = new ArrayList<>();
+        List<Integer> allSwitchOps = new ArrayList<Integer>();
         for (int k = 0; k < allCodes.length; k++) {
             Code c = allCodes[k];
         scanOneMethod:
@@ -1915,7 +1915,7 @@
 
             Set<Entry> ldcRefSet = ldcRefMap.get(curClass);
             if (ldcRefSet == null)
-                ldcRefMap.put(curClass, ldcRefSet = new HashSet<>());
+                ldcRefMap.put(curClass, ldcRefSet = new HashSet<Entry>());
 
             ClassEntry thisClass  = curClass.thisClass;
             ClassEntry superClass = curClass.superClass;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageWriter.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageWriter.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageWriter.java	2018-05-20 04:38:34.956799495 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackageWriter.java	2018-05-20 04:52:08.143913571 +0100
@@ -116,7 +116,7 @@
     int[][]     attrCounts;       // count attr. occurrences
 
     void setup() {
-        requiredEntries = new HashSet<>();
+        requiredEntries = new HashSet<Entry>();
         setArchiveOptions();
         trimClassAttributes();
         collectAttributeLayouts();
@@ -176,7 +176,7 @@
             }
         }
         // Decide on default version number (majority rule).
-        Map<Integer, int[]> verCounts = new HashMap<>();
+        Map<Integer, int[]> verCounts = new HashMap<Integer, int[]>();
         int bestCount = 0;
         int bestVersion = -1;
         for (Class cls : pkg.classes) {
@@ -728,7 +728,7 @@
 
     void collectAttributeLayouts() {
         maxFlags = new int[ATTR_CONTEXT_LIMIT];
-        allLayouts = new FixedList<>(ATTR_CONTEXT_LIMIT);
+        allLayouts = new FixedList<Map<Attribute.Layout, int[]>>(ATTR_CONTEXT_LIMIT);
         for (int i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
             allLayouts.set(i, new HashMap<Attribute.Layout, int[]>());
         }
@@ -773,7 +773,7 @@
         }
         // Collect counts for both predefs. and custom defs.
         // Decide on custom, local attribute definitions.
-        backCountTable = new HashMap<>();
+        backCountTable = new HashMap<Attribute.Layout, int[]>();
         attrCounts = new int[ATTR_CONTEXT_LIMIT][];
         for (int i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
             // Now the remaining defs in allLayouts[i] need attr. indexes.
@@ -888,7 +888,7 @@
     Attribute.Layout[] attrDefsWritten;
 
     void writeAttrDefs() throws IOException {
-        List<Object[]> defList = new ArrayList<>();
+        List<Object[]> defList = new ArrayList<Object[]>();
         for (int i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
             int limit = attrDefs.get(i).size();
             for (int j = 0; j < limit; j++) {
@@ -1005,7 +1005,7 @@
     void collectInnerClasses() {
         // Capture inner classes, removing them from individual classes.
         // Irregular inner classes must stay local, though.
-        Map<ClassEntry, InnerClass> allICMap = new HashMap<>();
+        Map<ClassEntry, InnerClass> allICMap = new HashMap<ClassEntry, InnerClass>();
         // First, collect a consistent global set.
         for (Class cls : pkg.classes) {
             if (!cls.hasInnerClasses())  continue;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PackerImpl.java	2018-05-20 04:52:08.143913571 +0100
@@ -181,8 +181,8 @@
         final Map<Attribute.Layout, Attribute> attrDefs;
         final Map<Attribute.Layout, String> attrCommands;
         {
-            Map<Attribute.Layout, Attribute> lattrDefs   = new HashMap<>();
-            Map<Attribute.Layout, String>  lattrCommands = new HashMap<>();
+            Map<Attribute.Layout, Attribute> lattrDefs   = new HashMap<Attribute.Layout, Attribute>();
+            Map<Attribute.Layout, String>  lattrCommands = new HashMap<Attribute.Layout, String>();
             String[] keys = {
                 Pack200.Packer.CLASS_ATTRIBUTE_PFX,
                 Pack200.Packer.FIELD_ATTRIBUTE_PFX,
@@ -590,7 +590,7 @@
                 assert(pkg.files.containsAll(pkg.getClassStubs()));
                 // Order of stubs in file list must agree with classes.
                 List<Package.File> res = pkg.files;
-                assert((res = new ArrayList<>(pkg.files))
+                assert((res = new ArrayList<Package.File>(pkg.files))
                        .retainAll(pkg.getClassStubs()) || true);
                 assert(res.equals(pkg.getClassStubs()));
             }
@@ -623,7 +623,7 @@
 
         List<InFile> scanJar(JarFile jf) throws IOException {
             // Collect jar entries, preserving order.
-            List<InFile> inFiles = new ArrayList<>();
+            List<InFile> inFiles = new ArrayList<InFile>();
             try {
                 for (JarEntry je : Collections.list(jf.entries())) {
                     InFile inFile = new InFile(jf, je);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PopulationCoding.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PopulationCoding.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PopulationCoding.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PopulationCoding.java	2018-05-20 04:52:08.143913571 +0100
@@ -309,7 +309,7 @@
         // As each new value is added, we assert that the value
         // was not already in the set.
         Set<Integer> uniqueValuesForDebug = null;
-        assert((uniqueValuesForDebug = new HashSet<>()) != null);
+        assert((uniqueValuesForDebug = new HashSet<Integer>()) != null);
         int fillp = 1;
         maxForDebug += fillp;
         int min = Integer.MIN_VALUE;  // farthest from the center
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PropMap.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PropMap.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/PropMap.java	2018-05-20 04:38:34.956799495 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/PropMap.java	2018-05-20 04:52:08.143913571 +0100
@@ -47,8 +47,8 @@
  */
 
 final class PropMap implements SortedMap<String, String>  {
-    private final TreeMap<String, String> theMap = new TreeMap<>();;
-    private final List<PropertyChangeListener> listenerList = new ArrayList<>(1);
+    private final TreeMap<String, String> theMap = new TreeMap<String, String>();;
+    private final List<PropertyChangeListener> listenerList = new ArrayList<PropertyChangeListener>(1);
 
     void addListener(PropertyChangeListener listener) {
         listenerList.add(listener);
@@ -187,7 +187,7 @@
     // Get sequence of props for "prefix", and "prefix.*".
     List<String> getProperties(String prefix) {
         Collection<String> values = prefixMap(prefix).values();
-        List<String> res = new ArrayList<>(values.size());
+        List<String> res = new ArrayList<String>(values.size());
         res.addAll(values);
         while (res.remove(null));
         return res;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/TLGlobals.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/TLGlobals.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/TLGlobals.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/TLGlobals.java	2018-05-20 04:52:08.143913571 +0100
@@ -58,12 +58,12 @@
     private final Map<String, MemberEntry> memberEntries;
 
     TLGlobals() {
-        utf8Entries = new HashMap<>();
-        classEntries = new HashMap<>();
-        literalEntries = new HashMap<>();
-        signatureEntries = new HashMap<>();
-        descriptorEntries = new HashMap<>();
-        memberEntries = new HashMap<>();
+        utf8Entries = new HashMap<String,Utf8Entry>();
+        classEntries = new HashMap<String,ClassEntry>();
+        literalEntries = new HashMap<Object,LiteralEntry>();
+        signatureEntries = new HashMap<String,SignatureEntry>();
+        descriptorEntries = new HashMap<String,DescriptorEntry>();
+        memberEntries = new HashMap<String,MemberEntry>();
         props = new PropMap();
     }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java	2018-05-20 04:38:34.956799495 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/UnpackerImpl.java	2018-05-20 04:52:08.143913571 +0100
@@ -232,7 +232,7 @@
             props.setProperty(java.util.jar.Pack200.Unpacker.PROGRESS,"50");
             pkg.ensureAllClassFiles();
             // Now write out the files.
-            Set<Package.Class> classesToWrite = new HashSet<>(pkg.getClasses());
+            Set<Package.Class> classesToWrite = new HashSet<Package.Class>(pkg.getClasses());
             for (Package.File file : pkg.getFiles()) {
                 String name = file.nameString;
                 JarEntry je = new JarEntry(Utils.getJarEntryName(name));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Utils.java openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Utils.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/java/util/jar/pack/Utils.java	2018-05-20 04:38:34.956799495 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/java/util/jar/pack/Utils.java	2018-05-20 04:52:08.147913507 +0100
@@ -132,7 +132,7 @@
     // Keep a TLS point to the global data and environment.
     // This makes it simpler to supply environmental options
     // to the engine code, especially the native code.
-    static final ThreadLocal<TLGlobals> currentInstance = new ThreadLocal<>();
+    static final ThreadLocal<TLGlobals> currentInstance = new ThreadLocal<TLGlobals>();
 
     // convenience methods to access the TL globals
     static TLGlobals getTLGlobals() {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jmx/remote/security/SubjectDelegator.java openjdk-boot/jdk/src/share/classes/com/sun/jmx/remote/security/SubjectDelegator.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jmx/remote/security/SubjectDelegator.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jmx/remote/security/SubjectDelegator.java	2018-05-20 04:52:08.147913507 +0100
@@ -56,7 +56,7 @@
         // principal in the delegated subject
         //
         Collection<Principal> ps = getSubjectPrincipals(delegatedSubject);
-        final Collection<Permission> permissions = new ArrayList<>(ps.size());
+        final Collection<Permission> permissions = new ArrayList<Permission>(ps.size());
         for(Principal p : ps) {
             final String pname = p.getClass().getName() + "." + p.getName();
             permissions.add(new SubjectDelegationPermission(pname));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/cosnaming/CNCtx.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/cosnaming/CNCtx.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/cosnaming/CNCtx.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/cosnaming/CNCtx.java	2018-05-20 04:52:08.147913507 +0100
@@ -1093,7 +1093,7 @@
     @SuppressWarnings("unchecked")
     public  Hashtable<String, java.lang.Object> getEnvironment() throws NamingException {
         if (_env == null) {
-            return new Hashtable<>(5, 0.75f);
+            return new Hashtable<String, java.lang.Object>(5, 0.75f);
         } else {
             return (Hashtable<String, java.lang.Object>)_env.clone();
         }
@@ -1122,7 +1122,7 @@
         java.lang.Object propValue)
         throws NamingException {
             if (_env == null) {
-                _env = new Hashtable<>(7, 0.75f);
+                _env = new Hashtable<String, java.lang.Object>(7, 0.75f);
             } else {
                 // copy-on-write
                 _env = (Hashtable<String, java.lang.Object>)_env.clone();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/cosnaming/CNNameParser.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/cosnaming/CNNameParser.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/cosnaming/CNNameParser.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/cosnaming/CNNameParser.java	2018-05-20 04:52:08.147913507 +0100
@@ -132,7 +132,7 @@
         throws InvalidNameException {
 
         int len = str.length();
-        Vector<String> components = new Vector<>(10);
+        Vector<String> components = new Vector<String>(10);
         char[] id = new char[len];
         char[] kind = new char[len];
         int idCount, kindCount;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/cosnaming/IiopUrl.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/cosnaming/IiopUrl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/cosnaming/IiopUrl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/cosnaming/IiopUrl.java	2018-05-20 04:52:08.147913507 +0100
@@ -185,7 +185,7 @@
         } else {
             stringName = UrlUtil.decode(url.substring(addrEnd+1));
         }
-        addresses = new Vector<>(3);
+        addresses = new Vector<Address>(3);
         if (oldFormat) {
             // Only one host:port part, not multiple
             addresses.addElement(
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/DnsContextFactory.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/DnsContextFactory.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/DnsContextFactory.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/DnsContextFactory.java	2018-05-20 04:52:08.147913507 +0100
@@ -59,7 +59,7 @@
 
     public Context getInitialContext(Hashtable<?,?> env) throws NamingException {
         if (env == null) {
-            env = new Hashtable<>(5);
+            env = new Hashtable<Object, Object>(5);
         }
         return urlToContext(getInitCtxUrl(env), env);
     }
@@ -228,7 +228,7 @@
         if (security == null || input == null || input.isEmpty()) {
             return input;
         } else {
-            List<String> output = new ArrayList<>();
+            List<String> output = new ArrayList<String>();
             for (String platformServer: input) {
                 int colon = platformServer.indexOf(':',
                         platformServer.indexOf(']') + 1);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/DnsName.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/DnsName.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/DnsName.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/DnsName.java	2018-05-20 04:52:08.147913507 +0100
@@ -110,7 +110,7 @@
     // The labels of this domain name, as a list of strings.  Index 0
     // corresponds to the leftmost (least significant) label:  note that
     // this is the reverse of the ordering used by the Name interface.
-    private ArrayList<String> labels = new ArrayList<>();
+    private ArrayList<String> labels = new ArrayList<String>();
 
     // The number of octets needed to carry this domain name in a DNS
     // packet.  Equal to the sum of the lengths of each label, plus the
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/NameNode.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/NameNode.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/NameNode.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/NameNode.java	2018-05-20 04:52:08.147913507 +0100
@@ -140,7 +140,7 @@
 
             NameNode child = null;
             if (node.children == null) {
-                node.children = new Hashtable<>();
+                node.children = new Hashtable<String,NameNode>();
             } else {
                 child = node.children.get(key);
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/ResourceRecords.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/ResourceRecords.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/dns/ResourceRecords.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/dns/ResourceRecords.java	2018-05-20 04:52:08.147913507 +0100
@@ -45,10 +45,10 @@
     // Four sections:  question, answer, authority, additional.
     // The question section is treated as being made up of (shortened)
     // resource records, although this isn't technically how it's defined.
-    Vector<ResourceRecord> question = new Vector<>();
-    Vector<ResourceRecord> answer = new Vector<>();
-    Vector<ResourceRecord> authority = new Vector<>();
-    Vector<ResourceRecord> additional = new Vector<>();
+    Vector<ResourceRecord> question = new Vector<ResourceRecord>();
+    Vector<ResourceRecord> answer = new Vector<ResourceRecord>();
+    Vector<ResourceRecord> authority = new Vector<ResourceRecord>();
+    Vector<ResourceRecord> additional = new Vector<ResourceRecord>();
 
     /*
      * True if these resource records are from a zone transfer.  In
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/EventSupport.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/EventSupport.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/EventSupport.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/EventSupport.java	2018-05-20 04:52:08.147913507 +0100
@@ -119,7 +119,7 @@
      * NamingEventNotifiers; hashed by search arguments;
      */
     private Hashtable<NotifierArgs, NamingEventNotifier> notifiers =
-            new Hashtable<>(11);
+	new Hashtable<NotifierArgs, NamingEventNotifier>(11);
 
     /**
      * List of unsolicited notification listeners.
@@ -165,7 +165,7 @@
         if (l instanceof UnsolicitedNotificationListener) {
             // Add listener to this's list of unsolicited notifiers
             if (unsolicited == null) {
-                unsolicited = new Vector<>(3);
+                unsolicited = new Vector<UnsolicitedNotificationListener>(3);
             }
 
             unsolicited.addElement((UnsolicitedNotificationListener)l);
@@ -194,7 +194,7 @@
         if (l instanceof UnsolicitedNotificationListener) {
             // Add listener to this's list of unsolicited notifiers
             if (unsolicited == null) {
-                unsolicited = new Vector<>(3);
+                unsolicited = new Vector<UnsolicitedNotificationListener>(3);
             }
             unsolicited.addElement((UnsolicitedNotificationListener)l);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapClient.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapClient.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapClient.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapClient.java	2018-05-20 04:52:08.147913507 +0100
@@ -82,7 +82,7 @@
 
     // Default list of binary attributes
     private static final Hashtable<String, Boolean> defaultBinaryAttrs =
-            new Hashtable<>(23,0.75f);
+	new Hashtable<String, Boolean>(23,0.75f);
     static {
         defaultBinaryAttrs.put("userpassword", Boolean.TRUE);      //2.5.4.35
         defaultBinaryAttrs.put("javaserializeddata", Boolean.TRUE);
@@ -617,7 +617,7 @@
             res.entries.setSize(0); // clear the (previous) set of entries
         } else {
             res.entries =
-                new Vector<>(batchSize == Integer.MAX_VALUE ? 32 : batchSize);
+                new Vector<LdapEntry>(batchSize == Integer.MAX_VALUE ? 32 : batchSize);
         }
 
         if (res.referrals != null) {
@@ -667,7 +667,7 @@
             } else if ((seq == LDAP_REP_SEARCH_REF) && isLdapv3) {
 
                 // handle LDAPv3 search reference
-                Vector<String> URLs = new Vector<>(4);
+                Vector<String> URLs = new Vector<String>(4);
 
                 // %%% Although not strictly correct, some LDAP servers
                 //     encode the SEQUENCE OF tag in the SearchResultRef
@@ -683,7 +683,7 @@
                 }
 
                 if (res.referrals == null) {
-                    res.referrals = new Vector<>(4);
+                    res.referrals = new Vector<Vector<String>>(4);
                 }
                 res.referrals.addElement(URLs);
                 res.resControls = isLdapv3 ? parseControls(replyBer) : null;
@@ -773,7 +773,7 @@
             (replyBer.bytesLeft() > 0) &&
             (replyBer.peekByte() == LDAP_REP_REFERRAL)) {
 
-            Vector<String> URLs = new Vector<>(4);
+            Vector<String> URLs = new Vector<String>(4);
             int[] seqlen = new int[1];
 
             replyBer.parseSeq(seqlen);
@@ -785,7 +785,7 @@
             }
 
             if (res.referrals == null) {
-                res.referrals = new Vector<>(4);
+                res.referrals = new Vector<Vector<String>>(4);
             }
             res.referrals.addElement(URLs);
         }
@@ -796,7 +796,7 @@
 
         // handle LDAPv3 controls (if present)
         if ((replyBer.bytesLeft() > 0) && (replyBer.peekByte() == LDAP_CONTROLS)) {
-            Vector<Control> ctls = new Vector<>(4);
+            Vector<Control> ctls = new Vector<Control>(4);
             String controlOID;
             boolean criticality = false; // default
             byte[] controlValue = null;  // optional
@@ -1575,7 +1575,7 @@
     private void notifyUnsolicited(Object e) {
         Vector<LdapCtx> unsolicitedCopy;
         synchronized (unsolicited) {
-            unsolicitedCopy = new Vector<>(unsolicited);
+            unsolicitedCopy = new Vector<LdapCtx>(unsolicited);
             if (e instanceof NamingException) {
                 unsolicited.setSize(0);  // no more listeners after exception
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapCtxFactory.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapCtxFactory.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapCtxFactory.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapCtxFactory.java	2018-05-20 04:52:08.147913507 +0100
@@ -221,7 +221,7 @@
      * Used by Obj and obj/RemoteToAttrs too so must be public
      */
     public static Attribute createTypeNameAttr(Class<?> cl) {
-        Vector<String> v = new Vector<>(10);
+        Vector<String> v = new Vector<String>(10);
         String[] types = getTypeNames(cl, v);
         if (types.length > 0) {
             BasicAttribute tAttr =
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapCtx.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapCtx.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapCtx.java	2018-05-20 04:38:34.420807990 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapCtx.java	2018-05-20 04:52:08.147913507 +0100
@@ -313,7 +313,7 @@
             this.useDefaultPortNumber = true;
         }
 
-        schemaTrees = new Hashtable<>(11, 0.75f);
+        schemaTrees = new Hashtable<String, DirContext>(11, 0.75f);
         initEnv();
         try {
             connect(false);
@@ -2532,19 +2532,19 @@
             urlCount++;
         }
 
-        Vector<Vector<String>> referrals = new Vector<>(urlCount);
+        Vector<Vector<String>> referrals = new Vector<Vector<String>>(urlCount);
         int iURL;
         int i = 0;
 
         separator = refString.indexOf('\n');
         iURL = separator + 1;
         while ((separator = refString.indexOf('\n', iURL)) >= 0) {
-            Vector<String> referral = new Vector<>(1);
+            Vector<String> referral = new Vector<String>(1);
             referral.addElement(refString.substring(iURL, separator));
             referrals.addElement(referral);
             iURL = separator + 1;
         }
-        Vector<String> referral = new Vector<>(1);
+        Vector<String> referral = new Vector<String>(1);
         referral.addElement(refString.substring(iURL));
         referrals.addElement(referral);
 
@@ -2559,7 +2559,7 @@
         if (attrIds == null) {
             binaryAttrs = null;
         } else {
-            binaryAttrs = new Hashtable<>(11, 0.75f);
+            binaryAttrs = new Hashtable<String, Boolean>(11, 0.75f);
             StringTokenizer tokens =
                 new StringTokenizer(attrIds.toLowerCase(Locale.ENGLISH), " ");
 
@@ -2642,7 +2642,7 @@
                 }
 
                 // reset the cache before a new connection is established
-                schemaTrees = new Hashtable<>(11, 0.75f);
+                schemaTrees = new Hashtable<String, DirContext>(11, 0.75f);
                 connect(startTLS);
 
             } else if (!sharable || startTLS) {
@@ -2655,7 +2655,7 @@
                     }
                 }
                 // reset the cache before a new connection is established
-                schemaTrees = new Hashtable<>(11, 0.75f);
+                schemaTrees = new Hashtable<String, DirContext>(11, 0.75f);
                 connect(startTLS);
             }
 
@@ -2942,7 +2942,7 @@
             if (res.referrals == null) {
                 refs = null;
             } else if (handleReferrals == LdapClient.LDAP_REF_FOLLOW_SCHEME) {
-                refs = new Vector<>();
+                refs = new Vector<String>();
                 for (String s : res.referrals.elementAt(0)) {
                     if (s.startsWith("ldap:")) {
                         refs.add(s);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapName.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapName.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapName.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapName.java	2018-05-20 04:52:08.147913507 +0100
@@ -111,7 +111,7 @@
      */
     private LdapName(String name, Vector<Rdn> rdns, int beg, int end) {
         unparsed = name;
-        this.rdns = new Vector<>();
+        this.rdns = new Vector<Rdn>();
         for (int i = beg; i < end; i++) {
             this.rdns.addElement(rdns.elementAt(i));
         }
@@ -410,7 +410,7 @@
          */
         Vector<Rdn> getDn() throws InvalidNameException {
             cur = 0;
-            Vector<Rdn> rdns = new Vector<>(len / 3 + 10);  // leave room for growth
+            Vector<Rdn> rdns = new Vector<Rdn>(len / 3 + 10);  // leave room for growth
 
             if (len == 0) {
                 return rdns;
@@ -597,7 +597,7 @@
          * A vector of the TypeAndValue elements of this Rdn.
          * It is sorted to facilitate set operations.
          */
-        private final Vector<TypeAndValue> tvs = new Vector<>();
+        private final Vector<TypeAndValue> tvs = new Vector<TypeAndValue>();
 
         void add(TypeAndValue tv) {
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapResult.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapResult.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapResult.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapResult.java	2018-05-20 04:52:08.147913507 +0100
@@ -59,7 +59,7 @@
         switch (status) {
             case LdapClient.LDAP_COMPARE_TRUE:
                 status = LdapClient.LDAP_SUCCESS;
-                entries = new Vector<>(1,1);
+                entries = new Vector<LdapEntry>(1,1);
                 Attributes attrs = new BasicAttributes(LdapClient.caseIgnore);
                 LdapEntry entry = new LdapEntry( name, attrs );
                 entries.addElement(entry);
@@ -68,7 +68,7 @@
 
             case LdapClient.LDAP_COMPARE_FALSE:
                 status = LdapClient.LDAP_SUCCESS;
-                entries = new Vector<>(0);
+                entries = new Vector<LdapEntry>(0);
                 successful = true;
                 break;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapSchemaParser.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapSchemaParser.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/LdapSchemaParser.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/LdapSchemaParser.java	2018-05-20 04:52:08.147913507 +0100
@@ -519,7 +519,7 @@
         throws NamingException {
 
         int begin, end;
-        Vector<String> values = new Vector<>(5);
+        Vector<String> values = new Vector<String>(5);
 
         if (debug) {
             System.err.println("ReadQDescrList: pos="+pos[0]);
@@ -613,7 +613,7 @@
 
         int     begin, cur, end;
         String  oidName = null;
-        Vector<String> values = new Vector<>(5);
+        Vector<String> values = new Vector<String>(5);
 
         if (debug) {
             System.err.println("ReadOIDList: pos="+pos[0]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/NamingEventNotifier.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/NamingEventNotifier.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/NamingEventNotifier.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/NamingEventNotifier.java	2018-05-20 04:52:08.147913507 +0100
@@ -83,7 +83,7 @@
         context = (LdapCtx)ctx.newInstance(new Control[]{psearch});
         eventSrc = ctx;
 
-        namingListeners = new Vector<>();
+        namingListeners = new Vector<NamingListener>();
         namingListeners.addElement(firstListener);
 
         worker = Obj.helper.createThread(this);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/Obj.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/Obj.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/Obj.java	2018-05-20 04:38:34.968799304 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/Obj.java	2018-05-20 04:52:08.147913507 +0100
@@ -207,7 +207,7 @@
         } else {
             StringTokenizer parser =
                 new StringTokenizer((String)codebaseAttr.get());
-            Vector<String> vec = new Vector<>(10);
+            Vector<String> vec = new Vector<String>(10);
             while (parser.hasMoreTokens()) {
                 vec.addElement(parser.nextToken());
             }
@@ -411,7 +411,7 @@
              * Temporary Vector for decoded RefAddr addresses - used to ensure
              * unordered addresses are correctly re-ordered.
              */
-            Vector<RefAddr> refAddrList = new Vector<>();
+            Vector<RefAddr> refAddrList = new Vector<RefAddr>();
             refAddrList.setSize(attr.size());
 
             for (NamingEnumeration<?> vals = attr.getAll(); vals.hasMore(); ) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/pool/Connections.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/pool/Connections.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/pool/Connections.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/pool/Connections.java	2018-05-20 04:52:08.147913507 +0100
@@ -98,11 +98,11 @@
         } else {
             this.prefSize = prefSize;
         }
-        conns = new ArrayList<>(maxSize > 0 ? maxSize : DEFAULT_SIZE);
+        conns = new ArrayList<ConnectionDesc>(maxSize > 0 ? maxSize : DEFAULT_SIZE);
 
         // Maintain soft ref to id so that this Connections' entry in
         // Pool doesn't get GC'ed prematurely
-        ref = new SoftReference<>(id);
+        ref = new SoftReference<Object>(id);
 
         d("init size=", initSize);
         d("max size=", maxSize);
@@ -292,9 +292,9 @@
     boolean expire(long threshold) {
         List<ConnectionDesc> clonedConns;
         synchronized(this) {
-            clonedConns = new ArrayList<>(conns);
+            clonedConns = new ArrayList<ConnectionDesc>(conns);
         }
-        List<ConnectionDesc> expired = new ArrayList<>();
+        List<ConnectionDesc> expired = new ArrayList<ConnectionDesc>();
 
         for (ConnectionDesc entry : clonedConns) {
             d("expire(): ", entry);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/pool/Pool.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/pool/Pool.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/pool/Pool.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/pool/Pool.java	2018-05-20 04:52:08.147913507 +0100
@@ -83,7 +83,7 @@
      * Used for connections cleanup
      */
     private static final ReferenceQueue<ConnectionsRef> queue =
-        new ReferenceQueue<>();
+        new ReferenceQueue<ConnectionsRef>();
     private static final Collection<Reference<ConnectionsRef>> weakRefs =
         Collections.synchronizedList(new LinkedList<Reference<ConnectionsRef>>());
 
@@ -93,7 +93,7 @@
     final private Map<Object, ConnectionsRef> map;
 
     public Pool(int initSize, int prefSize, int maxSize) {
-        map = new WeakHashMap<>();
+        map = new WeakHashMap<Object, ConnectionsRef>();
         this.prefSize = prefSize;
         this.maxSize = maxSize;
         this.initSize = initSize;
@@ -165,10 +165,10 @@
     public void expire(long threshold) {
         Collection<ConnectionsRef> copy;
         synchronized (map) {
-            copy = new ArrayList<>(map.values());
+            copy = new ArrayList<ConnectionsRef>(map.values());
         }
 
-        ArrayList<ConnectionsRef> removed = new ArrayList<>();
+        ArrayList<ConnectionsRef> removed = new ArrayList<ConnectionsRef>();
         Connections conns;
         for (ConnectionsRef ref : copy) {
             conns = ref.getConnections();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/sasl/LdapSasl.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/sasl/LdapSasl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/ldap/sasl/LdapSasl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/ldap/sasl/LdapSasl.java	2018-05-20 04:52:08.147913507 +0100
@@ -186,7 +186,7 @@
       */
     private static String[] getSaslMechanismNames(String str) {
         StringTokenizer parser = new StringTokenizer(str);
-        Vector<String> mechs = new Vector<>(10);
+        Vector<String> mechs = new Vector<String>(10);
         while (parser.hasMoreTokens()) {
             mechs.addElement(parser.nextToken());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/toolkit/ctx/Continuation.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/toolkit/ctx/Continuation.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/toolkit/ctx/Continuation.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/toolkit/ctx/Continuation.java	2018-05-20 04:52:08.147913507 +0100
@@ -155,7 +155,8 @@
         if ((e instanceof CannotProceedException)) {
             CannotProceedException cpe = (CannotProceedException)e;
             Hashtable<?,?> env = (environment == null ?
-                new Hashtable<>(11) : (Hashtable<?,?>)environment.clone());
+				  new Hashtable<Object, Object>(11) :
+				  (Hashtable<?,?>)environment.clone());
             cpe.setEnvironment(env);
             cpe.setAltNameCtx(resolvedContext);
             cpe.setAltName(relativeResolvedName);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/toolkit/dir/HierMemDirCtx.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/toolkit/dir/HierMemDirCtx.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/toolkit/dir/HierMemDirCtx.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/toolkit/dir/HierMemDirCtx.java	2018-05-20 04:52:08.151913444 +0100
@@ -84,7 +84,7 @@
 
     private void init() {
         attrs = new BasicAttributes(ignoreCase);
-        bindings = new Hashtable<>(11, 0.75f);
+        bindings = new Hashtable<Name, Object>(11, 0.75f);
     }
 
     public Object lookup(String name) throws NamingException {
@@ -470,7 +470,7 @@
     @SuppressWarnings("unchecked") // clone()
     public Hashtable<String, Object> getEnvironment() throws NamingException {
         if (myEnv == null) {
-            return new Hashtable<>(5, 0.75f);
+            return new Hashtable<String, Object>(5, 0.75f);
         } else {
             return (Hashtable<String, Object>)myEnv.clone();
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/toolkit/dir/SearchFilter.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/toolkit/dir/SearchFilter.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/toolkit/dir/SearchFilter.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/toolkit/dir/SearchFilter.java	2018-05-20 04:52:08.151913444 +0100
@@ -208,7 +208,7 @@
         private boolean polarity;
 
         CompoundFilter(boolean polarity) {
-            subFilters = new Vector<>();
+            subFilters = new Vector<StringFilter>();
             this.polarity = polarity;
         }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/toolkit/url/GenericURLContext.java openjdk-boot/jdk/src/share/classes/com/sun/jndi/toolkit/url/GenericURLContext.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/jndi/toolkit/url/GenericURLContext.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/jndi/toolkit/url/GenericURLContext.java	2018-05-20 04:52:08.151913444 +0100
@@ -510,7 +510,7 @@
     @SuppressWarnings("unchecked") // clone()
     public Hashtable<String, Object> getEnvironment() throws NamingException {
         if (myEnv == null) {
-            return new Hashtable<>(5, 0.75f);
+            return new Hashtable<String, Object>(5, 0.75f);
         } else {
             return (Hashtable<String, Object>)myEnv.clone();
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/media/sound/AbstractLine.java openjdk-boot/jdk/src/share/classes/com/sun/media/sound/AbstractLine.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/media/sound/AbstractLine.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/media/sound/AbstractLine.java	2018-05-20 04:52:08.151913444 +0100
@@ -54,7 +54,7 @@
      * Contains event dispatcher per thread group.
      */
     private static final Map<ThreadGroup, EventDispatcher> dispatchers =
-            new WeakHashMap<>();
+      new WeakHashMap<ThreadGroup, EventDispatcher>();
 
     /**
      * Constructs a new AbstractLine.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/media/sound/JDK13Services.java openjdk-boot/jdk/src/share/classes/com/sun/media/sound/JDK13Services.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/media/sound/JDK13Services.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/media/sound/JDK13Services.java	2018-05-20 04:52:08.151913444 +0100
@@ -102,7 +102,7 @@
                 && !SoundbankReader.class.equals(serviceClass)
                 && !MidiFileWriter.class.equals(serviceClass)
                 && !MidiFileReader.class.equals(serviceClass)) {
-            providers = new ArrayList<>(0);
+            providers = new ArrayList<Object>(0);
         } else {
             providers = JSSecurityManager.getProviders(serviceClass);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/media/sound/RealTimeSequencer.java openjdk-boot/jdk/src/share/classes/com/sun/media/sound/RealTimeSequencer.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/media/sound/RealTimeSequencer.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/media/sound/RealTimeSequencer.java	2018-05-20 04:52:08.151913444 +0100
@@ -59,7 +59,7 @@
      * dispatcher instance with a factory in EventDispatcher
      */
     private static final Map<ThreadGroup, EventDispatcher> dispatchers =
-            new WeakHashMap<>();
+      new WeakHashMap<ThreadGroup, EventDispatcher>();
 
     /**
      * All RealTimeSequencers share this info object.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/naming/internal/FactoryEnumeration.java openjdk-boot/jdk/src/share/classes/com/sun/naming/internal/FactoryEnumeration.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/naming/internal/FactoryEnumeration.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/naming/internal/FactoryEnumeration.java	2018-05-20 04:52:08.151913444 +0100
@@ -87,7 +87,7 @@
                 }
                 // Instantiate Class to get factory
                 answer = ((Class) answer).newInstance();
-                ref = new NamedWeakReference<>(answer, className);
+                ref = new NamedWeakReference<Object>(answer, className);
                 factories.set(posn-1, ref);  // replace Class object or null
                 return answer;
             } catch (ClassNotFoundException e) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/naming/internal/ResourceManager.java openjdk-boot/jdk/src/share/classes/com/sun/naming/internal/ResourceManager.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/naming/internal/ResourceManager.java	2018-05-20 04:38:34.888800572 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/naming/internal/ResourceManager.java	2018-05-20 04:52:08.151913444 +0100
@@ -97,7 +97,7 @@
      */
     // WeakHashMap<Class | ClassLoader, Hashtable>
     private static final WeakHashMap<Object, Hashtable<? super String, Object>>
-            propertiesCache = new WeakHashMap<>(11);
+	propertiesCache = new WeakHashMap<Object, Hashtable<? super String, Object>>(11);
 
     /*
      * A cache of factory objects (ObjectFactory, StateFactory, ControlFactory).
@@ -109,7 +109,7 @@
      */
     private static final
         WeakHashMap<ClassLoader, Map<String, List<NamedWeakReference<Object>>>>
-            factoryCache = new WeakHashMap<>(11);
+	factoryCache = new WeakHashMap<ClassLoader, Map<String, List<NamedWeakReference<Object>>>>(11);
 
     /*
      * A cache of URL factory objects (ObjectFactory).
@@ -122,9 +122,9 @@
      */
     private static final
         WeakHashMap<ClassLoader, Map<String, WeakReference<Object>>>
-            urlFactoryCache = new WeakHashMap<>(11);
+	urlFactoryCache = new WeakHashMap<ClassLoader, Map<String, WeakReference<Object>>>(11);
     private static final WeakReference<Object> NO_FACTORY =
-            new WeakReference<>(null);
+            new WeakReference<Object>(null);
 
     /**
      * A class to allow JNDI properties be specified as applet parameters
@@ -203,7 +203,7 @@
     {
         String[] props = VersionHelper.PROPS;   // system/applet properties
         if (env == null) {
-            env = new Hashtable<>(11);
+            env = new Hashtable<Object, Object>(11);
         }
         Object applet = env.get(Context.APPLET);
 
@@ -341,7 +341,7 @@
         synchronized (factoryCache) {
             perLoaderCache = factoryCache.get(loader);
             if (perLoaderCache == null) {
-                perLoaderCache = new HashMap<>(11);
+                perLoaderCache = new HashMap<String, List<NamedWeakReference<Object>>>(11);
                 factoryCache.put(loader, perLoaderCache);
             }
         }
@@ -357,7 +357,7 @@
                 // Populate list with classes named in facProp; skipping
                 // those that we cannot load
                 StringTokenizer parser = new StringTokenizer(facProp, ":");
-                factories = new ArrayList<>(5);
+                factories = new ArrayList<NamedWeakReference<Object>>(5);
                 while (parser.hasMoreTokens()) {
                     try {
                         // System.out.println("loading");
@@ -431,7 +431,7 @@
         synchronized (urlFactoryCache) {
             perLoaderCache = urlFactoryCache.get(loader);
             if (perLoaderCache == null) {
-                perLoaderCache = new HashMap<>(11);
+                perLoaderCache = new HashMap<String, WeakReference<Object>>(11);
                 urlFactoryCache.put(loader, perLoaderCache);
             }
         }
@@ -475,7 +475,7 @@
 
             // Cache it.
             perLoaderCache.put(key, (factory != null)
-                                        ? new WeakReference<>(factory)
+                                        ? new WeakReference<Object>(factory)
                                         : NO_FACTORY);
             return factory;
         }
@@ -497,7 +497,7 @@
             throws NamingException
     {
         if (obj == null) {
-            return (new Hashtable<>(1));
+            return (new Hashtable<String, Object>(1));
         }
         synchronized (propertiesCache) {
             Class<?> c = obj.getClass();
@@ -606,7 +606,7 @@
                 throw ne;
             }
             if (result == null) {
-                result = new Hashtable<>(11);
+                result = new Hashtable<String, Object>(11);
             }
             propertiesCache.put(cl, result);
             return result;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/naming/internal/VersionHelper.java openjdk-boot/jdk/src/share/classes/com/sun/naming/internal/VersionHelper.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/naming/internal/VersionHelper.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/naming/internal/VersionHelper.java	2018-05-20 04:52:08.151913444 +0100
@@ -137,7 +137,7 @@
         throws MalformedURLException {
         // Parse codebase into separate URLs
         StringTokenizer parser = new StringTokenizer(codebase);
-        Vector<String> vec = new Vector<>(10);
+        Vector<String> vec = new Vector<String>(10);
         while (parser.hasMoreTokens()) {
             vec.addElement(parser.nextToken());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/rmi/rmid/ExecOptionPermission.java openjdk-boot/jdk/src/share/classes/com/sun/rmi/rmid/ExecOptionPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/rmi/rmid/ExecOptionPermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/rmi/rmid/ExecOptionPermission.java	2018-05-20 04:52:08.151913444 +0100
@@ -231,7 +231,7 @@
          * Create an empty ExecOptionPermissionCollection.
          */
         public ExecOptionPermissionCollection() {
-            permissions = new Hashtable<>(11);
+            permissions = new Hashtable<String, Permission>(11);
             all_allowed = false;
         }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/rmi/rmid/ExecPermission.java openjdk-boot/jdk/src/share/classes/com/sun/rmi/rmid/ExecPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/rmi/rmid/ExecPermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/rmi/rmid/ExecPermission.java	2018-05-20 04:52:08.151913444 +0100
@@ -235,7 +235,7 @@
          * Create an empty ExecPermissionCollection.
          */
         public ExecPermissionCollection() {
-            permissions = new Vector<>();
+            permissions = new Vector<Permission>();
         }
 
         /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java openjdk-boot/jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java	2018-05-20 04:52:08.151913444 +0100
@@ -1285,7 +1285,7 @@
      */
     public Collection<?> toCollection() throws SQLException {
 
-        TreeMap<Integer, Object> tMap = new TreeMap<>();
+        TreeMap<Integer, Object> tMap = new TreeMap<Integer, Object>();
 
         for (int i = 0; i<numRows; i++) {
             tMap.put(Integer.valueOf(i), rvh.get(i));
@@ -1315,7 +1315,7 @@
     public Collection<?> toCollection(int column) throws SQLException {
 
         int nRows = numRows;
-        Vector<Object> vec = new Vector<>(nRows);
+        Vector<Object> vec = new Vector<Object>(nRows);
 
         // create a copy
         CachedRowSetImpl crsTemp;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/rowset/JoinRowSetImpl.java openjdk-boot/jdk/src/share/classes/com/sun/rowset/JoinRowSetImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/rowset/JoinRowSetImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/rowset/JoinRowSetImpl.java	2018-05-20 04:52:08.155913381 +0100
@@ -222,7 +222,7 @@
            // either of the setter methods have been set.
            if(boolColId){
               //
-              ArrayList<Integer> indices = new ArrayList<>();
+              ArrayList<Integer> indices = new ArrayList<Integer>();
               for(int i=0;i<cRowset.getMatchColumnNames().length;i++) {
                   if( (strMatchKey = (cRowset.getMatchColumnNames())[i]) != null) {
                       iMatchKey = cRowset.findColumn(strMatchKey);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/callback/DialogCallbackHandler.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/callback/DialogCallbackHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/callback/DialogCallbackHandler.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/callback/DialogCallbackHandler.java	2018-05-20 04:52:08.155913381 +0100
@@ -99,10 +99,10 @@
         throws UnsupportedCallbackException
     {
         /* Collect messages to display in the dialog */
-        final List<Object> messages = new ArrayList<>(3);
+        final List<Object> messages = new ArrayList<Object>(3);
 
         /* Collection actions to perform if the user clicks OK */
-        final List<Action> okActions = new ArrayList<>(2);
+        final List<Action> okActions = new ArrayList<Action>(2);
 
         ConfirmationInfo confirmation = new ConfirmationInfo();
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/login/ConfigFile.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/login/ConfigFile.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/login/ConfigFile.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/login/ConfigFile.java	2018-05-20 04:52:08.155913381 +0100
@@ -152,7 +152,7 @@
 
         // new configuration
         HashMap<String, LinkedList<AppConfigurationEntry>> newConfig =
-                new HashMap<>();
+            new HashMap<String, LinkedList<AppConfigurationEntry>>();
 
         if (url != null) {
 
@@ -392,7 +392,7 @@
         String moduleClass;
         String sflag;
         AppConfigurationEntry.LoginModuleControlFlag controlFlag;
-        LinkedList<AppConfigurationEntry> configEntries = new LinkedList<>();
+        LinkedList<AppConfigurationEntry> configEntries = new LinkedList<AppConfigurationEntry>();
 
         // application name
         appName = st.sval;
@@ -432,7 +432,7 @@
             }
 
             // get the args
-            HashMap<String, String> options = new HashMap<>();
+            HashMap<String, String> options = new HashMap<String, String>();
             String key;
             String value;
             while (peek(";") == false) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/JndiLoginModule.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/JndiLoginModule.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/JndiLoginModule.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/JndiLoginModule.java	2018-05-20 04:52:08.155913381 +0100
@@ -181,7 +181,7 @@
     private UnixNumericUserPrincipal UIDPrincipal;
     private UnixNumericGroupPrincipal GIDPrincipal;
     private LinkedList<UnixNumericGroupPrincipal> supplementaryGroups =
-                                new LinkedList<>();
+                                new LinkedList<UnixNumericGroupPrincipal>();
 
     // initial state
     private Subject subject;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/KeyStoreLoginModule.java	2018-05-20 04:52:08.155913381 +0100
@@ -654,7 +654,7 @@
                 throw new FailedLoginException(
                     "Unable to find X.509 certificate chain in keystore");
             } else {
-                LinkedList<Certificate> certList = new LinkedList<>();
+                LinkedList<Certificate> certList = new LinkedList<Certificate>();
                 for (int i=0; i < fromKeyStore.length; i++) {
                     certList.add(fromKeyStore[i]);
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/SolarisLoginModule.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/SolarisLoginModule.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/SolarisLoginModule.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/SolarisLoginModule.java	2018-05-20 04:52:08.155913381 +0100
@@ -76,7 +76,7 @@
     private SolarisNumericUserPrincipal UIDPrincipal;
     private SolarisNumericGroupPrincipal GIDPrincipal;
     private LinkedList<SolarisNumericGroupPrincipal> supplementaryGroups =
-                new LinkedList<>();
+                new LinkedList<SolarisNumericGroupPrincipal>();
 
     /**
      * Initialize this <code>LoginModule</code>.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/UnixLoginModule.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/UnixLoginModule.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/module/UnixLoginModule.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/module/UnixLoginModule.java	2018-05-20 04:52:08.155913381 +0100
@@ -70,7 +70,7 @@
     private UnixNumericUserPrincipal UIDPrincipal;
     private UnixNumericGroupPrincipal GIDPrincipal;
     private LinkedList<UnixNumericGroupPrincipal> supplementaryGroups =
-                new LinkedList<>();
+                new LinkedList<UnixNumericGroupPrincipal>();
 
     /**
      * Initialize this <code>LoginModule</code>.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/PolicyFile.java openjdk-boot/jdk/src/share/classes/com/sun/security/auth/PolicyFile.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/security/auth/PolicyFile.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/security/auth/PolicyFile.java	2018-05-20 04:52:08.155913381 +0100
@@ -1179,7 +1179,7 @@
             // Done
             return certs;
 
-        ArrayList<Certificate> userCertList = new ArrayList<>();
+        ArrayList<Certificate> userCertList = new ArrayList<Certificate>();
         i = 0;
         while (i < certs.length) {
             userCertList.add(certs[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/com/sun/tools/example/trace/EventThread.java openjdk-boot/jdk/src/share/classes/com/sun/tools/example/trace/EventThread.java
--- openjdk-boot.orig/jdk/src/share/classes/com/sun/tools/example/trace/EventThread.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/com/sun/tools/example/trace/EventThread.java	2018-05-20 04:52:08.155913381 +0100
@@ -59,7 +59,7 @@
 
     // Maps ThreadReference to ThreadTrace instances
     private Map<ThreadReference, ThreadTrace> traceMap =
-       new HashMap<>();
+       new HashMap();
 
     EventThread(VirtualMachine vm, String[] excludes, PrintWriter writer) {
         super("event-handler");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/awt/Cursor.java openjdk-boot/jdk/src/share/classes/java/awt/Cursor.java
--- openjdk-boot.orig/jdk/src/share/classes/java/awt/Cursor.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/awt/Cursor.java	2018-05-20 04:52:08.155913381 +0100
@@ -163,7 +163,7 @@
      * hashtable, filesystem dir prefix, filename, and properties for custom cursors support
      */
 
-    private static final Hashtable<String,Cursor> systemCustomCursors = new Hashtable<>(1);
+    private static final Hashtable<String,Cursor> systemCustomCursors = new Hashtable<String,Cursor>(1);
     private static final String systemCustomCursorDirPrefix = initCursorDir();
 
     private static String initCursorDir() {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/awt/datatransfer/Clipboard.java openjdk-boot/jdk/src/share/classes/java/awt/datatransfer/Clipboard.java
--- openjdk-boot.orig/jdk/src/share/classes/java/awt/datatransfer/Clipboard.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/awt/datatransfer/Clipboard.java	2018-05-20 04:52:08.155913381 +0100
@@ -341,7 +341,7 @@
      * @since 1.5
      */
     private Set<DataFlavor> getAvailableDataFlavorSet() {
-        Set<DataFlavor> set = new HashSet<>();
+        Set<DataFlavor> set = new HashSet<DataFlavor>();
         Transferable contents = getContents(null);
         if (contents != null) {
             DataFlavor[] flavors = contents.getTransferDataFlavors();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/awt/EventQueue.java openjdk-boot/jdk/src/share/classes/java/awt/EventQueue.java
--- openjdk-boot.orig/jdk/src/share/classes/java/awt/EventQueue.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/awt/EventQueue.java	2018-05-20 04:52:08.155913381 +0100
@@ -1183,7 +1183,7 @@
                 return;
             }
 
-            currentEvent = new WeakReference<>(e);
+            currentEvent = new WeakReference<AWTEvent>(e);
 
             // This series of 'instanceof' checks should be replaced with a
             // polymorphic type (for example, an interface which declares a
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/awt/MenuBar.java openjdk-boot/jdk/src/share/classes/java/awt/MenuBar.java
--- openjdk-boot.orig/jdk/src/share/classes/java/awt/MenuBar.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/awt/MenuBar.java	2018-05-20 04:52:08.155913381 +0100
@@ -94,7 +94,7 @@
      * @serial
      * @see #countMenus()
      */
-    Vector<Menu> menus = new Vector<>();
+    Vector<Menu> menus = new Vector<Menu>();
 
     /**
      * This menu is a special menu dedicated to
@@ -327,7 +327,7 @@
      * @since       JDK1.1
      */
     public synchronized Enumeration<MenuShortcut> shortcuts() {
-        Vector<MenuShortcut> shortcuts = new Vector<>();
+        Vector<MenuShortcut> shortcuts = new Vector<MenuShortcut>();
         int nmenus = getMenuCount();
         for (int i = 0 ; i < nmenus ; i++) {
             Enumeration<MenuShortcut> e = getMenu(i).shortcuts();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/awt/Menu.java openjdk-boot/jdk/src/share/classes/java/awt/Menu.java
--- openjdk-boot.orig/jdk/src/share/classes/java/awt/Menu.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/awt/Menu.java	2018-05-20 04:52:08.155913381 +0100
@@ -78,7 +78,7 @@
      * @serial
      * @see #countItems()
      */
-    Vector<MenuComponent> items = new Vector<>();
+    Vector<MenuComponent> items = new Vector<MenuComponent>();
 
     /**
      * This field indicates whether the menu has the
@@ -313,7 +313,7 @@
             }
 
             int nitems = getItemCount();
-            Vector<MenuItem> tempItems = new Vector<>();
+            Vector<MenuItem> tempItems = new Vector<MenuItem>();
 
             /* Remove the item at index, nitems-index times
                storing them in a temporary vector in the
@@ -379,7 +379,7 @@
             }
 
             int nitems = getItemCount();
-            Vector<MenuItem> tempItems = new Vector<>();
+            Vector<MenuItem> tempItems = new Vector<MenuItem>();
 
             /* Remove the item at index, nitems-index times
                storing them in a temporary vector in the
@@ -476,7 +476,7 @@
     }
 
     synchronized Enumeration<MenuShortcut> shortcuts() {
-        Vector<MenuShortcut> shortcuts = new Vector<>();
+        Vector<MenuShortcut> shortcuts = new Vector<MenuShortcut>();
         int nitems = getItemCount();
         for (int i = 0 ; i < nitems ; i++) {
             MenuItem mi = getItem(i);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/awt/RenderingHints.java openjdk-boot/jdk/src/share/classes/java/awt/RenderingHints.java
--- openjdk-boot.orig/jdk/src/share/classes/java/awt/RenderingHints.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/awt/RenderingHints.java	2018-05-20 04:52:08.155913381 +0100
@@ -92,7 +92,7 @@
      * {@code equals()} method.
      */
     public abstract static class Key {
-        private static HashMap<Object,Object> identitymap = new HashMap<>(17);
+        private static HashMap<Object,Object> identitymap = new HashMap<Object,Object>(17);
 
         private String getIdentity() {
             // Note that the identity string is dependent on 3 variables:
@@ -195,7 +195,7 @@
         }
     }
 
-    HashMap<Object,Object> hintmap = new HashMap<>(7);
+    HashMap<Object,Object> hintmap = new HashMap<Object,Object>(7);
 
     /**
      * Antialiasing hint key.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/beans/Introspector.java openjdk-boot/jdk/src/share/classes/java/beans/Introspector.java
--- openjdk-boot.orig/jdk/src/share/classes/java/beans/Introspector.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/beans/Introspector.java	2018-05-20 04:52:08.155913381 +0100
@@ -106,7 +106,7 @@
     public final static int IGNORE_ALL_BEANINFO        = 3;
 
     // Static Caches to speed up introspection.
-    private static final WeakCache<Class<?>, Method[]> declaredMethodCache = new WeakCache<>();
+    private static final WeakCache<Class<?>, Method[]> declaredMethodCache = new WeakCache();
 
     private Class beanClass;
     private BeanInfo explicitBeanInfo;
@@ -1481,7 +1481,7 @@
         this.defaultProperty = defaultProperty;
         this.methods = methods;
         this.targetBeanInfoRef = (targetBeanInfo != null)
-                ? new SoftReference<>(targetBeanInfo)
+                ? new SoftReference<BeanInfo>(targetBeanInfo)
                 : null;
     }
 
@@ -1565,7 +1565,7 @@
             targetBeanInfo = ThreadGroupContext.getContext().getBeanInfoFinder()
                     .find(this.beanDescriptor.getBeanClass());
             if (targetBeanInfo != null) {
-                this.targetBeanInfoRef = new SoftReference<>(targetBeanInfo);
+                this.targetBeanInfoRef = new SoftReference<BeanInfo>(targetBeanInfo);
             }
         }
         return targetBeanInfo;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/beans/MethodRef.java openjdk-boot/jdk/src/share/classes/java/beans/MethodRef.java
--- openjdk-boot.orig/jdk/src/share/classes/java/beans/MethodRef.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/beans/MethodRef.java	2018-05-20 04:52:08.155913381 +0100
@@ -44,7 +44,7 @@
         }
         else {
             this.signature = method.toGenericString();
-            this.methodRef = new SoftReference<>(method);
+            this.methodRef = new SoftReference<Method>(method);
             this.typeRef = new WeakReference<Class<?>>(method.getDeclaringClass());
         }
     }
@@ -66,7 +66,7 @@
                 this.typeRef = null;
             }
             else {
-                this.methodRef = new SoftReference<>(method);
+                this.methodRef = new SoftReference<Method>(method);
             }
         }
         return isPackageAccessible(method.getDeclaringClass()) ? method : null;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/beans/ThreadGroupContext.java openjdk-boot/jdk/src/share/classes/java/beans/ThreadGroupContext.java
--- openjdk-boot.orig/jdk/src/share/classes/java/beans/ThreadGroupContext.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/beans/ThreadGroupContext.java	2018-05-20 04:52:08.155913381 +0100
@@ -96,7 +96,7 @@
 
     BeanInfo putBeanInfo(Class<?> type, BeanInfo info) {
         if (this.beanInfoCache == null) {
-            this.beanInfoCache = new WeakHashMap<>();
+            this.beanInfoCache = new WeakHashMap();
         }
         return this.beanInfoCache.put(type, info);
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/DeleteOnExitHook.java openjdk-boot/jdk/src/share/classes/java/io/DeleteOnExitHook.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/DeleteOnExitHook.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/DeleteOnExitHook.java	2018-05-20 04:52:08.155913381 +0100
@@ -34,7 +34,7 @@
  */
 
 class DeleteOnExitHook {
-    private static LinkedHashSet<String> files = new LinkedHashSet<>();
+    private static LinkedHashSet<String> files = new LinkedHashSet<String>();
     static {
         // DeleteOnExitHook must be the last shutdown hook to be invoked.
         // Application shutdown hooks may add the first file to the
@@ -71,7 +71,7 @@
             files = null;
         }
 
-        ArrayList<String> toBeDeleted = new ArrayList<>(theFiles);
+        ArrayList<String> toBeDeleted = new ArrayList<String>(theFiles);
 
         // reverse the list to maintain previous jdk deletion order.
         // Last in first deleted.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/FileInputStream.java openjdk-boot/jdk/src/share/classes/java/io/FileInputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/FileInputStream.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/FileInputStream.java	2018-05-20 04:52:08.155913381 +0100
@@ -61,7 +61,7 @@
     private volatile boolean closed = false;
 
     private static final ThreadLocal<Boolean> runningFinalize =
-        new ThreadLocal<>();
+        new ThreadLocal<Boolean>();
 
     private static boolean isRunningFinalize() {
         Boolean val;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/File.java openjdk-boot/jdk/src/share/classes/java/io/File.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/File.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/File.java	2018-05-20 04:52:08.155913381 +0100
@@ -1150,7 +1150,7 @@
         if ((names == null) || (filter == null)) {
             return names;
         }
-        List<String> v = new ArrayList<>();
+        List<String> v = new ArrayList<String>();
         for (int i = 0 ; i < names.length ; i++) {
             if (filter.accept(this, names[i])) {
                 v.add(names[i]);
@@ -1241,7 +1241,7 @@
     public File[] listFiles(FilenameFilter filter) {
         String ss[] = list();
         if (ss == null) return null;
-        ArrayList<File> files = new ArrayList<>();
+        ArrayList<File> files = new ArrayList<File>();
         for (String s : ss)
             if ((filter == null) || filter.accept(this, s))
                 files.add(new File(s, this));
@@ -1279,7 +1279,7 @@
     public File[] listFiles(FileFilter filter) {
         String ss[] = list();
         if (ss == null) return null;
-        ArrayList<File> files = new ArrayList<>();
+        ArrayList<File> files = new ArrayList<File>();
         for (String s : ss) {
             File f = new File(s, this);
             if ((filter == null) || filter.accept(f))
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/FileOutputStream.java openjdk-boot/jdk/src/share/classes/java/io/FileOutputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/FileOutputStream.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/FileOutputStream.java	2018-05-20 04:52:08.159913318 +0100
@@ -76,7 +76,7 @@
     private final Object closeLock = new Object();
     private volatile boolean closed = false;
     private static final ThreadLocal<Boolean> runningFinalize =
-        new ThreadLocal<>();
+        new ThreadLocal<Boolean>();
 
     private static boolean isRunningFinalize() {
         Boolean val;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/FilePermission.java openjdk-boot/jdk/src/share/classes/java/io/FilePermission.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/FilePermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/FilePermission.java	2018-05-20 04:54:11.085965683 +0100
@@ -725,7 +725,7 @@
      */
 
     public FilePermissionCollection() {
-        perms = new ArrayList<>();
+        perms = new ArrayList<Permission>();
     }
 
     /**
@@ -830,7 +830,7 @@
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
-        Vector<Permission> permissions = new Vector<>(perms.size());
+        Vector<Permission> permissions = new Vector<Permission>(perms.size());
         synchronized (this) {
             permissions.addAll(perms);
         }
@@ -853,7 +853,7 @@
 
         // Get the one we want
         Vector<Permission> permissions = (Vector<Permission>)gfields.get("permissions", null);
-        perms = new ArrayList<>(permissions.size());
+        perms = new ArrayList<Permission>(permissions.size());
         for (Permission perm : permissions) {
             perms.add(perm);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectInputStream.java openjdk-boot/jdk/src/share/classes/java/io/ObjectInputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectInputStream.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/ObjectInputStream.java	2018-05-20 04:52:08.159913318 +0100
@@ -220,7 +220,7 @@
 
     /** table mapping primitive type names to corresponding class objects */
     private static final HashMap<String, Class<?>> primClasses
-        = new HashMap<>(8, 1.0F);
+        = new HashMap<String, Class<?>>(8, 1.0F);
     static {
         primClasses.put("boolean", boolean.class);
         primClasses.put("byte", byte.class);
@@ -236,11 +236,11 @@
     private static class Caches {
         /** cache of subclass security audit results */
         static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<WeakClassKey,Boolean>();
 
         /** queue for WeakReferences to audited subclasses */
         static final ReferenceQueue<Class<?>> subclassAuditsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
     }
 
     static {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectOutputStream.java openjdk-boot/jdk/src/share/classes/java/io/ObjectOutputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectOutputStream.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/ObjectOutputStream.java	2018-05-20 04:52:08.159913318 +0100
@@ -166,11 +166,11 @@
     private static class Caches {
         /** cache of subclass security audit results */
         static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<WeakClassKey,Boolean>();
 
         /** queue for WeakReferences to audited subclasses */
         static final ReferenceQueue<Class<?>> subclassAuditsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
     }
 
     /** filter stream for handling block data conversion */
@@ -2432,7 +2432,7 @@
         private final List<String> stack;
 
         DebugTraceInfoStack() {
-            stack = new ArrayList<>();
+            stack = new ArrayList<String>();
         }
 
         /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectStreamClass.java openjdk-boot/jdk/src/share/classes/java/io/ObjectStreamClass.java
--- openjdk-boot.orig/jdk/src/share/classes/java/io/ObjectStreamClass.java	2018-05-20 04:38:34.888800572 +0100
+++ openjdk-boot/jdk/src/share/classes/java/io/ObjectStreamClass.java	2018-05-20 04:52:08.159913318 +0100
@@ -94,18 +94,18 @@
     private static class Caches {
         /** cache mapping local classes -> descriptors */
         static final ConcurrentMap<WeakClassKey,Reference<?>> localDescs =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<WeakClassKey,Reference<?>>();
 
         /** cache mapping field group/local desc pairs -> field reflectors */
         static final ConcurrentMap<FieldReflectorKey,Reference<?>> reflectors =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<FieldReflectorKey,Reference<?>>();
 
         /** queue for WeakReferences to local classes */
         private static final ReferenceQueue<Class<?>> localDescsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
         /** queue for WeakReferences to field reflectors keys */
         private static final ReferenceQueue<Class<?>> reflectorsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
     }
 
     /** class associated with this descriptor (if any) */
@@ -342,7 +342,7 @@
         EntryFuture future = null;
         if (entry == null) {
             EntryFuture newEntry = new EntryFuture();
-            Reference<?> newRef = new SoftReference<>(newEntry);
+            Reference<?> newRef = new SoftReference<EntryFuture>(newEntry);
             do {
                 if (ref != null) {
                     Caches.localDescs.remove(key, ref);
@@ -596,7 +596,7 @@
             while (cls != fnscl) {
                 ProtectionDomain pd = cls.getProtectionDomain();
                 if (pd != null) {
-                    if (pds == null) pds = new HashSet<>();
+                    if (pds == null) pds = new HashSet<ProtectionDomain>();
                     pds.add(pd);
                 }
                 cls = cls.getSuperclass();
@@ -604,7 +604,7 @@
                     // that's not supposed to happen
                     // make a ProtectionDomain with no permission.
                     // should we throw instead?
-                    if (pds == null) pds = new HashSet<>();
+                    if (pds == null) pds = new HashSet<ProtectionDomain>();
                     else pds.clear();
                     pds.add(noPermissionsDomain());
                     break;
@@ -1305,7 +1305,7 @@
     private ClassDataSlot[] getClassDataLayout0()
         throws InvalidClassException
     {
-        ArrayList<ClassDataSlot> slots = new ArrayList<>();
+        ArrayList<ClassDataSlot> slots = new ArrayList<ClassDataSlot>();
         Class<?> start = cl, end = cl;
 
         // locate closest non-serializable superclass
@@ -1313,7 +1313,7 @@
             end = end.getSuperclass();
         }
 
-        HashSet<String> oscNames = new HashSet<>(3);
+        HashSet<String> oscNames = new HashSet<String>(3);
 
         for (ObjectStreamClass d = this; d != null; d = d.superDesc) {
             if (oscNames.contains(d.name)) {
@@ -1748,7 +1748,7 @@
 
         ObjectStreamField[] boundFields =
             new ObjectStreamField[serialPersistentFields.length];
-        Set<String> fieldNames = new HashSet<>(serialPersistentFields.length);
+        Set<String> fieldNames = new HashSet<String>(serialPersistentFields.length);
 
         for (int i = 0; i < serialPersistentFields.length; i++) {
             ObjectStreamField spf = serialPersistentFields[i];
@@ -1786,7 +1786,7 @@
      */
     private static ObjectStreamField[] getDefaultSerialFields(Class<?> cl) {
         Field[] clFields = cl.getDeclaredFields();
-        ArrayList<ObjectStreamField> list = new ArrayList<>();
+        ArrayList<ObjectStreamField> list = new ArrayList<ObjectStreamField>();
         int mask = Modifier.STATIC | Modifier.TRANSIENT;
 
         for (int i = 0; i < clFields.length; i++) {
@@ -2037,8 +2037,8 @@
             writeKeys = new long[nfields];
             offsets = new int[nfields];
             typeCodes = new char[nfields];
-            ArrayList<Class<?>> typeList = new ArrayList<>();
-            Set<Long> usedKeys = new HashSet<>();
+            ArrayList<Class<?>> typeList = new ArrayList<Class<?>>();
+            Set<Long> usedKeys = new HashSet<Long>();
 
 
             for (int i = 0; i < nfields; i++) {
@@ -2274,7 +2274,7 @@
         EntryFuture future = null;
         if (entry == null) {
             EntryFuture newEntry = new EntryFuture();
-            Reference<?> newRef = new SoftReference<>(newEntry);
+            Reference<?> newRef = new SoftReference<EntryFuture>(newEntry);
             do {
                 if (ref != null) {
                     Caches.reflectors.remove(key, ref);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/ApplicationShutdownHooks.java openjdk-boot/jdk/src/share/classes/java/lang/ApplicationShutdownHooks.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/ApplicationShutdownHooks.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/ApplicationShutdownHooks.java	2018-05-20 04:52:08.159913318 +0100
@@ -47,7 +47,7 @@
                     }
                 }
             );
-            hooks = new IdentityHashMap<>();
+            hooks = new IdentityHashMap<Thread, Thread>();
         } catch (IllegalStateException e) {
             // application shutdown hooks cannot be added if
             // shutdown is in progress.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Character.java openjdk-boot/jdk/src/share/classes/java/lang/Character.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Character.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Character.java	2018-05-20 04:52:08.159913318 +0100
@@ -646,7 +646,8 @@
      */
     public static final class UnicodeBlock extends Subset {
 
-        private static Map<String, UnicodeBlock> map = new HashMap<>(256);
+        private static Map<String, UnicodeBlock> map
+            = new HashMap<String, UnicodeBlock>(256);
 
         /**
          * Creates a UnicodeBlock with the given identifier name.
@@ -4175,7 +4176,7 @@
 
         private static HashMap<String, Character.UnicodeScript> aliases;
         static {
-            aliases = new HashMap<>(128);
+            aliases = new HashMap<String, UnicodeScript>(128);
             aliases.put("ARAB", ARABIC);
             aliases.put("ARMI", IMPERIAL_ARAMAIC);
             aliases.put("ARMN", ARMENIAN);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/CharacterName.java openjdk-boot/jdk/src/share/classes/java/lang/CharacterName.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/CharacterName.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/CharacterName.java	2018-05-20 04:52:08.159913318 +0100
@@ -81,7 +81,7 @@
             } while (cpOff < cpEnd);
             strPool = new byte[total - cpEnd];
             dis.readFully(strPool);
-            refStrPool = new SoftReference<>(strPool);
+            refStrPool = new SoftReference<byte[]>(strPool);
         } catch (Exception x) {
             throw new InternalError(x.getMessage());
         } finally {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Class.java openjdk-boot/jdk/src/share/classes/java/lang/Class.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Class.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Class.java	2018-05-20 04:52:08.159913318 +0100
@@ -1359,7 +1359,7 @@
         return java.security.AccessController.doPrivileged(
             new java.security.PrivilegedAction<Class<?>[]>() {
                 public Class[] run() {
-                    List<Class<?>> list = new ArrayList<>();
+                    List<Class<?>> list = new ArrayList<Class<?>>();
                     Class<?> currentClass = Class.this;
                     while (currentClass != null) {
                         Class<?>[] members = currentClass.getDeclaredClasses();
@@ -2442,9 +2442,9 @@
         if (!useCaches) return null;
 
         while (true) {
-            ReflectionData<T> rd = new ReflectionData<>(classRedefinedCount);
+            ReflectionData<T> rd = new ReflectionData<T>(classRedefinedCount);
             // try to CAS it...
-            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference<>(rd))) {
+            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference<ReflectionData<T>>(rd))) {
                 return rd;
             }
             // else retry
@@ -2531,9 +2531,9 @@
 
         // No cached value available; compute value recursively.
         // Traverse in correct order for getField().
-        List<Field> fields = new ArrayList<>();
+        List<Field> fields = new ArrayList<Field>();
         if (traversedInterfaces == null) {
-            traversedInterfaces = new HashSet<>();
+            traversedInterfaces = new HashSet<Class<?>>();
         }
 
         // Local fields
@@ -3160,7 +3160,7 @@
             if (universe == null)
                 throw new IllegalArgumentException(
                     getName() + " is not an enum type");
-            Map<String, T> m = new HashMap<>(2 * universe.length);
+            Map<String, T> m = new HashMap<String, T>(2 * universe.length);
             for (T constant : universe)
                 m.put(((Enum<?>)constant).name(), constant);
             enumConstantDirectory = m;
@@ -3284,7 +3284,7 @@
         if (superClass == null) {
             annotations = declaredAnnotations;
         } else {
-            annotations = new HashMap<>();
+            annotations = new HashMap<Class<? extends Annotation>, Annotation>();
             superClass.initAnnotationsIfNecessary();
             for (Map.Entry<Class<? extends Annotation>, Annotation> e : superClass.annotations.entrySet()) {
                 Class<? extends Annotation> annotationClass = e.getKey();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/ClassLoader.java openjdk-boot/jdk/src/share/classes/java/lang/ClassLoader.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/ClassLoader.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/ClassLoader.java	2018-05-20 04:52:08.163913254 +0100
@@ -253,7 +253,7 @@
 
     // The classes loaded by this class loader. The only purpose of this table
     // is to keep the classes from being GC'ed until the loader is GC'ed.
-    private final Vector<Class<?>> classes = new Vector<>();
+    private final Vector<Class<?>> classes = new Vector<Class<?>>();
 
     // The "default" domain. Set as the default ProtectionDomain on newly
     // created classes.
@@ -272,7 +272,8 @@
     // The packages defined in this class loader.  Each package name is mapped
     // to its corresponding Package object.
     // @GuardedBy("itself")
-    private final HashMap<String, Package> packages = new HashMap<>();
+    private final HashMap<String, Package> packages =
+        new HashMap<String, Package>();
 
     private static Void checkCreateClassLoader() {
         SecurityManager security = System.getSecurityManager();
@@ -285,16 +286,16 @@
     private ClassLoader(Void unused, ClassLoader parent) {
         this.parent = parent;
         if (ParallelLoaders.isRegistered(this.getClass())) {
-            parallelLockMap = new ConcurrentHashMap<>();
-            package2certs = new ConcurrentHashMap<>();
+            parallelLockMap = new ConcurrentHashMap<String, Object>();
+            package2certs = new ConcurrentHashMap<String, Certificate[]>();
             domains =
                 Collections.synchronizedSet(new HashSet<ProtectionDomain>());
             assertionLock = new Object();
         } else {
             // no finer-grained lock; lock on the classloader instance
             parallelLockMap = null;
-            package2certs = new Hashtable<>();
-            domains = new HashSet<>();
+            package2certs = new Hashtable<String, Certificate[]>();
+            domains = new HashSet<ProtectionDomain>();
             assertionLock = this;
         }
     }
@@ -1192,7 +1193,7 @@
         }
         tmp[1] = findResources(name);
 
-        return new CompoundEnumeration<>(tmp);
+        return new CompoundEnumeration<URL>(tmp);
     }
 
     /**
@@ -1691,7 +1692,7 @@
     protected Package[] getPackages() {
         Map<String, Package> map;
         synchronized (packages) {
-            map = new HashMap<>(packages);
+            map = new HashMap<String, Package>(packages);
         }
         Package[] pkgs;
         if (parent != null) {
@@ -1798,17 +1799,20 @@
     }
 
     // All native library names we've loaded.
-    private static Vector<String> loadedLibraryNames = new Vector<>();
+    private static Vector<String> loadedLibraryNames
+        = new Vector<String>();
 
     // Native libraries belonging to system classes.
     private static Vector<NativeLibrary> systemNativeLibraries
-        = new Vector<>();
+        = new Vector<NativeLibrary>();
 
     // Native libraries associated with the class loader.
-    private Vector<NativeLibrary> nativeLibraries = new Vector<>();
+    private Vector<NativeLibrary> nativeLibraries
+        = new Vector<NativeLibrary>();
 
     // native libraries being loaded/unloaded.
-    private static Stack<NativeLibrary> nativeLibraryContext = new Stack<>();
+    private static Stack<NativeLibrary> nativeLibraryContext
+        = new Stack<NativeLibrary>();
 
     // The paths searched for libraries
     private static String usr_paths[];
@@ -2142,8 +2146,8 @@
          * them to empty maps, effectively ignoring any present settings.
          */
         synchronized (assertionLock) {
-            classAssertionStatus = new HashMap<>();
-            packageAssertionStatus = new HashMap<>();
+            classAssertionStatus = new HashMap<String, Boolean>();
+            packageAssertionStatus = new HashMap<String, Boolean>();
             defaultAssertionStatus = false;
         }
     }
@@ -2205,8 +2209,8 @@
     private void initializeJavaAssertionMaps() {
         // assert Thread.holdsLock(assertionLock);
 
-        classAssertionStatus = new HashMap<>();
-        packageAssertionStatus = new HashMap<>();
+        classAssertionStatus = new HashMap<String, Boolean>();
+        packageAssertionStatus = new HashMap<String, Boolean>();
         AssertionStatusDirectives directives = retrieveDirectives();
 
         for(int i = 0; i < directives.classes.length; i++)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/ClassValue.java openjdk-boot/jdk/src/share/classes/java/lang/ClassValue.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/ClassValue.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/ClassValue.java	2018-05-20 04:52:08.163913254 +0100
@@ -297,12 +297,12 @@
      * Some machines may also require a barrier instruction to execute
      * before this.version.
      */
-    private volatile Version<T> version = new Version<>(this);
+    private volatile Version<T> version = new Version<T>(this);
     Version<T> version() { return version; }
-    void bumpVersion() { version = new Version<>(this); }
+    void bumpVersion() { version = new Version<T>(this); }
     static class Version<T> {
         private final ClassValue<T> classValue;
-        private final Entry<T> promise = new Entry<>(this);
+        private final Entry<T> promise = new Entry<T>(this);
         Version(ClassValue<T> classValue) { this.classValue = classValue; }
         ClassValue<T> classValue() { return classValue; }
         Entry<T> promise() { return promise; }
@@ -351,12 +351,12 @@
         Entry<T> refreshVersion(Version<T> v2) {
             assertNotPromise();
             @SuppressWarnings("unchecked")  // if !isPromise, type is T
-            Entry<T> e2 = new Entry<>(v2, (T) value);
+            Entry<T> e2 = new Entry<T>(v2, (T) value);
             clear();
             // value = null -- caller must drop
             return e2;
         }
-        static final Entry<?> DEAD_ENTRY = new Entry<>(null, null);
+        static final Entry<?> DEAD_ENTRY = new Entry<Object>(null, null);
     }
 
     /** Return the backing map associated with this type. */
@@ -382,7 +382,7 @@
 
     static <T> Entry<T> makeEntry(Version<T> explicitVersion, T value) {
         // Note that explicitVersion might be different from this.version.
-        return new Entry<>(explicitVersion, value);
+        return new Entry<T>(explicitVersion, value);
 
         // As soon as the Entry is put into the cache, the value will be
         // reachable via a data race (as defined by the Java Memory Model).
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/BoundMethodHandle.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/BoundMethodHandle.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/BoundMethodHandle.java	2018-05-20 04:38:34.988798987 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/BoundMethodHandle.java	2018-05-20 04:52:08.163913254 +0100
@@ -393,7 +393,7 @@
         }
         private boolean isPlaceholder() { return clazz == null; }
 
-        private static final HashMap<String, SpeciesData> CACHE = new HashMap<>();
+        private static final HashMap<String, SpeciesData> CACHE = new HashMap<String, SpeciesData>();
         private static final boolean INIT_DONE;  // set after <clinit> finishes...
 
         SpeciesData extendWithType(char type) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/DirectMethodHandle.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/DirectMethodHandle.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/DirectMethodHandle.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/DirectMethodHandle.java	2018-05-20 04:52:08.163913254 +0100
@@ -290,7 +290,7 @@
             if (UNSAFE.shouldBeInitialized(type))
                 // If the previous call didn't block, this can happen.
                 // We are executing inside <clinit>.
-                return new WeakReference<>(Thread.currentThread());
+                return new WeakReference<Thread>(Thread.currentThread());
             return null;
         }
         static final EnsureInitialized INSTANCE = new EnsureInitialized();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java	2018-05-20 04:38:34.988798987 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java	2018-05-20 04:52:08.163913254 +0100
@@ -129,7 +129,7 @@
 
     static {
         if (DUMP_CLASS_FILES) {
-            DUMP_CLASS_FILES_COUNTERS = new HashMap<>();
+	    DUMP_CLASS_FILES_COUNTERS = new HashMap<String,Integer>();
             try {
                 File dumpDir = new File("DUMP_CLASS_FILES");
                 if (!dumpDir.exists()) {
@@ -198,7 +198,7 @@
         }
     }
 
-    Map<Object, CpPatch> cpPatches = new HashMap<>();
+    Map<Object, CpPatch> cpPatches = new HashMap<Object, CpPatch>();
 
     int cph = 0;  // for counting constant placeholders
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/LambdaForm.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/LambdaForm.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/LambdaForm.java	2018-05-20 04:38:34.988798987 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/LambdaForm.java	2018-05-20 04:52:08.163913254 +0100
@@ -468,12 +468,12 @@
         int   capacity   = 512;    // expect many distinct signatures over time
         float loadFactor = 0.75f;  // normal default
         int   writers    = 1;
-        PREPARED_FORMS = new ConcurrentHashMap<>(capacity, loadFactor, writers);
+        PREPARED_FORMS = new ConcurrentHashMap<String,LambdaForm>(capacity, loadFactor, writers);
     }
 
     private static Map<String,LambdaForm> computeInitialPreparedForms() {
         // Find all predefined invokers and associate them with canonical empty lambda forms.
-        HashMap<String,LambdaForm> forms = new HashMap<>();
+        HashMap<String,LambdaForm> forms = new HashMap<String,LambdaForm>();
         for (MemberName m : MemberName.getFactory().getMethods(LambdaForm.class, false, null, null, null)) {
             if (!m.isStatic() || !m.isPackage())  continue;
             MethodType mt = m.getMethodType();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MemberName.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/MemberName.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MemberName.java	2018-05-20 04:38:34.888800572 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/MemberName.java	2018-05-20 04:52:08.163913254 +0100
@@ -808,14 +808,14 @@
                 // JVM returned to us with an intentional overflow!
                 totalCount += buf.length;
                 int excess = bufCount - buf.length;
-                if (bufs == null)  bufs = new ArrayList<>(1);
+                if (bufs == null)  bufs = new ArrayList<MemberName[]>(1);
                 bufs.add(buf);
                 int len2 = buf.length;
                 len2 = Math.max(len2, excess);
                 len2 = Math.max(len2, totalCount / 4);
                 buf = newMemberBuffer(Math.min(BUF_MAX, len2));
             }
-            ArrayList<MemberName> result = new ArrayList<>(totalCount);
+            ArrayList<MemberName> result = new ArrayList<MemberName>(totalCount);
             if (bufs != null) {
                 for (MemberName[] buf0 : bufs) {
                     Collections.addAll(result, buf0);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java	2018-05-20 04:38:34.988798987 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java	2018-05-20 04:52:08.163913254 +0100
@@ -73,8 +73,8 @@
 
     static final class ArrayAccessor {
         /// Support for array element access
-        static final HashMap<Class<?>, MethodHandle> GETTER_CACHE = new HashMap<>();  // TODO use it
-        static final HashMap<Class<?>, MethodHandle> SETTER_CACHE = new HashMap<>();  // TODO use it
+        static final HashMap<Class<?>, MethodHandle> GETTER_CACHE = new HashMap<Class<?>, MethodHandle>();  // TODO use it
+        static final HashMap<Class<?>, MethodHandle> SETTER_CACHE = new HashMap<Class<?>, MethodHandle>();  // TODO use it
 
         static int     getElementI(int[]     a, int i)            { return              a[i]; }
         static long    getElementJ(long[]    a, int i)            { return              a[i]; }
@@ -686,7 +686,7 @@
             }
         }
         static MethodHandle[] makeInvokes() {
-            ArrayList<MethodHandle> invokes = new ArrayList<>();
+            ArrayList<MethodHandle> invokes = new ArrayList<MethodHandle>();
             MethodHandles.Lookup lookup = IMPL_LOOKUP;
             for (;;) {
                 int nargs = invokes.size();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MethodHandle.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/MethodHandle.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MethodHandle.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/MethodHandle.java	2018-05-20 04:52:08.163913254 +0100
@@ -834,7 +834,7 @@
                 }
             }
             if (sawProblem) {
-                ArrayList<Class<?>> ptypes = new ArrayList<>(type().parameterList());
+                ArrayList<Class<?>> ptypes = new ArrayList<Class<?>>(type().parameterList());
                 for (int i = nargs - arrayLength; i < nargs; i++) {
                     ptypes.set(i, arrayElement);
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MethodHandles.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/MethodHandles.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MethodHandles.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/MethodHandles.java	2018-05-20 04:52:08.163913254 +0100
@@ -1953,7 +1953,7 @@
         int inargs  = outargs + dropped;
         if (pos < 0 || pos >= inargs)
             throw newIllegalArgumentException("no argument type to remove");
-        ArrayList<Class<?>> ptypes = new ArrayList<>(oldType.parameterList());
+        ArrayList<Class<?>> ptypes = new ArrayList<Class<?>>(oldType.parameterList());
         ptypes.addAll(pos, valueTypes);
         if (ptypes.size() != inargs)  throw newIllegalArgumentException("valueTypes");
         MethodType newType = MethodType.methodType(oldType.returnType(), ptypes);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MethodType.java openjdk-boot/jdk/src/share/classes/java/lang/invoke/MethodType.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/invoke/MethodType.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/invoke/MethodType.java	2018-05-20 04:52:08.163913254 +0100
@@ -1044,7 +1044,7 @@
         private final float loadFactor;
 
         // Reference queue for cleared WeakEntries
-        private final ReferenceQueue<Object> queue = new ReferenceQueue<>();
+        private final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();
 
         private Entry[] newTable(int n) {
             return new Entry[n];
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/management/ManagementFactory.java openjdk-boot/jdk/src/share/classes/java/lang/management/ManagementFactory.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/management/ManagementFactory.java	2018-05-20 04:38:34.888800572 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/management/ManagementFactory.java	2018-05-20 04:52:08.163913254 +0100
@@ -789,7 +789,7 @@
            getPlatformManagementInterfaces()
     {
         Set<Class<? extends PlatformManagedObject>> result =
-            new HashSet<>();
+            new HashSet<Class<? extends PlatformManagedObject>>();
         for (PlatformComponent component: PlatformComponent.values()) {
             result.add(component.getMXBeanInterface());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/management/PlatformComponent.java openjdk-boot/jdk/src/share/classes/java/lang/management/PlatformComponent.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/management/PlatformComponent.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/management/PlatformComponent.java	2018-05-20 04:52:08.163913254 +0100
@@ -287,7 +287,7 @@
             List<T> getGcMXBeanList(Class<T> gcMXBeanIntf) {
         List<GarbageCollectorMXBean> list =
             ManagementFactoryHelper.getGarbageCollectorMXBeans();
-        List<T> result = new ArrayList<>(list.size());
+        List<T> result = new ArrayList<T>(list.size());
         for (GarbageCollectorMXBean m : list) {
             if (gcMXBeanIntf.isInstance(m)) {
                 result.add(gcMXBeanIntf.cast(m));
@@ -342,7 +342,7 @@
     }
 
     private static Set<String> keyProperties(String... keyNames) {
-        Set<String> set = new HashSet<>();
+        Set<String> set = new HashSet<String>();
         set.add("type");
         for (String s : keyNames) {
             set.add(s);
@@ -407,7 +407,7 @@
             List<T> getMXBeans(MBeanServerConnection mbs, Class<T> mxbeanInterface)
         throws java.io.IOException
     {
-        List<T> result = new ArrayList<>();
+        List<T> result = new ArrayList<T>();
         for (ObjectName on : getObjectNames(mbs)) {
             result.add(ManagementFactory.
                 newPlatformMXBeanProxy(mbs,
@@ -438,7 +438,7 @@
     private static Map<String, PlatformComponent> enumMap;
     private static synchronized void ensureInitialized() {
         if (enumMap == null) {
-            enumMap = new HashMap<>();
+            enumMap = new HashMap<String,PlatformComponent>();
             for (PlatformComponent pc: PlatformComponent.values()) {
                 // Use String as the key rather than Class<?> to avoid
                 // causing unnecessary class loading of management interface
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Package.java openjdk-boot/jdk/src/share/classes/java/lang/Package.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Package.java	2018-05-20 04:38:34.960799432 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Package.java	2018-05-20 04:52:08.163913254 +0100
@@ -599,13 +599,16 @@
     }
 
     // The map of loaded system packages
-    private static Map<String, Package> pkgs = new HashMap<>(31);
+    private static Map<String, Package> pkgs
+        = new HashMap<String, Package>(31);
 
     // Maps each directory or zip file name to its corresponding url
-    private static Map<String, URL> urls = new HashMap<>(10);
+    private static Map<String, URL> urls
+        = new HashMap<String, URL>(10);
 
     // Maps each code source url for a jar file to its manifest
-    private static Map<String, Manifest> mans = new HashMap<>(10);
+    private static Map<String, Manifest> mans
+        = new HashMap<String, Manifest>(10);
 
     private static native String getSystemPackage0(String name);
     private static native String[] getSystemPackages0();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/ProcessBuilder.java openjdk-boot/jdk/src/share/classes/java/lang/ProcessBuilder.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/ProcessBuilder.java	2018-05-20 04:38:34.892800509 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/ProcessBuilder.java	2018-05-20 04:52:08.163913254 +0100
@@ -214,7 +214,7 @@
      * @param command a string array containing the program and its arguments
      */
     public ProcessBuilder(String... command) {
-        this.command = new ArrayList<>(command.length);
+        this.command = new ArrayList<String>(command.length);
         for (String arg : command)
             this.command.add(arg);
     }
@@ -251,7 +251,7 @@
      * @return this process builder
      */
     public ProcessBuilder command(String... command) {
-        this.command = new ArrayList<>(command.length);
+        this.command = new ArrayList<String>(command.length);
         for (String arg : command)
             this.command.add(arg);
         return this;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/Constructor.java openjdk-boot/jdk/src/share/classes/java/lang/reflect/Constructor.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/Constructor.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/reflect/Constructor.java	2018-05-20 04:52:08.163913254 +0100
@@ -137,7 +137,7 @@
         // which implicitly requires that new java.lang.reflect
         // objects be fabricated for each reflective call on Class
         // objects.)
-        Constructor<T> res = new Constructor<>(clazz,
+        Constructor<T> res = new Constructor<T>(clazz,
                                                 parameterTypes,
                                                 exceptionTypes, modifiers, slot,
                                                 signature,
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/Proxy.java openjdk-boot/jdk/src/share/classes/java/lang/reflect/Proxy.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/Proxy.java	2018-05-20 04:38:34.892800509 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/reflect/Proxy.java	2018-05-20 04:52:08.163913254 +0100
@@ -234,7 +234,7 @@
      * a cache of proxy classes
      */
     private static final WeakCache<ClassLoader, Class<?>[], Class<?>>
-        proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());
+        proxyClassCache = new WeakCache<ClassLoader, Class<?>[], Class<?>>(new KeyFactory(), new ProxyClassFactory());
 
     /**
      * the invocation handler for this proxy instance.
@@ -601,7 +601,7 @@
         @Override
         public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
 
-            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
+	  Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<Class<?>, Boolean>(interfaces.length);
             for (Class<?> intf : interfaces) {
                 /*
                  * Verify that the class loader resolves the name of this
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/ReflectAccess.java openjdk-boot/jdk/src/share/classes/java/lang/reflect/ReflectAccess.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/ReflectAccess.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/reflect/ReflectAccess.java	2018-05-20 04:52:08.167913190 +0100
@@ -84,7 +84,7 @@
                                              byte[] annotations,
                                              byte[] parameterAnnotations)
     {
-        return new Constructor<>(declaringClass,
+        return new Constructor<T>(declaringClass,
                                   parameterTypes,
                                   checkedExceptions,
                                   modifiers,
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/WeakCache.java openjdk-boot/jdk/src/share/classes/java/lang/reflect/WeakCache.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/reflect/WeakCache.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/reflect/WeakCache.java	2018-05-20 04:52:08.167913190 +0100
@@ -71,12 +71,12 @@
     }
 
     private final ReferenceQueue<K> refQueue
-        = new ReferenceQueue<>();
+        = new ReferenceQueue<K>();
     // the key type is Object for supporting null key
     private final ConcurrentMap<Object, ConcurrentMap<Object, Supplier<V>>> map
-        = new ConcurrentHashMap<>();
+        = new ConcurrentHashMap<Object, ConcurrentMap<Object, Supplier<V>>>();
     private final ConcurrentMap<Supplier<V>, Boolean> reverseMap
-        = new ConcurrentHashMap<>();
+        = new ConcurrentHashMap<Supplier<V>, Boolean>();
     private final BiFunction<K, P, ?> subKeyFactory;
     private final BiFunction<K, P, V> valueFactory;
 
@@ -123,7 +123,7 @@
         if (valuesMap == null) {
             ConcurrentMap<Object, Supplier<V>> oldValuesMap
                 = map.putIfAbsent(cacheKey,
-                                  valuesMap = new ConcurrentHashMap<>());
+                                  valuesMap = new ConcurrentHashMap<Object, Supplier<V>>());
             if (oldValuesMap != null) {
                 valuesMap = oldValuesMap;
             }
@@ -186,7 +186,7 @@
         Objects.requireNonNull(value);
 
         expungeStaleEntries();
-        return reverseMap.containsKey(new LookupValue<>(value));
+        return reverseMap.containsKey(new LookupValue<V>(value));
     }
 
     /**
@@ -251,7 +251,7 @@
             assert value != null;
 
             // wrap value with CacheValue (WeakReference)
-            CacheValue<V> cacheValue = new CacheValue<>(value);
+            CacheValue<V> cacheValue = new CacheValue<V>(value);
 
             // put into reverseMap
             reverseMap.put(cacheValue, Boolean.TRUE);
@@ -349,7 +349,7 @@
                    // so we use a NULL_KEY singleton as cache key
                    ? NULL_KEY
                    // non-null key requires wrapping with a WeakReference
-                   : new CacheKey<>(key, refQueue);
+                   : new CacheKey<K>(key, refQueue);
         }
 
         private final int hash;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/StringCoding.java openjdk-boot/jdk/src/share/classes/java/lang/StringCoding.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/StringCoding.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/StringCoding.java	2018-05-20 04:52:08.167913190 +0100
@@ -53,9 +53,9 @@
 
     /** The cached coders for each thread */
     private final static ThreadLocal<SoftReference<StringDecoder>> decoder =
-        new ThreadLocal<>();
+        new ThreadLocal<SoftReference<StringDecoder>>();
     private final static ThreadLocal<SoftReference<StringEncoder>> encoder =
-        new ThreadLocal<>();
+        new ThreadLocal<SoftReference<StringEncoder>>();
 
     private static boolean warnUnsupportedCharset = true;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/String.java openjdk-boot/jdk/src/share/classes/java/lang/String.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/String.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/String.java	2018-05-20 04:52:08.167913190 +0100
@@ -2282,7 +2282,7 @@
             int off = 0;
             int next = 0;
             boolean limited = limit > 0;
-            ArrayList<String> list = new ArrayList<>();
+            ArrayList<String> list = new ArrayList<String>();
             while ((next = indexOf(ch, off)) != -1) {
                 if (!limited || list.size() < limit - 1) {
                     list.add(substring(off, next));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Thread.java openjdk-boot/jdk/src/share/classes/java/lang/Thread.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Thread.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Thread.java	2018-05-20 04:52:08.167913190 +0100
@@ -1641,7 +1641,8 @@
         // Get a snapshot of the list of all threads
         Thread[] threads = getThreads();
         StackTraceElement[][] traces = dumpThreads(threads);
-        Map<Thread, StackTraceElement[]> m = new HashMap<>(threads.length);
+        Map<Thread, StackTraceElement[]> m
+            = new HashMap<Thread, StackTraceElement[]>(threads.length);
         for (int i = 0; i < threads.length; i++) {
             StackTraceElement[] stackTrace = traces[i];
             if (stackTrace != null) {
@@ -1662,11 +1663,11 @@
     private static class Caches {
         /** cache of subclass security audit results */
         static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =
-            new ConcurrentHashMap<>();
+            new ConcurrentHashMap<WeakClassKey,Boolean>();
 
         /** queue for WeakReferences to audited subclasses */
         static final ReferenceQueue<Class<?>> subclassAuditsQueue =
-            new ReferenceQueue<>();
+            new ReferenceQueue<Class<?>>();
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/lang/Throwable.java openjdk-boot/jdk/src/share/classes/java/lang/Throwable.java
--- openjdk-boot.orig/jdk/src/share/classes/java/lang/Throwable.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/lang/Throwable.java	2018-05-20 04:52:08.167913190 +0100
@@ -918,7 +918,7 @@
                 // Use the sentinel for a zero-length list
                 suppressed = SUPPRESSED_SENTINEL;
             } else { // Copy Throwables to new list
-                suppressed = new ArrayList<>(1);
+                suppressed = new ArrayList<Throwable>(1);
                 for (Throwable t : suppressedExceptions) {
                     // Enforce constraints on suppressed exceptions in
                     // case of corrupt or malicious stream.
@@ -1049,7 +1049,7 @@
             return;
 
         if (suppressedExceptions == SUPPRESSED_SENTINEL)
-            suppressedExceptions = new ArrayList<>(1);
+            suppressedExceptions = new ArrayList<Throwable>(1);
 
         suppressedExceptions.add(exception);
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/net/InetAddress.java openjdk-boot/jdk/src/share/classes/java/net/InetAddress.java
--- openjdk-boot.orig/jdk/src/share/classes/java/net/InetAddress.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/net/InetAddress.java	2018-05-20 04:52:08.167913190 +0100
@@ -733,7 +733,7 @@
 
     static InetAddressImpl  impl;
 
-    private static final HashMap<String, Void> lookupTable = new HashMap<>();
+    private static final HashMap<String, Void> lookupTable = new HashMap<String, Void>();
 
     /**
      * Represents a cache entry
@@ -792,7 +792,7 @@
 
                 // As we iterate in insertion order we can
                 // terminate when a non-expired entry is found.
-                LinkedList<String> expired = new LinkedList<>();
+                LinkedList<String> expired = new LinkedList<String>();
                 long now = System.currentTimeMillis();
                 for (String key : cache.keySet()) {
                     CacheEntry entry = cache.get(key);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/net/SocketPermission.java openjdk-boot/jdk/src/share/classes/java/net/SocketPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/java/net/SocketPermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/net/SocketPermission.java	2018-05-20 04:52:08.167913190 +0100
@@ -1453,7 +1453,7 @@
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
-        Vector<SocketPermission> permissions = new Vector<>(perms.size());
+        Vector<SocketPermission> permissions = new Vector<SocketPermission>(perms.size());
 
         synchronized (this) {
             permissions.addAll(perms);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/net/URLClassLoader.java openjdk-boot/jdk/src/share/classes/java/net/URLClassLoader.java
--- openjdk-boot.orig/jdk/src/share/classes/java/net/URLClassLoader.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/net/URLClassLoader.java	2018-05-20 04:52:08.167913190 +0100
@@ -198,7 +198,7 @@
      */
 
     private WeakHashMap<Closeable,Void>
-        closeables = new WeakHashMap<>();
+        closeables = new WeakHashMap<Closeable, Void>();
 
     /**
      * Returns an input stream for reading the specified resource.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/net/URLConnection.java openjdk-boot/jdk/src/share/classes/java/net/URLConnection.java
--- openjdk-boot.orig/jdk/src/share/classes/java/net/URLConnection.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/net/URLConnection.java	2018-05-20 04:52:08.167913190 +0100
@@ -1237,7 +1237,7 @@
         factory = fac;
     }
 
-    private static Hashtable<String, ContentHandler> handlers = new Hashtable<>();
+    private static Hashtable<String, ContentHandler> handlers = new Hashtable<String, ContentHandler>();
 
     /**
      * Gets the Content Handler appropriate for this connection.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/net/URL.java openjdk-boot/jdk/src/share/classes/java/net/URL.java
--- openjdk-boot.orig/jdk/src/share/classes/java/net/URL.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/net/URL.java	2018-05-20 04:52:08.167913190 +0100
@@ -1126,7 +1126,7 @@
     /**
      * A table of protocol handlers.
      */
-    static Hashtable<String,URLStreamHandler> handlers = new Hashtable<>();
+    static Hashtable<String,URLStreamHandler> handlers = new Hashtable<String,URLStreamHandler>();
     private static Object streamHandlerLock = new Object();
 
     // special case the gopher protocol, disabled by default
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/nio/file/Files.java openjdk-boot/jdk/src/share/classes/java/nio/file/Files.java
--- openjdk-boot.orig/jdk/src/share/classes/java/nio/file/Files.java	2018-05-20 04:38:34.972799241 +0100
+++ openjdk-boot/jdk/src/share/classes/java/nio/file/Files.java	2018-05-20 04:52:08.167913190 +0100
@@ -1504,7 +1504,7 @@
             return AccessController
                 .doPrivileged(new PrivilegedAction<List<FileTypeDetector>>() {
                     @Override public List<FileTypeDetector> run() {
-                        List<FileTypeDetector> list = new ArrayList<>();
+                        List<FileTypeDetector> list = new ArrayList<FileTypeDetector>();
                         ServiceLoader<FileTypeDetector> loader = ServiceLoader
                             .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());
                         for (FileTypeDetector detector: loader) {
@@ -3112,7 +3112,7 @@
         BufferedReader reader = null;
         try {
             reader = newBufferedReader(path, cs);
-            List<String> result = new ArrayList<>();
+            List<String> result = new ArrayList<String>();
             for (;;) {
                 String line = reader.readLine();
                 if (line == null)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/nio/file/FileTreeWalker.java openjdk-boot/jdk/src/share/classes/java/nio/file/FileTreeWalker.java
--- openjdk-boot.orig/jdk/src/share/classes/java/nio/file/FileTreeWalker.java	2018-05-20 04:38:34.912800192 +0100
+++ openjdk-boot/jdk/src/share/classes/java/nio/file/FileTreeWalker.java	2018-05-20 04:52:08.167913190 +0100
@@ -58,7 +58,7 @@
     private final boolean followLinks;
     private final LinkOption[] linkOptions;
     private final int maxDepth;
-    private final ArrayDeque<DirectoryNode> stack = new ArrayDeque<>();
+    private final ArrayDeque<DirectoryNode> stack = new ArrayDeque<DirectoryNode>();
     private boolean closed;
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/AccessControlContext.java openjdk-boot/jdk/src/share/classes/java/security/AccessControlContext.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/AccessControlContext.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/AccessControlContext.java	2018-05-20 04:52:08.167913190 +0100
@@ -134,7 +134,7 @@
                 this.context = null;
             }
         } else {
-            List<ProtectionDomain> v = new ArrayList<>(context.length);
+            List<ProtectionDomain> v = new ArrayList<ProtectionDomain>(context.length);
             for (int i =0; i< context.length; i++) {
                 if ((context[i] != null) &&  (!v.contains(context[i])))
                     v.add(context[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/BasicPermission.java openjdk-boot/jdk/src/share/classes/java/security/BasicPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/BasicPermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/BasicPermission.java	2018-05-20 04:52:08.167913190 +0100
@@ -513,7 +513,7 @@
 
         // Copy perms into a Hashtable
         Hashtable<String, Permission> permissions =
-                new Hashtable<>(perms.size()*2);
+            new Hashtable<String, Permission>(perms.size()*2);
 
         synchronized (this) {
             permissions.putAll(perms);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/cert/CertificateRevokedException.java openjdk-boot/jdk/src/share/classes/java/security/cert/CertificateRevokedException.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/cert/CertificateRevokedException.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/cert/CertificateRevokedException.java	2018-05-20 04:52:08.167913190 +0100
@@ -232,7 +232,7 @@
         } else if (size < 0) {
             throw new IOException("size cannot be negative");
         } else {
-            extensions = new HashMap<>(size > 20 ? 20 : size);
+            extensions = new HashMap<String, Extension>(size > 20 ? 20 : size);
         }
 
         // Read in the extensions and put the mappings in the extensions map
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/CodeSource.java openjdk-boot/jdk/src/share/classes/java/security/CodeSource.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/CodeSource.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/CodeSource.java	2018-05-20 04:52:08.167913190 +0100
@@ -189,7 +189,7 @@
         } else if (signers != null) {
             // Convert the code signers to certs
             ArrayList<java.security.cert.Certificate> certChains =
-                        new ArrayList<>();
+                        new ArrayList<java.security.cert.Certificate>();
             for (int i = 0; i < signers.length; i++) {
                 certChains.addAll(
                     signers[i].getSignerCertPath().getCertificates());
@@ -540,7 +540,7 @@
             // we know of 3 different cert types: X.509, PGP, SDSI, which
             // could all be present in the stream at the same time
             cfs = new Hashtable<String, CertificateFactory>(3);
-            certList = new ArrayList<>(size > 20 ? 20 : size);
+            certList = new ArrayList<java.security.cert.Certificate>(size > 20 ? 20 : size);
         } else if (size < 0) {
             throw new IOException("size cannot be negative");
         }
@@ -608,10 +608,10 @@
 
             // Iterate through all the certificates
             int i = 0;
-            List<CodeSigner> signers = new ArrayList<>();
+            List<CodeSigner> signers = new ArrayList<CodeSigner>();
             while (i < certs.length) {
                 List<java.security.cert.Certificate> certChain =
-                        new ArrayList<>();
+                        new ArrayList<java.security.cert.Certificate>();
                 certChain.add(certs[i++]); // first cert is an end-entity cert
                 int j = i;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/KeyStore.java openjdk-boot/jdk/src/share/classes/java/security/KeyStore.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/KeyStore.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/KeyStore.java	2018-05-20 04:52:08.171913127 +0100
@@ -492,7 +492,7 @@
             }
 
             this.attributes =
-                Collections.unmodifiableSet(new HashSet<>(attributes));
+                Collections.unmodifiableSet(new HashSet<PKCS12Attribute>(attributes));
         }
 
         /**
@@ -611,7 +611,7 @@
             }
             this.sKey = secretKey;
             this.attributes =
-                Collections.unmodifiableSet(new HashSet<>(attributes));
+                Collections.unmodifiableSet(new HashSet<PKCS12Attribute>(attributes));
         }
 
         /**
@@ -694,7 +694,7 @@
             }
             this.cert = trustedCert;
             this.attributes =
-                Collections.unmodifiableSet(new HashSet<>(attributes));
+                Collections.unmodifiableSet(new HashSet<PKCS12Attribute>(attributes));
         }
 
         /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/Permissions.java openjdk-boot/jdk/src/share/classes/java/security/Permissions.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/Permissions.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/Permissions.java	2018-05-20 04:52:08.171913127 +0100
@@ -361,7 +361,7 @@
 
         // Copy perms into a Hashtable
         Hashtable<Class<?>, PermissionCollection> perms =
-            new Hashtable<>(permsMap.size()*2); // no sync; estimate
+            new Hashtable<Class<?>, PermissionCollection>(permsMap.size()*2); // no sync; estimate
         synchronized (this) {
             perms.putAll(permsMap);
         }
@@ -569,7 +569,7 @@
 
         // Copy perms into a Hashtable
         Hashtable<Permission, Permission> perms =
-                new Hashtable<>(permsMap.size()*2);
+            new Hashtable<Permission, Permission>(permsMap.size()*2);
         synchronized (this) {
             perms.putAll(permsMap);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/Policy.java openjdk-boot/jdk/src/share/classes/java/security/Policy.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/Policy.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/Policy.java	2018-05-20 04:52:08.171913127 +0100
@@ -109,7 +109,7 @@
 
     // PolicyInfo is stored in an AtomicReference
     private static AtomicReference<PolicyInfo> policy =
-        new AtomicReference<>(new PolicyInfo(null, false));
+        new AtomicReference<PolicyInfo>(new PolicyInfo(null, false));
 
     private static final Debug debug = Debug.getInstance("policy");
 
@@ -319,7 +319,7 @@
         PermissionCollection policyPerms = null;
         synchronized (p) {
             if (p.pdMapping == null) {
-                p.pdMapping = new WeakHashMap<>();
+                p.pdMapping = new WeakHashMap<ProtectionDomain.Key, PermissionCollection>();
            }
         }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/ProtectionDomain.java openjdk-boot/jdk/src/share/classes/java/security/ProtectionDomain.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/ProtectionDomain.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/ProtectionDomain.java	2018-05-20 04:52:08.171913127 +0100
@@ -400,8 +400,8 @@
         int swag = 32;
         int vcap = 8;
         Enumeration<Permission> e;
-        List<Permission> pdVector = new ArrayList<>(vcap);
-        List<Permission> plVector = new ArrayList<>(swag);
+        List<Permission> pdVector = new ArrayList<Permission>(vcap);
+        List<Permission> plVector = new ArrayList<Permission>(swag);
 
         //
         // Build a vector of domain permissions for subsequent merge
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/Provider.java openjdk-boot/jdk/src/share/classes/java/security/Provider.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/Provider.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/Provider.java	2018-05-20 04:52:08.171913127 +0100
@@ -434,7 +434,7 @@
 
     private void readObject(ObjectInputStream in)
                 throws IOException, ClassNotFoundException {
-        Map<Object,Object> copy = new HashMap<>();
+        Map<Object,Object> copy = new HashMap<Object,Object>();
         for (Map.Entry<Object,Object> entry : super.entrySet()) {
             copy.put(entry.getKey(), entry.getValue());
         }
@@ -716,7 +716,7 @@
         }
         if (serviceSet == null) {
             ensureLegacyParsed();
-            Set<Service> set = new LinkedHashSet<>();
+            Set<Service> set = new LinkedHashSet<Service>();
             if (serviceMap != null) {
                 set.addAll(serviceMap.values());
             }
@@ -1404,7 +1404,7 @@
                     if (s != null) {
                         String[] classNames = s.split("\\|");
                         List<Class<?>> classList =
-                            new ArrayList<>(classNames.length);
+                            new ArrayList<Class<?>>(classNames.length);
                         for (String className : classNames) {
                             Class<?> clazz = getKeyClass(className);
                             if (clazz != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/SecureClassLoader.java openjdk-boot/jdk/src/share/classes/java/security/SecureClassLoader.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/SecureClassLoader.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/SecureClassLoader.java	2018-05-20 04:52:08.171913127 +0100
@@ -50,7 +50,7 @@
     // HashMap that maps CodeSource to ProtectionDomain
     // @GuardedBy("pdcache")
     private final HashMap<CodeSource, ProtectionDomain> pdcache =
-                        new HashMap<>(11);
+        new HashMap<CodeSource, ProtectionDomain>(11);
 
     private static final Debug debug = Debug.getInstance("scl");
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/Security.java openjdk-boot/jdk/src/share/classes/java/security/Security.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/Security.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/Security.java	2018-05-20 04:52:08.171913127 +0100
@@ -544,7 +544,7 @@
             value = filter.substring(index + 1);
         }
 
-        Hashtable<String, String> hashtableFilter = new Hashtable<>(1);
+        Hashtable<String, String> hashtableFilter = new Hashtable<String, String>(1);
         hashtableFilter.put(key, value);
 
         return (getProviders(hashtableFilter));
@@ -604,7 +604,7 @@
         // Then only return those providers who satisfy the selection criteria.
         Provider[] allProviders = Security.getProviders();
         Set<String> keySet = filter.keySet();
-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);
+        LinkedHashSet<Provider> candidates = new LinkedHashSet<Provider>(5);
 
         // Returns all installed providers
         // if the selection criteria is null.
@@ -659,7 +659,7 @@
 
     // Map containing cached Spi Class objects of the specified type
     private static final Map<String, Class<?>> spiMap =
-            new ConcurrentHashMap<>();
+	new ConcurrentHashMap<String, Class<?>>();
 
     /**
      * Return the Class object for the given engine type
@@ -883,7 +883,7 @@
                                                 String attrName,
                                                 String filterValue,
                                                 Provider[] allProviders) {
-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);
+        LinkedHashSet<Provider> candidates = new LinkedHashSet<Provider>(5);
         for (int i = 0; i < allProviders.length; i++) {
             if (isCriterionSatisfied(allProviders[i], serviceName,
                                      algName,
@@ -1080,7 +1080,7 @@
             return Collections.emptySet();
         }
 
-        HashSet<String> result = new HashSet<>();
+        HashSet<String> result = new HashSet<String>();
         Provider[] providers = Security.getProviders();
 
         for (int i = 0; i < providers.length; i++) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/UnresolvedPermissionCollection.java openjdk-boot/jdk/src/share/classes/java/security/UnresolvedPermissionCollection.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/UnresolvedPermissionCollection.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/UnresolvedPermissionCollection.java	2018-05-20 04:52:08.171913127 +0100
@@ -119,7 +119,7 @@
 
     public Enumeration<Permission> elements() {
         List<Permission> results =
-            new ArrayList<>(); // where results are stored
+            new ArrayList<Permission>(); // where results are stored
 
         // Get iterator of Map values (which are lists of permissions)
         synchronized (this) {
@@ -161,7 +161,7 @@
 
         // Copy perms into a Hashtable
         Hashtable<String, Vector<UnresolvedPermission>> permissions =
-            new Hashtable<>(perms.size()*2);
+            new Hashtable<String, Vector<UnresolvedPermission>>(perms.size()*2);
 
         // Convert each entry (List) into a Vector
         synchronized (this) {
@@ -169,7 +169,7 @@
             for (Map.Entry<String, List<UnresolvedPermission>> e : set) {
                 // Convert list into Vector
                 List<UnresolvedPermission> list = e.getValue();
-                Vector<UnresolvedPermission> vec = new Vector<>(list.size());
+                Vector<UnresolvedPermission> vec = new Vector<UnresolvedPermission>(list.size());
                 synchronized (list) {
                     vec.addAll(list);
                 }
@@ -210,7 +210,7 @@
         for (Map.Entry<String, Vector<UnresolvedPermission>> e : set) {
             // Convert Vector into ArrayList
             Vector<UnresolvedPermission> vec = e.getValue();
-            List<UnresolvedPermission> list = new ArrayList<>(vec.size());
+            List<UnresolvedPermission> list = new ArrayList<UnresolvedPermission>(vec.size());
             list.addAll(vec);
 
             // Add to Hashtable being serialized
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/security/UnresolvedPermission.java openjdk-boot/jdk/src/share/classes/java/security/UnresolvedPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/java/security/UnresolvedPermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/security/UnresolvedPermission.java	2018-05-20 04:52:08.171913127 +0100
@@ -200,7 +200,7 @@
                 if (this.certs == null) {
                     // extract the signer certs
                     ArrayList<java.security.cert.Certificate> signerCerts =
-                        new ArrayList<>();
+                        new ArrayList<java.security.cert.Certificate>();
                     i = 0;
                     while (i < certs.length) {
                         signerCerts.add(certs[i]);
@@ -565,8 +565,8 @@
         if (size > 0) {
             // we know of 3 different cert types: X.509, PGP, SDSI, which
             // could all be present in the stream at the same time
-            cfs = new Hashtable<>(3);
-            certList = new ArrayList<>(size > 20 ? 20 : size);
+            cfs = new Hashtable<String, CertificateFactory>(3);
+            certList = new ArrayList<Certificate>(size > 20 ? 20 : size);
         } else if (size < 0) {
             throw new IOException("size cannot be negative");
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/AbstractList.java openjdk-boot/jdk/src/share/classes/java/util/AbstractList.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/AbstractList.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/AbstractList.java	2018-05-20 04:52:08.171913127 +0100
@@ -482,8 +482,8 @@
      */
     public List<E> subList(int fromIndex, int toIndex) {
         return (this instanceof RandomAccess ?
-                new RandomAccessSubList<>(this, fromIndex, toIndex) :
-                new SubList<>(this, fromIndex, toIndex));
+                new RandomAccessSubList<E>(this, fromIndex, toIndex) :
+                new SubList<E>(this, fromIndex, toIndex));
     }
 
     // Comparison and hashing
@@ -747,7 +747,7 @@
     }
 
     public List<E> subList(int fromIndex, int toIndex) {
-        return new SubList<>(this, fromIndex, toIndex);
+        return new SubList<E>(this, fromIndex, toIndex);
     }
 
     private void rangeCheck(int index) {
@@ -776,6 +776,6 @@
     }
 
     public List<E> subList(int fromIndex, int toIndex) {
-        return new RandomAccessSubList<>(this, fromIndex, toIndex);
+        return new RandomAccessSubList<E>(this, fromIndex, toIndex);
     }
 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Arrays.java openjdk-boot/jdk/src/share/classes/java/util/Arrays.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Arrays.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Arrays.java	2018-05-20 04:52:08.171913127 +0100
@@ -2825,7 +2825,7 @@
      */
     @SafeVarargs
     public static <T> List<T> asList(T... a) {
-        return new ArrayList<>(a);
+        return new ArrayList<T>(a);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Collections.java openjdk-boot/jdk/src/share/classes/java/util/Collections.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Collections.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Collections.java	2018-05-20 04:52:08.171913127 +0100
@@ -1035,7 +1035,7 @@
      * @return an unmodifiable view of the specified collection.
      */
     public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
-        return new UnmodifiableCollection<>(c);
+        return new UnmodifiableCollection<T>(c);
     }
 
     /**
@@ -1109,7 +1109,7 @@
      * @return an unmodifiable view of the specified set.
      */
     public static <T> Set<T> unmodifiableSet(Set<? extends T> s) {
-        return new UnmodifiableSet<>(s);
+        return new UnmodifiableSet<T>(s);
     }
 
     /**
@@ -1141,7 +1141,7 @@
      * @return an unmodifiable view of the specified sorted set.
      */
     public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> s) {
-        return new UnmodifiableSortedSet<>(s);
+        return new UnmodifiableSortedSet<T>(s);
     }
 
     /**
@@ -1158,13 +1158,13 @@
         public Comparator<? super E> comparator() {return ss.comparator();}
 
         public SortedSet<E> subSet(E fromElement, E toElement) {
-            return new UnmodifiableSortedSet<>(ss.subSet(fromElement,toElement));
+            return new UnmodifiableSortedSet<E>(ss.subSet(fromElement,toElement));
         }
         public SortedSet<E> headSet(E toElement) {
-            return new UnmodifiableSortedSet<>(ss.headSet(toElement));
+            return new UnmodifiableSortedSet<E>(ss.headSet(toElement));
         }
         public SortedSet<E> tailSet(E fromElement) {
-            return new UnmodifiableSortedSet<>(ss.tailSet(fromElement));
+            return new UnmodifiableSortedSet<E>(ss.tailSet(fromElement));
         }
 
         public E first()                   {return ss.first();}
@@ -1188,8 +1188,8 @@
      */
     public static <T> List<T> unmodifiableList(List<? extends T> list) {
         return (list instanceof RandomAccess ?
-                new UnmodifiableRandomAccessList<>(list) :
-                new UnmodifiableList<>(list));
+                new UnmodifiableRandomAccessList<T>(list) :
+                new UnmodifiableList<T>(list));
     }
 
     /**
@@ -1250,7 +1250,7 @@
         }
 
         public List<E> subList(int fromIndex, int toIndex) {
-            return new UnmodifiableList<>(list.subList(fromIndex, toIndex));
+            return new UnmodifiableList<E>(list.subList(fromIndex, toIndex));
         }
 
         /**
@@ -1267,7 +1267,7 @@
          */
         private Object readResolve() {
             return (list instanceof RandomAccess
-                    ? new UnmodifiableRandomAccessList<>(list)
+                    ? new UnmodifiableRandomAccessList<E>(list)
                     : this);
         }
     }
@@ -1283,7 +1283,7 @@
         }
 
         public List<E> subList(int fromIndex, int toIndex) {
-            return new UnmodifiableRandomAccessList<>(
+            return new UnmodifiableRandomAccessList<E>(
                 list.subList(fromIndex, toIndex));
         }
 
@@ -1296,7 +1296,7 @@
          * deserialization.
          */
         private Object writeReplace() {
-            return new UnmodifiableList<>(list);
+            return new UnmodifiableList<E>(list);
         }
     }
 
@@ -1315,7 +1315,7 @@
      * @return an unmodifiable view of the specified map.
      */
     public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m) {
-        return new UnmodifiableMap<>(m);
+        return new UnmodifiableMap<K,V>(m);
     }
 
     /**
@@ -1363,7 +1363,7 @@
 
         public Set<Map.Entry<K,V>> entrySet() {
             if (entrySet==null)
-                entrySet = new UnmodifiableEntrySet<>(m.entrySet());
+                entrySet = new UnmodifiableEntrySet<K,V>(m.entrySet());
             return entrySet;
         }
 
@@ -1400,7 +1400,7 @@
                         return i.hasNext();
                     }
                     public Map.Entry<K,V> next() {
-                        return new UnmodifiableEntry<>(i.next());
+                        return new UnmodifiableEntry<K,V>(i.next());
                     }
                     public void remove() {
                         throw new UnsupportedOperationException();
@@ -1411,7 +1411,7 @@
             public Object[] toArray() {
                 Object[] a = c.toArray();
                 for (int i=0; i<a.length; i++)
-                    a[i] = new UnmodifiableEntry<>((Map.Entry<K,V>)a[i]);
+                    a[i] = new UnmodifiableEntry<K,V>((Map.Entry<K,V>)a[i]);
                 return a;
             }
 
@@ -1422,7 +1422,7 @@
                 Object[] arr = c.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));
 
                 for (int i=0; i<arr.length; i++)
-                    arr[i] = new UnmodifiableEntry<>((Map.Entry<K,V>)arr[i]);
+                    arr[i] = new UnmodifiableEntry<K,V>((Map.Entry<K,V>)arr[i]);
 
                 if (arr.length > a.length)
                     return (T[])arr;
@@ -1443,7 +1443,7 @@
                 if (!(o instanceof Map.Entry))
                     return false;
                 return c.contains(
-                    new UnmodifiableEntry<>((Map.Entry<?,?>) o));
+                    new UnmodifiableEntry<Object,Object>((Map.Entry<?,?>) o));
             }
 
             /**
@@ -1519,7 +1519,7 @@
      * @return an unmodifiable view of the specified sorted map.
      */
     public static <K,V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<K, ? extends V> m) {
-        return new UnmodifiableSortedMap<>(m);
+        return new UnmodifiableSortedMap<K,V>(m);
     }
 
     /**
@@ -1537,13 +1537,13 @@
         public Comparator<? super K> comparator() {return sm.comparator();}
 
         public SortedMap<K,V> subMap(K fromKey, K toKey) {
-            return new UnmodifiableSortedMap<>(sm.subMap(fromKey, toKey));
+            return new UnmodifiableSortedMap<K,V>(sm.subMap(fromKey, toKey));
         }
         public SortedMap<K,V> headMap(K toKey) {
-            return new UnmodifiableSortedMap<>(sm.headMap(toKey));
+            return new UnmodifiableSortedMap<K,V>(sm.headMap(toKey));
         }
         public SortedMap<K,V> tailMap(K fromKey) {
-            return new UnmodifiableSortedMap<>(sm.tailMap(fromKey));
+            return new UnmodifiableSortedMap<K,V>(sm.tailMap(fromKey));
         }
 
         public K firstKey()           {return sm.firstKey();}
@@ -1585,11 +1585,11 @@
      * @return a synchronized view of the specified collection.
      */
     public static <T> Collection<T> synchronizedCollection(Collection<T> c) {
-        return new SynchronizedCollection<>(c);
+        return new SynchronizedCollection<T>(c);
     }
 
     static <T> Collection<T> synchronizedCollection(Collection<T> c, Object mutex) {
-        return new SynchronizedCollection<>(c, mutex);
+        return new SynchronizedCollection<T>(c, mutex);
     }
 
     /**
@@ -1688,11 +1688,11 @@
      * @return a synchronized view of the specified set.
      */
     public static <T> Set<T> synchronizedSet(Set<T> s) {
-        return new SynchronizedSet<>(s);
+        return new SynchronizedSet<T>(s);
     }
 
     static <T> Set<T> synchronizedSet(Set<T> s, Object mutex) {
-        return new SynchronizedSet<>(s, mutex);
+        return new SynchronizedSet<T>(s, mutex);
     }
 
     /**
@@ -1758,7 +1758,7 @@
      * @return a synchronized view of the specified sorted set.
      */
     public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s) {
-        return new SynchronizedSortedSet<>(s);
+        return new SynchronizedSortedSet<T>(s);
     }
 
     /**
@@ -1787,18 +1787,18 @@
 
         public SortedSet<E> subSet(E fromElement, E toElement) {
             synchronized (mutex) {
-                return new SynchronizedSortedSet<>(
+                return new SynchronizedSortedSet<E>(
                     ss.subSet(fromElement, toElement), mutex);
             }
         }
         public SortedSet<E> headSet(E toElement) {
             synchronized (mutex) {
-                return new SynchronizedSortedSet<>(ss.headSet(toElement), mutex);
+                return new SynchronizedSortedSet<E>(ss.headSet(toElement), mutex);
             }
         }
         public SortedSet<E> tailSet(E fromElement) {
             synchronized (mutex) {
-               return new SynchronizedSortedSet<>(ss.tailSet(fromElement),mutex);
+               return new SynchronizedSortedSet<E>(ss.tailSet(fromElement),mutex);
             }
         }
 
@@ -1837,14 +1837,14 @@
      */
     public static <T> List<T> synchronizedList(List<T> list) {
         return (list instanceof RandomAccess ?
-                new SynchronizedRandomAccessList<>(list) :
-                new SynchronizedList<>(list));
+                new SynchronizedRandomAccessList<T>(list) :
+                new SynchronizedList<T>(list));
     }
 
     static <T> List<T> synchronizedList(List<T> list, Object mutex) {
         return (list instanceof RandomAccess ?
-                new SynchronizedRandomAccessList<>(list, mutex) :
-                new SynchronizedList<>(list, mutex));
+                new SynchronizedRandomAccessList<T>(list, mutex) :
+                new SynchronizedList<T>(list, mutex));
     }
 
     /**
@@ -1909,7 +1909,7 @@
 
         public List<E> subList(int fromIndex, int toIndex) {
             synchronized (mutex) {
-                return new SynchronizedList<>(list.subList(fromIndex, toIndex),
+                return new SynchronizedList<E>(list.subList(fromIndex, toIndex),
                                             mutex);
             }
         }
@@ -1928,7 +1928,7 @@
          */
         private Object readResolve() {
             return (list instanceof RandomAccess
-                    ? new SynchronizedRandomAccessList<>(list)
+                    ? new SynchronizedRandomAccessList<E>(list)
                     : this);
         }
     }
@@ -1950,7 +1950,7 @@
 
         public List<E> subList(int fromIndex, int toIndex) {
             synchronized (mutex) {
-                return new SynchronizedRandomAccessList<>(
+                return new SynchronizedRandomAccessList<E>(
                     list.subList(fromIndex, toIndex), mutex);
             }
         }
@@ -1964,7 +1964,7 @@
          * deserialization.
          */
         private Object writeReplace() {
-            return new SynchronizedList<>(list);
+            return new SynchronizedList<E>(list);
         }
     }
 
@@ -1996,7 +1996,7 @@
      * @return a synchronized view of the specified map.
      */
     public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {
-        return new SynchronizedMap<>(m);
+        return new SynchronizedMap<K,V>(m);
     }
 
     /**
@@ -2057,7 +2057,7 @@
         public Set<K> keySet() {
             synchronized (mutex) {
                 if (keySet==null)
-                    keySet = new SynchronizedSet<>(m.keySet(), mutex);
+                    keySet = new SynchronizedSet<K>(m.keySet(), mutex);
                 return keySet;
             }
         }
@@ -2065,7 +2065,7 @@
         public Set<Map.Entry<K,V>> entrySet() {
             synchronized (mutex) {
                 if (entrySet==null)
-                    entrySet = new SynchronizedSet<>(m.entrySet(), mutex);
+                    entrySet = new SynchronizedSet<Map.Entry<K,V>>(m.entrySet(), mutex);
                 return entrySet;
             }
         }
@@ -2073,7 +2073,7 @@
         public Collection<V> values() {
             synchronized (mutex) {
                 if (values==null)
-                    values = new SynchronizedCollection<>(m.values(), mutex);
+                    values = new SynchronizedCollection<V>(m.values(), mutex);
                 return values;
             }
         }
@@ -2137,7 +2137,7 @@
      * @return a synchronized view of the specified sorted map.
      */
     public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m) {
-        return new SynchronizedSortedMap<>(m);
+        return new SynchronizedSortedMap<K,V>(m);
     }
 
 
@@ -2167,18 +2167,18 @@
 
         public SortedMap<K,V> subMap(K fromKey, K toKey) {
             synchronized (mutex) {
-                return new SynchronizedSortedMap<>(
+                return new SynchronizedSortedMap<K,V>(
                     sm.subMap(fromKey, toKey), mutex);
             }
         }
         public SortedMap<K,V> headMap(K toKey) {
             synchronized (mutex) {
-                return new SynchronizedSortedMap<>(sm.headMap(toKey), mutex);
+                return new SynchronizedSortedMap<K,V>(sm.headMap(toKey), mutex);
             }
         }
         public SortedMap<K,V> tailMap(K fromKey) {
             synchronized (mutex) {
-               return new SynchronizedSortedMap<>(sm.tailMap(fromKey),mutex);
+               return new SynchronizedSortedMap<K,V>(sm.tailMap(fromKey),mutex);
             }
         }
 
@@ -2254,7 +2254,7 @@
      */
     public static <E> Collection<E> checkedCollection(Collection<E> c,
                                                       Class<E> type) {
-        return new CheckedCollection<>(c, type);
+        return new CheckedCollection<E>(c, type);
     }
 
     @SuppressWarnings("unchecked")
@@ -2386,7 +2386,7 @@
      * @since 1.5
      */
     public static <E> Set<E> checkedSet(Set<E> s, Class<E> type) {
-        return new CheckedSet<>(s, type);
+        return new CheckedSet<E>(s, type);
     }
 
     /**
@@ -2432,7 +2432,7 @@
      */
     public static <E> SortedSet<E> checkedSortedSet(SortedSet<E> s,
                                                     Class<E> type) {
-        return new CheckedSortedSet<>(s, type);
+        return new CheckedSortedSet<E>(s, type);
     }
 
     /**
@@ -2492,8 +2492,8 @@
      */
     public static <E> List<E> checkedList(List<E> list, Class<E> type) {
         return (list instanceof RandomAccess ?
-                new CheckedRandomAccessList<>(list, type) :
-                new CheckedList<>(list, type));
+                new CheckedRandomAccessList<E>(list, type) :
+                new CheckedList<E>(list, type));
     }
 
     /**
@@ -2558,7 +2558,7 @@
         }
 
         public List<E> subList(int fromIndex, int toIndex) {
-            return new CheckedList<>(list.subList(fromIndex, toIndex), type);
+            return new CheckedList<E>(list.subList(fromIndex, toIndex), type);
         }
     }
 
@@ -2575,7 +2575,7 @@
         }
 
         public List<E> subList(int fromIndex, int toIndex) {
-            return new CheckedRandomAccessList<>(
+            return new CheckedRandomAccessList<E>(
                 list.subList(fromIndex, toIndex), type);
         }
     }
@@ -2617,7 +2617,7 @@
     public static <K, V> Map<K, V> checkedMap(Map<K, V> m,
                                               Class<K> keyType,
                                               Class<V> valueType) {
-        return new CheckedMap<>(m, keyType, valueType);
+        return new CheckedMap<K,V>(m, keyType, valueType);
     }
 
 
@@ -2685,14 +2685,15 @@
             // - protection from malicious t
             // - correct behavior if t is a concurrent map
             Object[] entries = t.entrySet().toArray();
-            List<Map.Entry<K,V>> checked = new ArrayList<>(entries.length);
+            List<Map.Entry<K,V>> checked =
+                new ArrayList<Map.Entry<K,V>>(entries.length);
             for (Object o : entries) {
                 Map.Entry<?,?> e = (Map.Entry<?,?>) o;
                 Object k = e.getKey();
                 Object v = e.getValue();
                 typeCheck(k, v);
                 checked.add(
-                    new AbstractMap.SimpleImmutableEntry<>((K) k, (V) v));
+                    new AbstractMap.SimpleImmutableEntry<K,V>((K) k, (V) v));
             }
             for (Map.Entry<K,V> e : checked)
                 m.put(e.getKey(), e.getValue());
@@ -2702,7 +2703,7 @@
 
         public Set<Map.Entry<K,V>> entrySet() {
             if (entrySet==null)
-                entrySet = new CheckedEntrySet<>(m.entrySet(), valueType);
+                entrySet = new CheckedEntrySet<K,V>(m.entrySet(), valueType);
             return entrySet;
         }
 
@@ -2817,7 +2818,7 @@
                 if (!(o instanceof Map.Entry))
                     return false;
                 return s.remove(new AbstractMap.SimpleImmutableEntry
-                                <>((Map.Entry<?,?>)o));
+                                <Object, Object>((Map.Entry<?,?>)o));
             }
 
             public boolean removeAll(Collection<?> c) {
@@ -2850,7 +2851,7 @@
 
             static <K,V,T> CheckedEntry<K,V,T> checkedEntry(Map.Entry<K,V> e,
                                                             Class<T> valueType) {
-                return new CheckedEntry<>(e, valueType);
+                return new CheckedEntry<K,V,T>(e, valueType);
             }
 
             /**
@@ -2891,7 +2892,7 @@
                     if (!(o instanceof Map.Entry))
                         return false;
                     return e.equals(new AbstractMap.SimpleImmutableEntry
-                                    <>((Map.Entry<?,?>)o));
+                                    <Object, Object>((Map.Entry<?,?>)o));
                 }
             }
         }
@@ -2934,7 +2935,7 @@
     public static <K,V> SortedMap<K,V> checkedSortedMap(SortedMap<K, V> m,
                                                         Class<K> keyType,
                                                         Class<V> valueType) {
-        return new CheckedSortedMap<>(m, keyType, valueType);
+        return new CheckedSortedMap<K,V>(m, keyType, valueType);
     }
 
     /**
@@ -3000,7 +3001,7 @@
 
     private static class EmptyIterator<E> implements Iterator<E> {
         static final EmptyIterator<Object> EMPTY_ITERATOR
-            = new EmptyIterator<>();
+            = new EmptyIterator<Object>();
 
         public boolean hasNext() { return false; }
         public E next() { throw new NoSuchElementException(); }
@@ -3049,7 +3050,7 @@
         implements ListIterator<E>
     {
         static final EmptyListIterator<Object> EMPTY_ITERATOR
-            = new EmptyListIterator<>();
+            = new EmptyListIterator<Object>();
 
         public boolean hasPrevious() { return false; }
         public E previous() { throw new NoSuchElementException(); }
@@ -3085,7 +3086,7 @@
 
     private static class EmptyEnumeration<E> implements Enumeration<E> {
         static final EmptyEnumeration<Object> EMPTY_ENUMERATION
-            = new EmptyEnumeration<>();
+            = new EmptyEnumeration<Object>();
 
         public boolean hasMoreElements() { return false; }
         public E nextElement() { throw new NoSuchElementException(); }
@@ -3097,7 +3098,7 @@
      * @see #emptySet()
      */
     @SuppressWarnings("unchecked")
-    public static final Set EMPTY_SET = new EmptySet<>();
+    public static final Set EMPTY_SET = new EmptySet<Object>();
 
     /**
      * Returns the empty set (immutable).  This set is serializable.
@@ -3157,7 +3158,7 @@
      * @see #emptyList()
      */
     @SuppressWarnings("unchecked")
-    public static final List EMPTY_LIST = new EmptyList<>();
+    public static final List EMPTY_LIST = new EmptyList<Object>();
 
     /**
      * Returns the empty list (immutable).  This list is serializable.
@@ -3231,7 +3232,7 @@
      * @since 1.3
      */
     @SuppressWarnings("unchecked")
-    public static final Map EMPTY_MAP = new EmptyMap<>();
+    public static final Map EMPTY_MAP = new EmptyMap<Object,Object>();
 
     /**
      * Returns the empty map (immutable).  This map is serializable.
@@ -3293,7 +3294,7 @@
      * @return an immutable set containing only the specified object.
      */
     public static <T> Set<T> singleton(T o) {
-        return new SingletonSet<>(o);
+        return new SingletonSet<T>(o);
     }
 
     static <E> Iterator<E> singletonIterator(final E e) {
@@ -3346,7 +3347,7 @@
      * @since 1.3
      */
     public static <T> List<T> singletonList(T o) {
-        return new SingletonList<>(o);
+        return new SingletonList<T>(o);
     }
 
     /**
@@ -3388,7 +3389,7 @@
      * @since 1.3
      */
     public static <K,V> Map<K,V> singletonMap(K key, V value) {
-        return new SingletonMap<>(key, value);
+        return new SingletonMap<K,V>(key, value);
     }
 
     /**
@@ -3430,7 +3431,7 @@
         public Set<Map.Entry<K,V>> entrySet() {
             if (entrySet==null)
                 entrySet = Collections.<Map.Entry<K,V>>singleton(
-                    new SimpleImmutableEntry<>(k, v));
+                    new SimpleImmutableEntry<K,V>(k, v));
             return entrySet;
         }
 
@@ -3462,7 +3463,7 @@
     public static <T> List<T> nCopies(int n, T o) {
         if (n < 0)
             throw new IllegalArgumentException("List length = " + n);
-        return new CopiesList<>(n, o);
+        return new CopiesList<T>(n, o);
     }
 
     /**
@@ -3536,7 +3537,7 @@
             if (fromIndex > toIndex)
                 throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                                    ") > toIndex(" + toIndex + ")");
-            return new CopiesList<>(toIndex - fromIndex, element);
+            return new CopiesList<E>(toIndex - fromIndex, element);
         }
     }
 
@@ -3604,7 +3605,7 @@
         if (cmp instanceof ReverseComparator2)
             return ((ReverseComparator2<T>)cmp).cmp;
 
-        return new ReverseComparator2<>(cmp);
+        return new ReverseComparator2<T>(cmp);
     }
 
     /**
@@ -3683,7 +3684,7 @@
      * @see ArrayList
      */
     public static <T> ArrayList<T> list(Enumeration<T> e) {
-        ArrayList<T> l = new ArrayList<>();
+        ArrayList<T> l = new ArrayList<T>();
         while (e.hasMoreElements())
             l.add(e.nextElement());
         return l;
@@ -3876,7 +3877,7 @@
      * @since 1.6
      */
     public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {
-        return new SetFromMap<>(map);
+        return new SetFromMap<E>(map);
     }
 
     /**
@@ -3940,7 +3941,7 @@
      * @since  1.6
      */
     public static <T> Queue<T> asLifoQueue(Deque<T> deque) {
-        return new AsLIFOQueue<>(deque);
+        return new AsLIFOQueue<T>(deque);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Currency.java openjdk-boot/jdk/src/share/classes/java/util/Currency.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Currency.java	2018-05-20 04:38:34.960799432 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Currency.java	2018-05-20 04:52:08.171913127 +0100
@@ -101,7 +101,7 @@
 
     // class data: instance map
 
-    private static ConcurrentMap<String, Currency> instances = new ConcurrentHashMap<>(7);
+    private static ConcurrentMap<String, Currency> instances = new ConcurrentHashMap<String,Currency>(7);
     private static HashSet<Currency> available;
 
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/EnumMap.java openjdk-boot/jdk/src/share/classes/java/util/EnumMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/EnumMap.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/EnumMap.java	2018-05-20 04:52:08.175913064 +0100
@@ -508,7 +508,7 @@
             int j = 0;
             for (int i = 0; i < vals.length; i++)
                 if (vals[i] != null)
-                    a[j++] = new AbstractMap.SimpleEntry<>(
+                    a[j++] = new AbstractMap.SimpleEntry<K,V>(
                         keyUniverse[i], unmaskNull(vals[i]));
             return a;
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/EnumSet.java openjdk-boot/jdk/src/share/classes/java/util/EnumSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/EnumSet.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/EnumSet.java	2018-05-20 04:52:08.175913064 +0100
@@ -110,9 +110,9 @@
             throw new ClassCastException(elementType + " not an enum");
 
         if (universe.length <= 64)
-            return new RegularEnumSet<>(elementType, universe);
+            return new RegularEnumSet<E>(elementType, universe);
         else
-            return new JumboEnumSet<>(elementType, universe);
+            return new JumboEnumSet<E>(elementType, universe);
     }
 
     /**
@@ -431,7 +431,7 @@
     }
 
     Object writeReplace() {
-        return new SerializationProxy<>(this);
+        return new SerializationProxy<E>(this);
     }
 
     // readObject method for the serialization proxy pattern
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Formatter.java openjdk-boot/jdk/src/share/classes/java/util/Formatter.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Formatter.java	2018-05-20 04:38:34.892800509 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Formatter.java	2018-05-20 04:52:08.175913064 +0100
@@ -2531,7 +2531,7 @@
      * Finds format specifiers in the format string.
      */
     private FormatString[] parse(String s) {
-        ArrayList<FormatString> al = new ArrayList<>();
+        ArrayList<FormatString> al = new ArrayList<FormatString>();
         Matcher m = fsPattern.matcher(s);
         for (int i = 0, len = s.length(); i < len; ) {
             if (m.find(i)) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/HashMap.java openjdk-boot/jdk/src/share/classes/java/util/HashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/HashMap.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/HashMap.java	2018-05-20 04:52:08.175913064 +0100
@@ -895,7 +895,7 @@
      */
     void createEntry(int hash, K key, V value, int bucketIndex) {
         Entry<K,V> e = table[bucketIndex];
-        table[bucketIndex] = new Entry<>(hash, key, value, e);
+        table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
         size++;
     }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/HashSet.java openjdk-boot/jdk/src/share/classes/java/util/HashSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/HashSet.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/HashSet.java	2018-05-20 04:52:08.175913064 +0100
@@ -104,7 +104,7 @@
      * default initial capacity (16) and load factor (0.75).
      */
     public HashSet() {
-        map = new HashMap<>();
+        map = new HashMap<E,Object>();
     }
 
     /**
@@ -117,7 +117,7 @@
      * @throws NullPointerException if the specified collection is null
      */
     public HashSet(Collection<? extends E> c) {
-        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
+        map = new HashMap<E,Object>(Math.max((int) (c.size()/.75f) + 1, 16));
         addAll(c);
     }
 
@@ -131,7 +131,7 @@
      *             than zero, or if the load factor is nonpositive
      */
     public HashSet(int initialCapacity, float loadFactor) {
-        map = new HashMap<>(initialCapacity, loadFactor);
+        map = new HashMap<E,Object>(initialCapacity, loadFactor);
     }
 
     /**
@@ -143,7 +143,7 @@
      *             than zero
      */
     public HashSet(int initialCapacity) {
-        map = new HashMap<>(initialCapacity);
+        map = new HashMap<E,Object>(initialCapacity);
     }
 
     /**
@@ -160,7 +160,7 @@
      *             than zero, or if the load factor is nonpositive
      */
     HashSet(int initialCapacity, float loadFactor, boolean dummy) {
-        map = new LinkedHashMap<>(initialCapacity, loadFactor);
+        map = new LinkedHashMap<E,Object>(initialCapacity, loadFactor);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Hashtable.java openjdk-boot/jdk/src/share/classes/java/util/Hashtable.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Hashtable.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Hashtable.java	2018-05-20 04:52:08.175913064 +0100
@@ -539,7 +539,7 @@
 
         // Creates the new entry.
         Entry<K,V> e = tab[index];
-        tab[index] = new Entry<>(hash, key, value, e);
+        tab[index] = new Entry<K,V>(hash, key, value, e);
         count++;
         return null;
     }
@@ -663,7 +663,7 @@
         if (count == 0) {
             return Collections.emptyEnumeration();
         } else {
-            return new Enumerator<>(type, false);
+            return new Enumerator<T>(type, false);
         }
     }
 
@@ -671,7 +671,7 @@
         if (count == 0) {
             return Collections.emptyIterator();
         } else {
-            return new Enumerator<>(type, true);
+            return new Enumerator<T>(type, true);
         }
     }
 
@@ -949,7 +949,7 @@
 
                 while (entry != null) {
                     entryStack =
-                        new Entry<>(0, entry.key, entry.value, entryStack);
+                        new Entry<K,V>(0, entry.key, entry.value, entryStack);
                     entry = entry.next;
                 }
             }
@@ -1048,7 +1048,7 @@
         }
         // Creates the new entry.
         Entry<K,V> e = tab[index];
-        tab[index] = new Entry<>(hash, key, value, e);
+        tab[index] = new Entry<K,V>(hash, key, value, e);
         count++;
     }
 
@@ -1069,7 +1069,7 @@
         }
 
         protected Object clone() {
-            return new Entry<>(hash, key, value,
+            return new Entry<K,V>(hash, key, value,
                                   (next==null ? null : (Entry<K,V>) next.clone()));
         }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/IdentityHashMap.java openjdk-boot/jdk/src/share/classes/java/util/IdentityHashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/IdentityHashMap.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/IdentityHashMap.java	2018-05-20 04:52:08.175913064 +0100
@@ -1142,7 +1142,7 @@
             Object[] result = new Object[size];
             Iterator<Map.Entry<K,V>> it = iterator();
             for (int i = 0; i < size; i++)
-                result[i] = new AbstractMap.SimpleEntry<>(it.next());
+                result[i] = new AbstractMap.SimpleEntry<K,V>(it.next());
             return result;
         }
 
@@ -1154,7 +1154,7 @@
                     .newInstance(a.getClass().getComponentType(), size);
             Iterator<Map.Entry<K,V>> it = iterator();
             for (int i = 0; i < size; i++)
-                a[i] = (T) new AbstractMap.SimpleEntry<>(it.next());
+                a[i] = (T) new AbstractMap.SimpleEntry<K,V>(it.next());
             if (a.length > size)
                 a[size] = null;
             return a;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/jar/Attributes.java openjdk-boot/jdk/src/share/classes/java/util/jar/Attributes.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/jar/Attributes.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/jar/Attributes.java	2018-05-20 04:52:08.175913064 +0100
@@ -71,7 +71,7 @@
      * @param size the initial number of attributes
      */
     public Attributes(int size) {
-        map = new HashMap<>(size);
+        map = new HashMap<Object,Object>(size);
     }
 
     /**
@@ -81,7 +81,7 @@
      * @param attr the specified Attributes
      */
     public Attributes(Attributes attr) {
-        map = new HashMap<>(attr);
+        map = new HashMap<Object,Object>(attr);
     }
 
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/jar/JarVerifier.java openjdk-boot/jdk/src/share/classes/java/util/jar/JarVerifier.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/jar/JarVerifier.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/jar/JarVerifier.java	2018-05-20 04:52:08.175913064 +0100
@@ -95,10 +95,10 @@
 
     public JarVerifier(byte rawBytes[]) {
         manifestRawBytes = rawBytes;
-        sigFileSigners = new Hashtable<>();
-        verifiedSigners = new Hashtable<>();
-        sigFileData = new Hashtable<>(11);
-        pendingBlocks = new ArrayList<>();
+        sigFileSigners = new Hashtable<String, CodeSigner[]>();
+        verifiedSigners = new Hashtable<String, CodeSigner[]>();
+        sigFileData = new Hashtable<String, byte[]>(11);
+        pendingBlocks = new ArrayList<SignatureFileVerifier>();
         baos = new ByteArrayOutputStream();
         manifestDigests = new ArrayList();
     }
@@ -283,7 +283,7 @@
                 String key = uname.substring(0, uname.lastIndexOf("."));
 
                 if (signerCache == null)
-                    signerCache = new ArrayList<>();
+                    signerCache = new ArrayList<CodeSigner[]>();
 
                 if (manDig == null) {
                     synchronized(manifestRawBytes) {
@@ -389,7 +389,7 @@
         CodeSigner[] signers) {
 
         if (signers != null) {
-            ArrayList<java.security.cert.Certificate> certChains = new ArrayList<>();
+            ArrayList<java.security.cert.Certificate> certChains = new ArrayList<java.security.cert.Certificate>();
             for (int i = 0; i < signers.length; i++) {
                 certChains.addAll(
                     signers[i].getSignerCertPath().getCertificates());
@@ -505,8 +505,10 @@
 
     // Extended JavaUtilJarAccess CodeSource API Support
 
-    private Map<URL, Map<CodeSigner[], CodeSource>> urlToCodeSourceMap = new HashMap<>();
-    private Map<CodeSigner[], CodeSource> signerToCodeSource = new HashMap<>();
+    private Map<URL, Map<CodeSigner[], CodeSource>> urlToCodeSourceMap
+	= new HashMap<URL, Map<CodeSigner[], CodeSource>>();
+    private Map<CodeSigner[], CodeSource> signerToCodeSource
+	= new HashMap<CodeSigner[], CodeSource>();
     private URL lastURL;
     private Map<CodeSigner[], CodeSource> lastURLMap;
 
@@ -522,7 +524,7 @@
         } else {
             map = urlToCodeSourceMap.get(url);
             if (map == null) {
-                map = new HashMap<>();
+                map = new HashMap<CodeSigner[], CodeSource>();
                 urlToCodeSourceMap.put(url, map);
             }
             lastURLMap = map;
@@ -537,7 +539,7 @@
     }
 
     private CodeSource[] mapSignersToCodeSources(URL url, List<CodeSigner[]> signers, boolean unsigned) {
-        List<CodeSource> sources = new ArrayList<>();
+        List<CodeSource> sources = new ArrayList<CodeSource>();
 
         for (int i = 0; i < signers.size(); i++) {
             sources.add(mapSignersToCodeSource(url, signers.get(i)));
@@ -565,7 +567,7 @@
          * but this handles a CodeSource of any type, just in case.
          */
         CodeSource[] sources = mapSignersToCodeSources(cs.getLocation(), getJarCodeSigners(), true);
-        List<CodeSource> sourceList = new ArrayList<>();
+        List<CodeSource> sourceList = new ArrayList<CodeSource>();
         for (int i = 0; i < sources.length; i++) {
             sourceList.add(sources[i]);
         }
@@ -663,7 +665,8 @@
              * only about the asserted signatures. Verification of
              * signature validity happens via the JarEntry apis.
              */
-            signerMap = new HashMap<>(verifiedSigners.size() + sigFileSigners.size());
+            signerMap
+		= new HashMap<String, CodeSigner[]>(verifiedSigners.size() + sigFileSigners.size());
             signerMap.putAll(verifiedSigners);
             signerMap.putAll(sigFileSigners);
         }
@@ -679,7 +682,7 @@
          * Grab a single copy of the CodeSigner arrays. Check
          * to see if we can optimize CodeSigner equality test.
          */
-        List<CodeSigner[]> req = new ArrayList<>(cs.length);
+        List<CodeSigner[]> req = new ArrayList<CodeSigner[]>(cs.length);
         for (int i = 0; i < cs.length; i++) {
             CodeSigner[] match = findMatchingSigners(cs[i]);
             if (match != null) {
@@ -735,7 +738,7 @@
      * and includes signed entries with no ZIP data.
      */
     public Enumeration<JarEntry> entries2(final JarFile jar, Enumeration<? extends ZipEntry> e) {
-        final Map<String, CodeSigner[]> map = new HashMap<>();
+        final Map<String, CodeSigner[]> map = new HashMap<String, CodeSigner[]>();
         map.putAll(signerMap());
         final Enumeration<? extends ZipEntry> enum_ = e;
         return new Enumeration<JarEntry>() {
@@ -840,9 +843,9 @@
     private synchronized List<CodeSigner[]> getJarCodeSigners() {
         CodeSigner[] signers;
         if (jarCodeSigners == null) {
-            HashSet<CodeSigner[]> set = new HashSet<>();
+            HashSet<CodeSigner[]> set = new HashSet<CodeSigner[]>();
             set.addAll(signerMap().values());
-            jarCodeSigners = new ArrayList<>();
+            jarCodeSigners = new ArrayList<CodeSigner[]>();
             jarCodeSigners.addAll(set);
         }
         return jarCodeSigners;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/JumboEnumSet.java openjdk-boot/jdk/src/share/classes/java/util/JumboEnumSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/JumboEnumSet.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/JumboEnumSet.java	2018-05-20 04:52:08.175913064 +0100
@@ -91,7 +91,7 @@
      * @return an iterator over the elements contained in this set
      */
     public Iterator<E> iterator() {
-        return new EnumSetIterator<>();
+        return new EnumSetIterator<E>();
     }
 
     private class EnumSetIterator<E extends Enum<E>> implements Iterator<E> {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/LinkedHashMap.java openjdk-boot/jdk/src/share/classes/java/util/LinkedHashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/LinkedHashMap.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/LinkedHashMap.java	2018-05-20 04:52:08.175913064 +0100
@@ -238,7 +238,7 @@
      */
     @Override
     void init() {
-        header = new Entry<>(-1, null, null, null);
+        header = new Entry<K,V>(-1, null, null, null);
         header.before = header.after = header;
     }
 
@@ -439,7 +439,7 @@
      */
     void createEntry(int hash, K key, V value, int bucketIndex) {
         HashMap.Entry<K,V> old = table[bucketIndex];
-        Entry<K,V> e = new Entry<>(hash, key, value, old);
+        Entry<K,V> e = new Entry<K,V>(hash, key, value, old);
         table[bucketIndex] = e;
         e.addBefore(header);
         size++;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/LinkedList.java openjdk-boot/jdk/src/share/classes/java/util/LinkedList.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/LinkedList.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/LinkedList.java	2018-05-20 04:52:08.175913064 +0100
@@ -122,7 +122,7 @@
      */
     private void linkFirst(E e) {
         final Node<E> f = first;
-        final Node<E> newNode = new Node<>(null, e, f);
+        final Node<E> newNode = new Node<E>(null, e, f);
         first = newNode;
         if (f == null)
             last = newNode;
@@ -137,7 +137,7 @@
      */
     void linkLast(E e) {
         final Node<E> l = last;
-        final Node<E> newNode = new Node<>(l, e, null);
+        final Node<E> newNode = new Node<E>(l, e, null);
         last = newNode;
         if (l == null)
             first = newNode;
@@ -153,7 +153,7 @@
     void linkBefore(E e, Node<E> succ) {
         // assert succ != null;
         final Node<E> pred = succ.prev;
-        final Node<E> newNode = new Node<>(pred, e, succ);
+        final Node<E> newNode = new Node<E>(pred, e, succ);
         succ.prev = newNode;
         if (pred == null)
             first = newNode;
@@ -419,7 +419,7 @@
 
         for (Object o : a) {
             @SuppressWarnings("unchecked") E e = (E) o;
-            Node<E> newNode = new Node<>(pred, e, null);
+            Node<E> newNode = new Node<E>(pred, e, null);
             if (pred == null)
                 first = newNode;
             else
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/ListResourceBundle.java openjdk-boot/jdk/src/share/classes/java/util/ListResourceBundle.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/ListResourceBundle.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/ListResourceBundle.java	2018-05-20 04:52:08.175913064 +0100
@@ -187,7 +187,7 @@
             return;
 
         Object[][] contents = getContents();
-        HashMap<String,Object> temp = new HashMap<>(contents.length);
+        HashMap<String,Object> temp = new HashMap<String,Object>(contents.length);
         for (int i = 0; i < contents.length; ++i) {
             // key must be non-null String, value must be non-null
             String key = (String) contents[i][0];
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Locale.java openjdk-boot/jdk/src/share/classes/java/util/Locale.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Locale.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Locale.java	2018-05-20 04:52:08.175913064 +0100
@@ -1807,7 +1807,7 @@
                 return formatList(variantNames, listPattern, listCompositionPattern);
             }
         }
-        ArrayList<String> names = new ArrayList<>(4);
+        ArrayList<String> names = new ArrayList<String>(4);
         if (languageName.length() != 0) {
             names.add(languageName);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/FileHandler.java openjdk-boot/jdk/src/share/classes/java/util/logging/FileHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/FileHandler.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/FileHandler.java	2018-05-20 04:53:44.550386112 +0100
@@ -128,7 +128,7 @@
     private File files[];
     private static final int DEFAULT_MAX_LOCKS = 100;
     private static int maxLocks;
-    private static java.util.HashMap<String, String> locks = new java.util.HashMap<>();
+    private static java.util.HashMap<String, String> locks = new java.util.HashMap<String, String>();
 
     /*
      * Initialize maxLocks from the System property if set.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Level.java openjdk-boot/jdk/src/share/classes/java/util/logging/Level.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Level.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/Level.java	2018-05-20 04:52:08.175913064 +0100
@@ -524,8 +524,8 @@
     // were final, the following KnownLevel implementation can be removed.
     // Future API change should take this into consideration.
     static final class KnownLevel {
-        private static Map<String, List<KnownLevel>> nameToLevels = new HashMap<>();
-        private static Map<Integer, List<KnownLevel>> intToLevels = new HashMap<>();
+        private static Map<String, List<KnownLevel>> nameToLevels = new HashMap<String, List<KnownLevel>>();
+        private static Map<Integer, List<KnownLevel>> intToLevels = new HashMap<Integer, List<KnownLevel>>();
         final Level levelObject;     // instance of Level class or Level subclass
         final Level mirroredLevel;   // instance of Level class
         KnownLevel(Level l) {
@@ -543,14 +543,14 @@
             KnownLevel o = new KnownLevel(l);
             List<KnownLevel> list = nameToLevels.get(l.name);
             if (list == null) {
-                list = new ArrayList<>();
+                list = new ArrayList<KnownLevel>();
                 nameToLevels.put(l.name, list);
             }
             list.add(o);
 
             list = intToLevels.get(l.value);
             if (list == null) {
-                list = new ArrayList<>();
+                list = new ArrayList<KnownLevel>();
                 intToLevels.put(l.value, list);
             }
             list.add(o);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Logger.java openjdk-boot/jdk/src/share/classes/java/util/logging/Logger.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Logger.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/Logger.java	2018-05-20 04:52:08.179913001 +0100
@@ -177,7 +177,7 @@
     private volatile LogManager manager;
     private String name;
     private final CopyOnWriteArrayList<Handler> handlers =
-        new CopyOnWriteArrayList<>();
+        new CopyOnWriteArrayList<Handler>();
     private volatile String resourceBundleName;
     private volatile boolean useParentHandlers = true;
     private volatile Filter filter;
@@ -1612,7 +1612,7 @@
             // Set our new parent.
             parent = newParent;
             if (parent.kids == null) {
-                parent.kids = new ArrayList<>(2);
+                parent.kids = new ArrayList<LogManager.LoggerWeakRef>(2);
             }
             if (ref == null) {
                 // we didn't have a previous parent
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Logging.java openjdk-boot/jdk/src/share/classes/java/util/logging/Logging.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/Logging.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/Logging.java	2018-05-20 04:52:08.179913001 +0100
@@ -56,7 +56,7 @@
 
     public List<String> getLoggerNames() {
         Enumeration loggers = logManager.getLoggerNames();
-        ArrayList<String> array = new ArrayList<>();
+        ArrayList<String> array = new ArrayList<String>();
 
         for (; loggers.hasMoreElements();) {
             array.add((String) loggers.nextElement());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/LogManager.java openjdk-boot/jdk/src/share/classes/java/util/logging/LogManager.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/LogManager.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/LogManager.java	2018-05-20 04:52:08.179913001 +0100
@@ -389,7 +389,7 @@
                     // find the AppContext of the applet code
                     // will be null if we are in the main app context.
                     if (contextsMap == null) {
-                        contextsMap = new WeakHashMap<>();
+                        contextsMap = new WeakHashMap<Object, LoggerContext>();
                     }
                     context = contextsMap.get(ecx);
                     if (context == null) {
@@ -408,7 +408,7 @@
     }
 
     private List<LoggerContext> contexts() {
-        List<LoggerContext> cxs = new ArrayList<>();
+        List<LoggerContext> cxs = new ArrayList<LoggerContext>();
         cxs.add(systemContext);
         cxs.add(getUserContext());
         return cxs;
@@ -501,7 +501,7 @@
     // added in the user context.
     static class LoggerContext {
         // Table of named Loggers that maps names to Loggers.
-        private final Hashtable<String,LoggerWeakRef> namedLoggers = new Hashtable<>();
+        private final Hashtable<String,LoggerWeakRef> namedLoggers = new Hashtable<String,LoggerWeakRef>();
         // Tree of named Loggers
         private final LogNode root;
         private final boolean requiresDefaultLoggers;
@@ -744,7 +744,7 @@
                     name = "";
                 }
                 if (node.children == null) {
-                    node.children = new HashMap<>();
+                    node.children = new HashMap<String,LogNode>();
                 }
                 LogNode child = node.children.get(head);
                 if (child == null) {
@@ -836,7 +836,7 @@
     // loggerRefQueue holds LoggerWeakRef objects for Logger objects
     // that have been GC'ed.
     private final ReferenceQueue<Logger> loggerRefQueue
-        = new ReferenceQueue<>();
+        = new ReferenceQueue<Logger>();
 
     // Package-level inner class.
     // Helper class for managing WeakReferences to Logger objects.
@@ -1211,7 +1211,7 @@
         }
         hands = hands.trim();
         int ix = 0;
-        Vector<String> result = new Vector<>();
+        Vector<String> result = new Vector<String>();
         while (ix < hands.length()) {
             int end = ix;
             while (end < hands.length()) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/logging/LogRecord.java openjdk-boot/jdk/src/share/classes/java/util/logging/LogRecord.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/logging/LogRecord.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/logging/LogRecord.java	2018-05-20 04:52:08.179913001 +0100
@@ -85,7 +85,8 @@
     private static final AtomicInteger nextThreadId
         = new AtomicInteger(MIN_SEQUENTIAL_THREAD_ID);
 
-    private static final ThreadLocal<Integer> threadIds = new ThreadLocal<>();
+    private static final ThreadLocal<Integer> threadIds
+        = new ThreadLocal<Integer>();
 
     /**
      * @serial Logging message level
@@ -509,7 +510,7 @@
                 parameters[i] = in.readObject();
             }
         } else {
-            List<Object> params = new ArrayList<>(Math.min(len, 1024));
+            List<Object> params = new ArrayList<Object>(Math.min(len, 1024));
             for (int i = 0; i < len; i++) {
                 params.add(in.readObject());
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/prefs/AbstractPreferences.java openjdk-boot/jdk/src/share/classes/java/util/prefs/AbstractPreferences.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/prefs/AbstractPreferences.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/prefs/AbstractPreferences.java	2018-05-20 04:52:08.179913001 +0100
@@ -155,7 +155,8 @@
      * All known unremoved children of this node.  (This "cache" is consulted
      * prior to calling childSpi() or getChild().
      */
-    private Map<String, AbstractPreferences> kidCache = new HashMap<>();
+    private Map<String, AbstractPreferences> kidCache
+        = new HashMap<String, AbstractPreferences>();
 
     /**
      * This field is used to keep track of whether or not this node has
@@ -712,7 +713,7 @@
             if (removed)
                 throw new IllegalStateException("Node has been removed.");
 
-            Set<String> s = new TreeSet<>(kidCache.keySet());
+            Set<String> s = new TreeSet<String>(kidCache.keySet());
             for (String kid : childrenNamesSpi())
                 s.add(kid);
             return s.toArray(EMPTY_STRING_ARRAY);
@@ -1441,7 +1442,8 @@
      * event delivery from preference activity, greatly simplifying
      * locking and reducing opportunity for deadlock.
      */
-    private static final List<EventObject> eventQueue = new LinkedList<>();
+    private static final List<EventObject> eventQueue
+        = new LinkedList<EventObject>();
 
     /**
      * These two classes are used to distinguish NodeChangeEvents on
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/PriorityQueue.java openjdk-boot/jdk/src/share/classes/java/util/PriorityQueue.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/PriorityQueue.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/PriorityQueue.java	2018-05-20 04:52:08.179913001 +0100
@@ -540,7 +540,7 @@
                     cursor--;
                 else {
                     if (forgetMeNot == null)
-                        forgetMeNot = new ArrayDeque<>();
+                        forgetMeNot = new ArrayDeque<E>();
                     forgetMeNot.add(moved);
                 }
             } else if (lastRetElt != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/Properties.java openjdk-boot/jdk/src/share/classes/java/util/Properties.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/Properties.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/Properties.java	2018-05-20 04:52:08.179913001 +0100
@@ -1005,7 +1005,7 @@
      * @since   1.6
      */
     public Set<String> stringPropertyNames() {
-        Hashtable<String, String> h = new Hashtable<>();
+        Hashtable<String, String> h = new Hashtable<String, String>();
         enumerateStringProperties(h);
         return h.keySet();
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/regex/Pattern.java openjdk-boot/jdk/src/share/classes/java/util/regex/Pattern.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/regex/Pattern.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/regex/Pattern.java	2018-05-20 04:52:08.179913001 +0100
@@ -321,7 +321,7 @@
  *     <td headers="matches">Nothing, but quotes all characters until <tt>\E</tt></td></tr>
  * <tr><td valign="top" headers="construct quot"><tt>\E</tt></td>
  *     <td headers="matches">Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
- *     <!-- Metachars: !$()*+.<>?[\]^{|} -->
+ *     <!-- Metachars: !$()*+.?[\]^{|} -->
  *
  * <tr><th>&nbsp;</th></tr>
  * <tr align="left"><th colspan="2" id="special">Special constructs (named-capturing and non-capturing)</th></tr>
@@ -1193,7 +1193,7 @@
     public String[] split(CharSequence input, int limit) {
         int index = 0;
         boolean matchLimited = limit > 0;
-        ArrayList<String> matchList = new ArrayList<>();
+        ArrayList<String> matchList = new ArrayList<String>();
         Matcher m = matcher(input);
 
         // Add segments before each match found
@@ -1695,7 +1695,7 @@
 
     Map<String, Integer> namedGroups() {
         if (namedGroups == null)
-            namedGroups = new HashMap<>(2);
+            namedGroups = new HashMap<String, Integer>(2);
         return namedGroups;
     }
 
@@ -5495,7 +5495,7 @@
         }
 
         private static final HashMap<String, CharPropertyFactory> map
-            = new HashMap<>();
+            = new HashMap<String, CharPropertyFactory>();
 
         static {
             // Unicode character property aliases, defined in
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/regex/UnicodeProp.java openjdk-boot/jdk/src/share/classes/java/util/regex/UnicodeProp.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/regex/UnicodeProp.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/regex/UnicodeProp.java	2018-05-20 04:52:08.179913001 +0100
@@ -193,8 +193,8 @@
         }
     };
 
-    private final static HashMap<String, String> posix = new HashMap<>();
-    private final static HashMap<String, String> aliases = new HashMap<>();
+    private final static HashMap<String, String> posix = new HashMap<String,String>();
+    private final static HashMap<String, String> aliases = new HashMap<String,String>();
     static {
         posix.put("ALPHA", "ALPHABETIC");
         posix.put("LOWER", "LOWERCASE");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/RegularEnumSet.java openjdk-boot/jdk/src/share/classes/java/util/RegularEnumSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/RegularEnumSet.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/RegularEnumSet.java	2018-05-20 04:52:08.179913001 +0100
@@ -72,7 +72,7 @@
      * @return an iterator over the elements contained in this set
      */
     public Iterator<E> iterator() {
-        return new EnumSetIterator<>();
+        return new EnumSetIterator<E>();
     }
 
     private class EnumSetIterator<E extends Enum<E>> implements Iterator<E> {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/ResourceBundle.java openjdk-boot/jdk/src/share/classes/java/util/ResourceBundle.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/ResourceBundle.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/ResourceBundle.java	2018-05-20 04:52:08.179913001 +0100
@@ -291,7 +291,7 @@
      * name for compatibility with some workarounds for bug 4212439.
      */
     private static final ConcurrentMap<CacheKey, BundleReference> cacheList
-        = new ConcurrentHashMap<>(INITIAL_CACHE_SIZE);
+      = new ConcurrentHashMap<CacheKey,BundleReference>(INITIAL_CACHE_SIZE);
 
     /**
      * Queue for reference objects referring to class loaders or bundles.
@@ -1763,7 +1763,7 @@
      * @since 1.6
      */
     public Set<String> keySet() {
-        Set<String> keys = new HashSet<>();
+        Set<String> keys = new HashSet<String>();
         for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
             keys.addAll(rb.handleKeySet());
         }
@@ -1791,7 +1791,7 @@
         if (keySet == null) {
             synchronized (this) {
                 if (keySet == null) {
-                    Set<String> keys = new HashSet<>();
+                    Set<String> keys = new HashSet<String>();
                     Enumeration<String> enumKeys = getKeys();
                     while (enumKeys.hasMoreElements()) {
                         String key = enumKeys.nextElement();
@@ -2309,7 +2309,7 @@
             if (baseName == null) {
                 throw new NullPointerException();
             }
-            return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));
+            return new ArrayList<Locale>(CANDIDATES_CACHE.get(locale.getBaseLocale()));
         }
 
         private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();
@@ -2335,7 +2335,7 @@
                 if (language.equals("nb") || isNorwegianBokmal) {
                     List<Locale> tmpList = getDefaultList("nb", script, region, variant);
                     // Insert a locale replacing "nb" with "no" for every list entry
-                    List<Locale> bokmalList = new LinkedList<>();
+                    List<Locale> bokmalList = new LinkedList<Locale>();
                     for (Locale l : tmpList) {
                         bokmalList.add(l);
                         if (l.getLanguage().length() == 0) {
@@ -2382,7 +2382,7 @@
                 List<String> variants = null;
 
                 if (variant.length() > 0) {
-                    variants = new LinkedList<>();
+                    variants = new LinkedList<String>();
                     int idx = variant.length();
                     while (idx != -1) {
                         variants.add(variant.substring(0, idx));
@@ -2390,7 +2390,7 @@
                     }
                 }
 
-                List<Locale> list = new LinkedList<>();
+                List<Locale> list = new LinkedList<Locale>();
 
                 if (variants != null) {
                     for (String v : variants) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/ServiceLoader.java openjdk-boot/jdk/src/share/classes/java/util/ServiceLoader.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/ServiceLoader.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/ServiceLoader.java	2018-05-20 04:52:08.179913001 +0100
@@ -191,7 +191,7 @@
     private ClassLoader loader;
 
     // Cached providers, in instantiation order
-    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();
+    private LinkedHashMap<String,S> providers = new LinkedHashMap<String,S>();
 
     // The current lazy-lookup iterator
     private LazyIterator lookupIterator;
@@ -291,7 +291,7 @@
     {
         InputStream in = null;
         BufferedReader r = null;
-        ArrayList<String> names = new ArrayList<>();
+        ArrayList<String> names = new ArrayList<String>();
         try {
             in = u.openStream();
             r = new BufferedReader(new InputStreamReader(in, "utf-8"));
@@ -470,7 +470,7 @@
     public static <S> ServiceLoader<S> load(Class<S> service,
                                             ClassLoader loader)
     {
-        return new ServiceLoader<>(service, loader);
+        return new ServiceLoader<S>(service, loader);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/TimSort.java openjdk-boot/jdk/src/share/classes/java/util/TimSort.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/TimSort.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/TimSort.java	2018-05-20 04:52:08.179913001 +0100
@@ -196,7 +196,7 @@
          * extending short natural runs to minRun elements, and merging runs
          * to maintain stack invariant.
          */
-        TimSort<T> ts = new TimSort<>(a, c);
+        TimSort<T> ts = new TimSort<T>(a, c);
         int minRun = minRunLength(nRemaining);
         do {
             // Identify next run
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/TreeMap.java openjdk-boot/jdk/src/share/classes/java/util/TreeMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/TreeMap.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/TreeMap.java	2018-05-20 04:52:08.179913001 +0100
@@ -530,7 +530,7 @@
         if (t == null) {
             compare(key, key); // type (and possibly null) check
 
-            root = new Entry<>(key, value, null);
+            root = new Entry<K,V>(key, value, null);
             size = 1;
             modCount++;
             return null;
@@ -566,7 +566,7 @@
                     return t.setValue(value);
             } while (t != null);
         }
-        Entry<K,V> e = new Entry<>(key, value, parent);
+        Entry<K,V> e = new Entry<K,V>(key, value, parent);
         if (cmp < 0)
             parent.left = e;
         else
@@ -1066,14 +1066,14 @@
         }
         public NavigableSet<E> subSet(E fromElement, boolean fromInclusive,
                                       E toElement,   boolean toInclusive) {
-            return new KeySet<>(m.subMap(fromElement, fromInclusive,
+            return new KeySet<E>(m.subMap(fromElement, fromInclusive,
                                           toElement,   toInclusive));
         }
         public NavigableSet<E> headSet(E toElement, boolean inclusive) {
-            return new KeySet<>(m.headMap(toElement, inclusive));
+            return new KeySet<E>(m.headMap(toElement, inclusive));
         }
         public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
-            return new KeySet<>(m.tailMap(fromElement, inclusive));
+            return new KeySet<E>(m.tailMap(fromElement, inclusive));
         }
         public SortedSet<E> subSet(E fromElement, E toElement) {
             return subSet(fromElement, true, toElement, false);
@@ -1202,7 +1202,7 @@
      */
     static <K,V> Map.Entry<K,V> exportEntry(TreeMap.Entry<K,V> e) {
         return (e == null) ? null :
-            new AbstractMap.SimpleImmutableEntry<>(e);
+            new AbstractMap.SimpleImmutableEntry<K,V>(e);
     }
 
     /**
@@ -2403,7 +2403,7 @@
             value = (defaultVal != null ? defaultVal : (V) str.readObject());
         }
 
-        Entry<K,V> middle =  new Entry<>(key, value, null);
+        Entry<K,V> middle =  new Entry<K,V>(key, value, null);
 
         // color nodes in non-full bottommost level red
         if (level == redLevel)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/TreeSet.java openjdk-boot/jdk/src/share/classes/java/util/TreeSet.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/TreeSet.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/TreeSet.java	2018-05-20 04:52:08.179913001 +0100
@@ -138,7 +138,7 @@
      *        ordering} of the elements will be used.
      */
     public TreeSet(Comparator<? super E> comparator) {
-        this(new TreeMap<>(comparator));
+        this(new TreeMap<E,Object>(comparator));
     }
 
     /**
@@ -195,7 +195,7 @@
      * @since 1.6
      */
     public NavigableSet<E> descendingSet() {
-        return new TreeSet<>(m.descendingMap());
+        return new TreeSet<E>(m.descendingMap());
     }
 
     /**
@@ -322,7 +322,7 @@
      */
     public NavigableSet<E> subSet(E fromElement, boolean fromInclusive,
                                   E toElement,   boolean toInclusive) {
-        return new TreeSet<>(m.subMap(fromElement, fromInclusive,
+        return new TreeSet<E>(m.subMap(fromElement, fromInclusive,
                                        toElement,   toInclusive));
     }
 
@@ -335,7 +335,7 @@
      * @since 1.6
      */
     public NavigableSet<E> headSet(E toElement, boolean inclusive) {
-        return new TreeSet<>(m.headMap(toElement, inclusive));
+        return new TreeSet<E>(m.headMap(toElement, inclusive));
     }
 
     /**
@@ -347,7 +347,7 @@
      * @since 1.6
      */
     public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
-        return new TreeSet<>(m.tailMap(fromElement, inclusive));
+        return new TreeSet<E>(m.tailMap(fromElement, inclusive));
     }
 
     /**
@@ -477,7 +477,7 @@
             throw new InternalError();
         }
 
-        clone.m = new TreeMap<>(m);
+        clone.m = new TreeMap<E,Object>(m);
         return clone;
     }
 
@@ -524,9 +524,9 @@
         // Create backing TreeMap
         TreeMap<E,Object> tm;
         if (c==null)
-            tm = new TreeMap<>();
+            tm = new TreeMap<E,Object>();
         else
-            tm = new TreeMap<>(c);
+            tm = new TreeMap<E,Object>(c);
         m = tm;
 
         // Read in size
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/WeakHashMap.java openjdk-boot/jdk/src/share/classes/java/util/WeakHashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/WeakHashMap.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/WeakHashMap.java	2018-05-20 04:52:08.183912938 +0100
@@ -172,7 +172,7 @@
     /**
      * Reference queue for cleared WeakEntries
      */
-    private final ReferenceQueue<Object> queue = new ReferenceQueue<>();
+    private final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();
 
     /**
      * The number of times this WeakHashMap has been structurally modified.
@@ -529,7 +529,7 @@
 
         modCount++;
         Entry<K,V> e = tab[i];
-        tab[i] = new Entry<>(k, value, queue, h, e);
+        tab[i] = new Entry<K,V>(k, value, queue, h, e);
         if (++size >= threshold)
             resize(tab.length * 2);
         return null;
@@ -1052,9 +1052,10 @@
         }
 
         private List<Map.Entry<K,V>> deepCopy() {
-            List<Map.Entry<K,V>> list = new ArrayList<>(size());
+            List<Map.Entry<K,V>> list =
+                new ArrayList<Map.Entry<K,V>>(size());
             for (Map.Entry<K,V> e : this)
-                list.add(new AbstractMap.SimpleEntry<>(e));
+                list.add(new AbstractMap.SimpleEntry<K,V>(e));
             return list;
         }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/zip/ZipFile.java openjdk-boot/jdk/src/share/classes/java/util/zip/ZipFile.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/zip/ZipFile.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/zip/ZipFile.java	2018-05-20 04:52:08.183912938 +0100
@@ -336,7 +336,7 @@
 
     // the outstanding inputstreams that need to be closed,
     // mapped to the inflater objects they use.
-    private final Map<InputStream, Inflater> streams = new WeakHashMap<>();
+    private final Map<InputStream, Inflater> streams = new WeakHashMap<InputStream,Inflater>();
 
     /**
      * Returns an input stream for reading the contents of the specified
@@ -478,7 +478,7 @@
     }
 
     // List of available Inflater objects for decompression
-    private Deque<Inflater> inflaterCache = new ArrayDeque<>();
+    private Deque<Inflater> inflaterCache = new ArrayDeque<Inflater>();
 
     /**
      * Returns the path name of the ZIP file.
@@ -596,7 +596,7 @@
             // Close streams, release their inflaters
             synchronized (streams) {
                 if (false == streams.isEmpty()) {
-                    Map<InputStream, Inflater> copy = new HashMap<>(streams);
+                    Map<InputStream, Inflater> copy = new HashMap<InputStream,Inflater>(streams);
                     streams.clear();
                     for (Map.Entry<InputStream, Inflater> e : copy.entrySet()) {
                         e.getKey().close();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/java/util/zip/ZipOutputStream.java openjdk-boot/jdk/src/share/classes/java/util/zip/ZipOutputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/java/util/zip/ZipOutputStream.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/java/util/zip/ZipOutputStream.java	2018-05-20 04:52:08.183912938 +0100
@@ -53,8 +53,8 @@
     }
 
     private XEntry current;
-    private Vector<XEntry> xentries = new Vector<>();
-    private HashSet<String> names = new HashSet<>();
+    private Vector<XEntry> xentries = new Vector<XEntry>();
+    private HashSet<String> names = new HashSet<String>();
     private CRC32 crc = new CRC32();
     private long written = 0;
     private long locoff = 0;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/crypto/Cipher.java openjdk-boot/jdk/src/share/classes/javax/crypto/Cipher.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/crypto/Cipher.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/crypto/Cipher.java	2018-05-20 04:52:53.695191859 +0100
@@ -416,7 +416,7 @@
             return Collections.singletonList(tr);
         } else { // if ((mode != null) && (pad != null)) {
             // AES/CBC/PKCS5Padding
-            List<Transform> list = new ArrayList<>(4);
+            List<Transform> list = new ArrayList<Transform>(4);
             list.add(new Transform(alg, "/" + mode + "/" + pad, null, null));
             list.add(new Transform(alg, "/" + mode, null, pad));
             list.add(new Transform(alg, "//" + pad, mode, null));
@@ -473,7 +473,7 @@
             throws NoSuchAlgorithmException, NoSuchPaddingException
     {
         List<Transform> transforms = getTransforms(transformation);
-        List<ServiceId> cipherServices = new ArrayList<>(transforms.size());
+        List<ServiceId> cipherServices = new ArrayList<ServiceId>(transforms.size());
         for (Transform transform : transforms) {
             cipherServices.add(new ServiceId("Cipher", transform.transform));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/crypto/CryptoAllPermission.java openjdk-boot/jdk/src/share/classes/javax/crypto/CryptoAllPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/crypto/CryptoAllPermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/crypto/CryptoAllPermission.java	2018-05-20 04:52:08.183912938 +0100
@@ -172,7 +172,7 @@
      * @return an enumeration of all the CryptoAllPermission objects.
      */
     public Enumeration<Permission> elements() {
-        Vector<Permission> v = new Vector<>(1);
+        Vector<Permission> v = new Vector<Permission>(1);
         if (all_allowed) v.add(CryptoAllPermission.INSTANCE);
         return v.elements();
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/crypto/CryptoPermissions.java openjdk-boot/jdk/src/share/classes/javax/crypto/CryptoPermissions.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/crypto/CryptoPermissions.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/crypto/CryptoPermissions.java	2018-05-20 04:52:08.183912938 +0100
@@ -84,7 +84,7 @@
      * no CryptoPermissionCollections.
      */
     CryptoPermissions() {
-        perms = new ConcurrentHashMap<>(7);
+        perms = new ConcurrentHashMap<String,PermissionCollection>(7);
     }
 
     /**
@@ -294,7 +294,7 @@
      */
     private CryptoPermission[] getMinimum(PermissionCollection thisPc,
                                           PermissionCollection thatPc) {
-        Vector<CryptoPermission> permVector = new Vector<>(2);
+        Vector<CryptoPermission> permVector = new Vector<CryptoPermission>(2);
 
         Enumeration<Permission> thisPcPermissions = thisPc.elements();
 
@@ -350,7 +350,7 @@
      */
     private CryptoPermission[] getMinimum(int maxKeySize,
                                           PermissionCollection pc) {
-        Vector<CryptoPermission> permVector = new Vector<>(1);
+        Vector<CryptoPermission> permVector = new Vector<CryptoPermission>(1);
 
         Enumeration<Permission> enum_ = pc.elements();
 
@@ -435,15 +435,15 @@
                 (Hashtable<String,PermissionCollection>)
                 (fields.get("perms", null));
         if (permTable != null) {
-            perms = new ConcurrentHashMap<>(permTable);
+            perms = new ConcurrentHashMap<String,PermissionCollection>(permTable);
         } else {
-            perms = new ConcurrentHashMap<>();
+            perms = new ConcurrentHashMap<String,PermissionCollection>();
         }
     }
 
     private void writeObject(ObjectOutputStream s) throws IOException {
         Hashtable<String,PermissionCollection> permTable =
-                new Hashtable<>(perms);
+            new Hashtable<String,PermissionCollection>(perms);
         ObjectOutputStream.PutField fields = s.putFields();
         fields.put("perms", permTable);
         s.writeFields();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/crypto/CryptoPolicyParser.java openjdk-boot/jdk/src/share/classes/javax/crypto/CryptoPolicyParser.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/crypto/CryptoPolicyParser.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/crypto/CryptoPolicyParser.java	2018-05-20 04:52:08.183912938 +0100
@@ -252,7 +252,7 @@
             // AlgorithmParameterSpec class name.
             String algParamSpecClassName = match("quoted string");
 
-            Vector<Integer> paramsV = new Vector<>(1);
+            Vector<Integer> paramsV = new Vector<Integer>(1);
             while (peek(",")) {
                 match(",");
                 if (peek("number")) {
@@ -456,7 +456,7 @@
     }
 
     CryptoPermission[] getPermissions() {
-        Vector<CryptoPermission> result = new Vector<>();
+        Vector<CryptoPermission> result = new Vector<CryptoPermission>();
 
         Enumeration<GrantEntry> grantEnum = grantEntries.elements();
         while (grantEnum.hasMoreElements()) {
@@ -498,7 +498,7 @@
 
         if (processedPermissions == null) {
             processedPermissions = new Hashtable<String, Vector<String>>();
-            Vector<String> exemptionMechanisms = new Vector<>(1);
+            Vector<String> exemptionMechanisms = new Vector<String>(1);
             exemptionMechanisms.addElement(thisExemptionMechanism);
             processedPermissions.put(alg, exemptionMechanisms);
             return true;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/crypto/JceSecurity.java openjdk-boot/jdk/src/share/classes/javax/crypto/JceSecurity.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/crypto/JceSecurity.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/crypto/JceSecurity.java	2018-05-20 04:52:08.183912938 +0100
@@ -60,11 +60,11 @@
     // value == PROVIDER_VERIFIED is successfully verified
     // value is failure cause Exception in error case
     private final static Map<Provider, Object> verificationResults =
-            new IdentityHashMap<>();
+	new IdentityHashMap<Provider, Object>();
 
     // Map<Provider,?> of the providers currently being verified
     private final static Map<Provider, Object> verifyingProviders =
-            new IdentityHashMap<>();
+	new IdentityHashMap<Provider, Object>();
 
     // Set the default value. May be changed in the static initializer.
     private static boolean isRestricted = true;
@@ -218,7 +218,7 @@
 
     // reference to a Map we use as a cache for codebases
     private static final Map<Class<?>, URL> codeBaseCacheRef =
-            new WeakHashMap<>();
+	new WeakHashMap<Class<?>, URL>();
 
     /*
      * Returns the CodeBase for the given class.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/crypto/JceSecurityManager.java openjdk-boot/jdk/src/share/classes/javax/crypto/JceSecurityManager.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/crypto/JceSecurityManager.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/crypto/JceSecurityManager.java	2018-05-20 04:52:08.183912938 +0100
@@ -52,9 +52,9 @@
     private static final CryptoPermissions exemptPolicy;
     private static final CryptoAllPermission allPerm;
     private static final Vector<Class<?>> TrustedCallersCache =
-            new Vector<>(2);
+            new Vector<Class<?>>(2);
     private static final ConcurrentMap<URL,CryptoPermissions> exemptCache =
-            new ConcurrentHashMap<>();
+	    new ConcurrentHashMap<URL, CryptoPermissions>();
     private static final CryptoPermissions CACHE_NULL_MARK =
             new CryptoPermissions();
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/imageio/spi/ServiceRegistry.java openjdk-boot/jdk/src/share/classes/javax/imageio/spi/ServiceRegistry.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/imageio/spi/ServiceRegistry.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/imageio/spi/ServiceRegistry.java	2018-05-20 04:52:08.183912938 +0100
@@ -698,7 +698,8 @@
 
     // Class -> Provider Object of that class
     final Map<Class<?>,Object> map = new HashMap();
-    final Map<Class<?>,AccessControlContext> accMap = new HashMap<>();
+    final Map<Class<?>,AccessControlContext> accMap
+	= new HashMap<Class<?>,AccessControlContext>();
 
     public SubRegistry(ServiceRegistry registry, Class category) {
         this.registry = registry;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/management/remote/rmi/RMIJRMPServerImpl.java openjdk-boot/jdk/src/share/classes/javax/management/remote/rmi/RMIJRMPServerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/management/remote/rmi/RMIJRMPServerImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/management/remote/rmi/RMIJRMPServerImpl.java	2018-05-20 04:52:08.183912938 +0100
@@ -103,7 +103,7 @@
                 = (String[]) this.env.get(EnvHelp.CREDENTIAL_TYPES);
         List<String> types = null;
         if (credentialsTypes != null) {
-            types = new ArrayList<>();
+            types = new ArrayList<String>();
             for (String type : credentialsTypes) {
                 if (type == null) {
                     throw new IllegalArgumentException("A credential type is null.");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/directory/BasicAttribute.java openjdk-boot/jdk/src/share/classes/javax/naming/directory/BasicAttribute.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/directory/BasicAttribute.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/directory/BasicAttribute.java	2018-05-20 04:52:08.183912938 +0100
@@ -255,7 +255,7 @@
       */
     public BasicAttribute(String id, boolean ordered) {
         attrID = id;
-        values = new Vector<>();
+        values = new Vector<Object>();
         this.ordered = ordered;
     }
 
@@ -515,7 +515,7 @@
             throws java.io.IOException, ClassNotFoundException {
         s.defaultReadObject();  // read in the attrID
         int n = s.readInt();    // number of values
-        values = new Vector<>(Math.min(1024, n));
+        values = new Vector<Object>(Math.min(1024, n));
         while (--n >= 0) {
             values.addElement(s.readObject());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/directory/BasicAttributes.java openjdk-boot/jdk/src/share/classes/javax/naming/directory/BasicAttributes.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/directory/BasicAttributes.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/directory/BasicAttributes.java	2018-05-20 04:52:08.183912938 +0100
@@ -79,7 +79,7 @@
     // If ignoreCase is true, key is aways lowercase.
     // If ignoreCase is false, key is stored as supplied by put().
     // %%% Not declared "private" due to bug 4064984.
-    transient Hashtable<String,Attribute> attrs = new Hashtable<>(11);
+    transient Hashtable<String,Attribute> attrs = new Hashtable<String,Attribute>(11);
 
     /**
       * Constructs a new instance of Attributes.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/ldap/InitialLdapContext.java openjdk-boot/jdk/src/share/classes/javax/naming/ldap/InitialLdapContext.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/ldap/InitialLdapContext.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/ldap/InitialLdapContext.java	2018-05-20 04:52:08.183912938 +0100
@@ -137,7 +137,7 @@
 
         // Clone environment since caller owns it.
         Hashtable<Object,Object> env = (environment == null)
-            ? new Hashtable<>(11)
+            ? new Hashtable<Object, Object>(11)
             : (Hashtable<Object,Object>)environment.clone();
 
         // Put connect controls into environment.  Copy them first since
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/ldap/LdapName.java openjdk-boot/jdk/src/share/classes/javax/naming/ldap/LdapName.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/ldap/LdapName.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/ldap/LdapName.java	2018-05-20 04:52:08.183912938 +0100
@@ -142,7 +142,7 @@
         //              "Invalid entries, list entries must be of type Rdn");
         //  }
 
-        this.rdns = new ArrayList<>(rdns.size());
+        this.rdns = new ArrayList<Rdn>(rdns.size());
         for (int i = 0; i < rdns.size(); i++) {
             Object obj = rdns.get(i);
             if (!(obj instanceof Rdn)) {
@@ -164,7 +164,7 @@
         // this.rdns = rdns.subList(beg, end);
 
         List<Rdn> sList = rdns.subList(beg, end);
-        this.rdns = new ArrayList<>(sList);
+        this.rdns = new ArrayList<Rdn>(sList);
     }
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/ldap/Rdn.java openjdk-boot/jdk/src/share/classes/javax/naming/ldap/Rdn.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/ldap/Rdn.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/ldap/Rdn.java	2018-05-20 04:52:08.183912938 +0100
@@ -130,7 +130,7 @@
         if (attrSet.size() == 0) {
             throw new InvalidNameException("Attributes cannot be empty");
         }
-        entries = new ArrayList<>(attrSet.size());
+        entries = new ArrayList<RdnEntry>(attrSet.size());
         NamingEnumeration<? extends Attribute> attrs = attrSet.getAll();
         try {
             for (int nEntries = 0; attrs.hasMore(); nEntries++) {
@@ -161,7 +161,7 @@
      *                  parsing of the rdnString.
      */
     public Rdn(String rdnString) throws InvalidNameException {
-        entries = new ArrayList<>(DEFAULT_SIZE);
+        entries = new ArrayList<RdnEntry>(DEFAULT_SIZE);
         (new Rfc2253Parser(rdnString)).parseRdn(this);
     }
 
@@ -172,7 +172,7 @@
      * @param rdn The non-null Rdn to be copied.
      */
     public Rdn(Rdn rdn) {
-        entries = new ArrayList<>(rdn.entries.size());
+        entries = new ArrayList<RdnEntry>(rdn.entries.size());
         entries.addAll(rdn.entries);
     }
 
@@ -199,7 +199,7 @@
                 "type or value cannot be empty, type:" + type +
                 " value:" + value);
         }
-        entries = new ArrayList<>(DEFAULT_SIZE);
+        entries = new ArrayList<RdnEntry>(DEFAULT_SIZE);
         put(type, value);
     }
 
@@ -210,7 +210,7 @@
 
     // An empty constructor used by the parser
     Rdn() {
-        entries = new ArrayList<>(DEFAULT_SIZE);
+        entries = new ArrayList<RdnEntry>(DEFAULT_SIZE);
     }
 
     /*
@@ -747,7 +747,7 @@
     private void readObject(ObjectInputStream s)
             throws IOException, ClassNotFoundException {
         s.defaultReadObject();
-        entries = new ArrayList<>(DEFAULT_SIZE);
+        entries = new ArrayList<RdnEntry>(DEFAULT_SIZE);
         String unparsed = (String) s.readObject();
         try {
             (new Rfc2253Parser(unparsed)).parseRdn(this);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/ldap/Rfc2253Parser.java openjdk-boot/jdk/src/share/classes/javax/naming/ldap/Rfc2253Parser.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/ldap/Rfc2253Parser.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/ldap/Rfc2253Parser.java	2018-05-20 04:52:08.183912938 +0100
@@ -61,7 +61,7 @@
             //  new ArrayList<Rdn>(len / 3 + 10);  // leave room for growth
 
             ArrayList<Rdn> rdns =
-                new ArrayList<>(len / 3 + 10);  // leave room for growth
+                new ArrayList<Rdn>(len / 3 + 10);  // leave room for growth
 
             if (len == 0) {
                 return rdns;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/NameImpl.java openjdk-boot/jdk/src/share/classes/javax/naming/NameImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/NameImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/NameImpl.java	2018-05-20 04:52:08.183912938 +0100
@@ -272,7 +272,7 @@
         if (syntax != null) {
             recordNamingConvention(syntax);
         }
-        components = new Vector<>();
+        components = new Vector<String>();
     }
 
     NameImpl(Properties syntax, String n) throws InvalidNameException {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/Reference.java openjdk-boot/jdk/src/share/classes/javax/naming/Reference.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/Reference.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/Reference.java	2018-05-20 04:52:08.183912938 +0100
@@ -120,7 +120,7 @@
       */
     public Reference(String className) {
         this.className  = className;
-        addrs = new Vector<>();
+        addrs = new Vector<RefAddr>();
     }
 
     /**
@@ -134,7 +134,7 @@
       */
     public Reference(String className, RefAddr addr) {
         this.className = className;
-        addrs = new Vector<>();
+        addrs = new Vector<RefAddr>();
         addrs.addElement(addr);
     }
 
@@ -382,7 +382,7 @@
     public Object clone() {
         Reference r = new Reference(className, classFactory, classFactoryLocation);
         Enumeration<RefAddr> a = getAll();
-        r.addrs = new Vector<>();
+        r.addrs = new Vector<RefAddr>();
 
         while (a.hasMoreElements())
             r.addrs.addElement(a.nextElement());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/spi/DirectoryManager.java openjdk-boot/jdk/src/share/classes/javax/naming/spi/DirectoryManager.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/spi/DirectoryManager.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/spi/DirectoryManager.java	2018-05-20 04:52:08.183912938 +0100
@@ -90,7 +90,7 @@
 
         Hashtable<Object,Object> env = (Hashtable<Object,Object>)cpe.getEnvironment();
         if (env == null) {
-            env = new Hashtable<>(7);
+            env = new Hashtable<Object, Object>(7);
         } else {
             // Make a (shallow) copy of the environment.
             env = (Hashtable<Object,Object>) env.clone();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/naming/spi/NamingManager.java openjdk-boot/jdk/src/share/classes/javax/naming/spi/NamingManager.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/naming/spi/NamingManager.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/naming/spi/NamingManager.java	2018-05-20 04:52:08.183912938 +0100
@@ -777,7 +777,7 @@
 
         Hashtable<Object,Object> env = (Hashtable<Object,Object>)cpe.getEnvironment();
         if (env == null) {
-            env = new Hashtable<>(7);
+            env = new Hashtable<Object, Object>(7);
         } else {
             // Make a (shallow) copy of the environment.
             env = (Hashtable<Object,Object>)env.clone();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/script/ScriptEngineManager.java openjdk-boot/jdk/src/share/classes/javax/script/ScriptEngineManager.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/script/ScriptEngineManager.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/script/ScriptEngineManager.java	2018-05-20 04:52:08.187912873 +0100
@@ -116,7 +116,7 @@
             return null;
         }
 
-        final List<ScriptEngineFactory> facList = new ArrayList<>();
+        final List<ScriptEngineFactory> facList = new ArrayList<ScriptEngineFactory>();
         try {
             while (itr.hasNext()) {
                 try {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/kerberos/DelegationPermission.java openjdk-boot/jdk/src/share/classes/javax/security/auth/kerberos/DelegationPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/kerberos/DelegationPermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/security/auth/kerberos/DelegationPermission.java	2018-05-20 04:52:08.187912873 +0100
@@ -361,7 +361,7 @@
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
-        Vector<Permission> permissions = new Vector<>(perms.size());
+        Vector<Permission> permissions = new Vector<Permission>(perms.size());
 
         synchronized (this) {
             permissions.addAll(perms);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/kerberos/ServicePermission.java openjdk-boot/jdk/src/share/classes/javax/security/auth/kerberos/ServicePermission.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/kerberos/ServicePermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/security/auth/kerberos/ServicePermission.java	2018-05-20 04:52:08.187912873 +0100
@@ -590,7 +590,7 @@
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
-        Vector<Permission> permissions = new Vector<>(perms.size());
+        Vector<Permission> permissions = new Vector<Permission>(perms.size());
 
         synchronized (this) {
             permissions.addAll(perms);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/PrivateCredentialPermission.java openjdk-boot/jdk/src/share/classes/javax/security/auth/PrivateCredentialPermission.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/PrivateCredentialPermission.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/security/auth/PrivateCredentialPermission.java	2018-05-20 04:52:08.187912873 +0100
@@ -329,7 +329,7 @@
             throw new IllegalArgumentException("invalid empty name");
         }
 
-        ArrayList<CredOwner> pList = new ArrayList<>();
+        ArrayList<CredOwner> pList = new ArrayList<CredOwner>();
         StringTokenizer tokenizer = new StringTokenizer(name, " ", true);
         String principalClass = null;
         String principalName = null;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/SubjectDomainCombiner.java openjdk-boot/jdk/src/share/classes/javax/security/auth/SubjectDomainCombiner.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/security/auth/SubjectDomainCombiner.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/security/auth/SubjectDomainCombiner.java	2018-05-20 04:52:08.187912873 +0100
@@ -50,7 +50,7 @@
 
     private Subject subject;
     private WeakKeyValueMap<ProtectionDomain, ProtectionDomain> cachedPDs =
-                new WeakKeyValueMap<>();
+        new WeakKeyValueMap<ProtectionDomain, ProtectionDomain>();
     private Set<Principal> principalSet;
     private Principal[] principals;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/javax/swing/JDesktopPane.java openjdk-boot/jdk/src/share/classes/javax/swing/JDesktopPane.java
--- openjdk-boot.orig/jdk/src/share/classes/javax/swing/JDesktopPane.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/javax/swing/JDesktopPane.java	2018-05-20 04:52:08.187912873 +0100
@@ -267,7 +267,7 @@
 
     private static Collection<JInternalFrame> getAllFrames(Container parent) {
         int i, count;
-        Collection<JInternalFrame> results = new LinkedHashSet<>();
+        Collection<JInternalFrame> results = new LinkedHashSet<JInternalFrame>();
         count = parent.getComponentCount();
         for (i = 0; i < count; i++) {
             Component next = parent.getComponent(i);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/jdk/net/Sockets.java openjdk-boot/jdk/src/share/classes/jdk/net/Sockets.java
--- openjdk-boot.orig/jdk/src/share/classes/jdk/net/Sockets.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/jdk/net/Sockets.java	2018-05-20 04:52:08.187912873 +0100
@@ -58,7 +58,7 @@
 public class Sockets {
 
     private final static HashMap<Class<?>,Set<SocketOption<?>>>
-        options = new HashMap<>();
+      options = new HashMap<Class<?>,Set<SocketOption<?>>>();
 
     static {
         initOptionSets();
@@ -351,7 +351,7 @@
 
         // Socket
 
-        Set<SocketOption<?>> set = new HashSet<>();
+        Set<SocketOption<?>> set = new HashSet<SocketOption<?>>();
         set.add(StandardSocketOptions.SO_KEEPALIVE);
         set.add(StandardSocketOptions.SO_SNDBUF);
         set.add(StandardSocketOptions.SO_RCVBUF);
@@ -367,7 +367,7 @@
 
         // ServerSocket
 
-        set = new HashSet<>();
+        set = new HashSet<SocketOption<?>>();
         set.add(StandardSocketOptions.SO_RCVBUF);
         set.add(StandardSocketOptions.SO_REUSEADDR);
         set.add(StandardSocketOptions.IP_TOS);
@@ -376,7 +376,7 @@
 
         // DatagramSocket
 
-        set = new HashSet<>();
+        set = new HashSet<SocketOption<?>>();
         set.add(StandardSocketOptions.SO_SNDBUF);
         set.add(StandardSocketOptions.SO_RCVBUF);
         set.add(StandardSocketOptions.SO_REUSEADDR);
@@ -389,7 +389,7 @@
 
         // MulticastSocket
 
-        set = new HashSet<>();
+        set = new HashSet<SocketOption<?>>();
         set.add(StandardSocketOptions.SO_SNDBUF);
         set.add(StandardSocketOptions.SO_RCVBUF);
         set.add(StandardSocketOptions.SO_REUSEADDR);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/org/jcp/xml/dsig/internal/dom/Policy.java openjdk-boot/jdk/src/share/classes/org/jcp/xml/dsig/internal/dom/Policy.java
--- openjdk-boot.orig/jdk/src/share/classes/org/jcp/xml/dsig/internal/dom/Policy.java	2018-05-20 04:38:34.320809575 +0100
+++ openjdk-boot/jdk/src/share/classes/org/jcp/xml/dsig/internal/dom/Policy.java	2018-05-20 04:52:08.187912873 +0100
@@ -46,11 +46,11 @@
 public final class Policy {
 
     // all restrictions are initialized to be unconstrained
-    private static Set<URI> disallowedAlgs = new HashSet<>();
+    private static Set<URI> disallowedAlgs = new HashSet<URI>();
     private static int maxTrans = Integer.MAX_VALUE;
     private static int maxRefs = Integer.MAX_VALUE;
-    private static Set<String> disallowedRefUriSchemes = new HashSet<>();
-    private static Map<String, Integer> minKeyMap = new HashMap<>();
+    private static Set<String> disallowedRefUriSchemes = new HashSet<String>();
+    private static Map<String, Integer> minKeyMap = new HashMap<String, Integer>();
     private static boolean noDuplicateIds = false;
     private static boolean noRMLoops = false;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/awt/im/ExecutableInputMethodManager.java openjdk-boot/jdk/src/share/classes/sun/awt/im/ExecutableInputMethodManager.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/awt/im/ExecutableInputMethodManager.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/awt/im/ExecutableInputMethodManager.java	2018-05-20 04:52:08.187912873 +0100
@@ -96,7 +96,7 @@
     // IM preference stuff
     private static final String preferredIMNode = "/sun/awt/im/preferredInputMethod";
     private static final String descriptorKey = "descriptor";
-    private Hashtable<String, InputMethodLocator> preferredLocatorCache = new Hashtable<>();
+    private Hashtable<String, InputMethodLocator> preferredLocatorCache = new Hashtable<String, InputMethodLocator>();
     private Preferences userRoot;
 
     ExecutableInputMethodManager() {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/awt/im/InputContext.java openjdk-boot/jdk/src/share/classes/sun/awt/im/InputContext.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/awt/im/InputContext.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/awt/im/InputContext.java	2018-05-20 04:52:08.187912873 +0100
@@ -552,10 +552,10 @@
 
             // keep the input method instance around for future use
             if (usedInputMethods == null) {
-                usedInputMethods = new HashMap<>(5);
+                usedInputMethods = new HashMap<InputMethodLocator, InputMethod>(5);
             }
             if (perInputMethodState == null) {
-                perInputMethodState = new HashMap<>(5);
+                perInputMethodState = new HashMap<InputMethod, Boolean>(5);
             }
             usedInputMethods.put(inputMethodLocator.deriveLocator(null), inputMethod);
             perInputMethodState.put(inputMethod,
@@ -924,7 +924,7 @@
         // method becomes the current one.
         if (requester != inputMethod) {
             if (perInputMethodState == null) {
-                perInputMethodState = new HashMap<>(5);
+                perInputMethodState = new HashMap<InputMethod, Boolean>(5);
             }
             perInputMethodState.put(requester, Boolean.valueOf(enable));
             return;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/font/CreatedFontTracker.java openjdk-boot/jdk/src/share/classes/sun/font/CreatedFontTracker.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/font/CreatedFontTracker.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/font/CreatedFontTracker.java	2018-05-20 04:52:08.187912873 +0100
@@ -109,7 +109,7 @@
      * Note that this only applies to createFont() from an InputStream object.
      */
     private static class TempFileDeletionHook {
-        private static HashMap<File, OutputStream> files = new HashMap<>();
+        private static HashMap<File, OutputStream> files = new HashMap<File, OutputStream>();
 
         private static Thread t = null;
         static void init() {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/invoke/util/ValueConversions.java openjdk-boot/jdk/src/share/classes/sun/invoke/util/ValueConversions.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/invoke/util/ValueConversions.java	2018-05-20 04:38:34.988798987 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/invoke/util/ValueConversions.java	2018-05-20 04:52:08.187912873 +0100
@@ -60,7 +60,7 @@
         EnumMap<Wrapper, MethodHandle>[] caches
                 = (EnumMap<Wrapper, MethodHandle>[]) new EnumMap<?,?>[n];
         for (int i = 0; i < n; i++)
-            caches[i] = new EnumMap<>(Wrapper.class);
+	  caches[i] = new EnumMap<Wrapper, MethodHandle>(Wrapper.class);
         return caches;
     }
 
@@ -943,7 +943,7 @@
                                   Object a8, Object a9)
                 { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
     private static MethodHandle[] makeArrays() {
-        ArrayList<MethodHandle> mhs = new ArrayList<>();
+        ArrayList<MethodHandle> mhs = new ArrayList<MethodHandle>();
         for (;;) {
             MethodHandle mh = findCollector("array", mhs.size(), Object[].class);
             if (mh == null)  break;
@@ -999,7 +999,7 @@
                                   Object a8, Object a9)
                 { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }
     private static MethodHandle[] makeFillArrays() {
-        ArrayList<MethodHandle> mhs = new ArrayList<>();
+        ArrayList<MethodHandle> mhs = new ArrayList<MethodHandle>();
         mhs.add(null);  // there is no empty fill; at least a0 is required
         for (;;) {
             MethodHandle mh = findCollector("fillArray", mhs.size(), Object[].class, Integer.class, Object[].class);
@@ -1200,7 +1200,7 @@
                                      Object a8, Object a9)
                 { return makeList(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
     private static MethodHandle[] makeLists() {
-        ArrayList<MethodHandle> mhs = new ArrayList<>();
+        ArrayList<MethodHandle> mhs = new ArrayList<MethodHandle>();
         for (;;) {
             MethodHandle mh = findCollector("list", mhs.size(), List.class);
             if (mh == null)  break;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/io/CharacterEncoding.java openjdk-boot/jdk/src/share/classes/sun/io/CharacterEncoding.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/io/CharacterEncoding.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/io/CharacterEncoding.java	2018-05-20 04:52:08.187912873 +0100
@@ -54,7 +54,7 @@
     private static volatile boolean installedAll;
 
     static {
-        aliasTable = new HashMap<>(460, 1.0f);                    /* MDA */
+        aliasTable = new HashMap<String,String>(460, 1.0f);                    /* MDA */
 
         aliasTable.put("us-ascii",              "ASCII");
         aliasTable.put("ascii",                 "ASCII");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/io/Converters.java openjdk-boot/jdk/src/share/classes/sun/io/Converters.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/io/Converters.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/io/Converters.java	2018-05-20 04:52:08.187912873 +0100
@@ -120,7 +120,7 @@
 
     private static Class<?> cache(int type, Object encoding, Class<?> c) {
         SoftReference<Object[]>[] srs = classCache[type];
-        srs[CACHE_SIZE - 1] = new SoftReference<>(new Object[] { c, encoding });
+        srs[CACHE_SIZE - 1] = new SoftReference<Object[]>(new Object[] { c, encoding });
         moveToFront(srs, CACHE_SIZE - 1);
         return c;
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/java2d/cmm/lcms/LCMSProfile.java openjdk-boot/jdk/src/share/classes/sun/java2d/cmm/lcms/LCMSProfile.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/java2d/cmm/lcms/LCMSProfile.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/java2d/cmm/lcms/LCMSProfile.java	2018-05-20 04:52:08.187912873 +0100
@@ -61,7 +61,7 @@
 
         TagCache(LCMSProfile p) {
             profile = p;
-            tags = new HashMap<>();
+            tags = new HashMap<Integer, TagData>();
         }
 
         TagData getTag(int sig) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/launcher/LauncherHelper.java openjdk-boot/jdk/src/share/classes/sun/launcher/LauncherHelper.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/launcher/LauncherHelper.java	2018-05-20 04:38:34.960799432 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/launcher/LauncherHelper.java	2018-05-20 04:52:08.187912873 +0100
@@ -171,7 +171,7 @@
     private static void printProperties(PrintStream ostream) {
         Properties p = System.getProperties();
         ostream.println(PROP_SETTINGS);
-        List<String> sortedPropertyKeys = new ArrayList<>();
+        List<String> sortedPropertyKeys = new ArrayList<String>();
         sortedPropertyKeys.addAll(p.stringPropertyNames());
         Collections.sort(sortedPropertyKeys);
         for (String x : sortedPropertyKeys) {
@@ -246,7 +246,7 @@
         }
         // Locale does not implement Comparable so we convert it to String
         // and sort it for pretty printing.
-        Set<String> sortedSet = new TreeSet<>();
+        Set<String> sortedSet = new TreeSet<String>();
         for (Locale l : tlocales) {
             sortedSet.add(l.toString());
         }
@@ -532,7 +532,7 @@
     }
 
     static String[] expandArgs(String[] argArray) {
-        List<StdArg> aList = new ArrayList<>();
+        List<StdArg> aList = new ArrayList<StdArg>();
         for (String x : argArray) {
             aList.add(new StdArg(x));
         }
@@ -540,7 +540,7 @@
     }
 
     static String[] expandArgs(List<StdArg> argList) {
-        ArrayList<String> out = new ArrayList<>();
+        ArrayList<String> out = new ArrayList<String>();
         if (trace) {
             System.err.println("Incoming arguments:");
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/ConnectorAddressLink.java openjdk-boot/jdk/src/share/classes/sun/management/ConnectorAddressLink.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/ConnectorAddressLink.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/ConnectorAddressLink.java	2018-05-20 04:52:08.187912873 +0100
@@ -168,7 +168,7 @@
             throw new IOException(iae.getMessage());
         }
         List<Counter> counters = new PerfInstrumentation(bb).getAllCounters();
-        Map<String, String> properties = new HashMap<>();
+        Map<String, String> properties = new HashMap<String, String>();
         for (Counter c : counters) {
             String name =  c.getName();
             if (name.startsWith(REMOTE_CONNECTOR_COUNTER_PREFIX) &&
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/counter/perf/PerfInstrumentation.java openjdk-boot/jdk/src/share/classes/sun/management/counter/perf/PerfInstrumentation.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/counter/perf/PerfInstrumentation.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/counter/perf/PerfInstrumentation.java	2018-05-20 04:52:08.187912873 +0100
@@ -73,7 +73,7 @@
         buffer.position(prologue.getEntryOffset());
         nextEntry = buffer.position();
         // rebuild all the counters
-        map = new TreeMap<>();
+        map = new TreeMap<String, Counter>();
     }
 
     boolean hasNext() {
@@ -154,7 +154,7 @@
                 map.put(c.getName(), c);
             }
         }
-        return new ArrayList<>(map.values());
+        return new ArrayList<Counter>(map.values());
     }
 
     public synchronized List<Counter> findByPattern(String patternString) {
@@ -167,7 +167,7 @@
 
         Pattern pattern = Pattern.compile(patternString);
         Matcher matcher = pattern.matcher("");
-        List<Counter> matches = new ArrayList<>();
+        List<Counter> matches = new ArrayList<Counter>();
 
 
         for (Map.Entry<String,Counter> me: map.entrySet()) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/Flag.java openjdk-boot/jdk/src/share/classes/sun/management/Flag.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/Flag.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/Flag.java	2018-05-20 04:52:08.187912873 +0100
@@ -91,7 +91,7 @@
         Flag[] flags = new Flag[numFlags];
         int count = getFlags(names, flags, numFlags);
 
-        List<Flag> result = new ArrayList<>();
+        List<Flag> result = new ArrayList<Flag>();
         for (Flag f : flags) {
             if (f != null) {
                 result.add(f);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/GarbageCollectionNotifInfoCompositeData.java openjdk-boot/jdk/src/share/classes/sun/management/GarbageCollectionNotifInfoCompositeData.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/GarbageCollectionNotifInfoCompositeData.java	2018-05-20 04:38:34.896800446 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/GarbageCollectionNotifInfoCompositeData.java	2018-05-20 04:52:08.187912873 +0100
@@ -141,7 +141,7 @@
         GC_INFO
     };
     private static HashMap<GcInfoBuilder,CompositeType> compositeTypeByBuilder =
-        new HashMap<>();
+        new HashMap<GcInfoBuilder,CompositeType>();
 
     public static String getGcName(CompositeData cd) {
         String gcname = getString(cd, GC_NAME);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/HotspotCompilation.java openjdk-boot/jdk/src/share/classes/sun/management/HotspotCompilation.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/HotspotCompilation.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/HotspotCompilation.java	2018-05-20 04:52:08.187912873 +0100
@@ -136,7 +136,7 @@
 
     private void initCompilerCounters() {
         // Build a tree map of the current list of performance counters
-        counters = new TreeMap<>();
+        counters = new TreeMap<String, Counter>();
         for (Counter c: getInternalCompilerCounters()) {
             counters.put(c.getName(), c);
         }
@@ -198,7 +198,7 @@
     }
 
     public java.util.List<CompilerThreadStat> getCompilerThreadStats() {
-        List<CompilerThreadStat> list = new ArrayList<>(threads.length);
+        List<CompilerThreadStat> list = new ArrayList<CompilerThreadStat>(threads.length);
         int i = 0;
         if (threads[0] == null) {
             // no adaptor thread
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/HotSpotDiagnostic.java openjdk-boot/jdk/src/share/classes/sun/management/HotSpotDiagnostic.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/HotSpotDiagnostic.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/HotSpotDiagnostic.java	2018-05-20 04:52:08.187912873 +0100
@@ -69,7 +69,7 @@
 
     public List<VMOption> getDiagnosticOptions() {
         List<Flag> allFlags = Flag.getAllFlags();
-        List<VMOption> result = new ArrayList<>();
+        List<VMOption> result = new ArrayList<VMOption>();
         for (Flag flag : allFlags) {
             if (flag.isWriteable() && flag.isExternal()) {
                 result.add(flag.getVMOption());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/HotspotThread.java openjdk-boot/jdk/src/share/classes/sun/management/HotspotThread.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/HotspotThread.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/HotspotThread.java	2018-05-20 04:52:08.187912873 +0100
@@ -58,7 +58,7 @@
         String[] names = new String[count];
         long[] times = new long[count];
         int numThreads = getInternalThreadTimes0(names, times);
-        Map<String, Long> result = new HashMap<>(numThreads);
+        Map<String, Long> result = new HashMap<String, Long>(numThreads);
         for (int i = 0; i < numThreads; i++) {
             result.put(names[i], new Long(times[i]));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/jdp/JdpPacketReader.java openjdk-boot/jdk/src/share/classes/sun/management/jdp/JdpPacketReader.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/jdp/JdpPacketReader.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/jdp/JdpPacketReader.java	2018-05-20 04:52:08.187912873 +0100
@@ -120,7 +120,7 @@
 
         String key = null, value = null;
 
-        final Map<String, String> tmpMap = new HashMap<>();
+        final Map<String, String> tmpMap = new HashMap<String, String>();
         try {
             while (true) {
                 key = getEntry();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/jmxremote/ConnectorBootstrap.java openjdk-boot/jdk/src/share/classes/sun/management/jmxremote/ConnectorBootstrap.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/jmxremote/ConnectorBootstrap.java	2018-05-20 04:38:34.968799304 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/jmxremote/ConnectorBootstrap.java	2018-05-20 04:52:08.187912873 +0100
@@ -244,7 +244,7 @@
                 }
             }
 
-            final Set<String> principalsStr = new HashSet<>();
+            final Set<String> principalsStr = new HashSet<String>();
             for (Principal p2: principals) {
                 principalsStr.add(p2.getName());
             }
@@ -489,7 +489,7 @@
         try {
             // Export remote connector address and associated configuration
             // properties to the instrumentation buffer.
-            Map<String, String> properties = new HashMap<>();
+            Map<String, String> properties = new HashMap<String, String>();
             properties.put("remoteAddress", url.toString());
             properties.put("authenticate", useAuthenticationStr);
             properties.put("ssl", useSslStr);
@@ -515,7 +515,7 @@
         System.setProperty("java.rmi.server.randomIDs", "true");
 
         // This RMI server should not keep the VM alive
-        Map<String, Object> env = new HashMap<>();
+        Map<String, Object> env = new HashMap<String, Object>();
         env.put(RMIExporter.EXPORTER_ATTRIBUTE, new PermanentExporter());
         env.put(EnvHelp.CREDENTIAL_TYPES, new String[]{
             String[].class.getName(), String.class.getName()
@@ -763,7 +763,7 @@
 
         JMXServiceURL url = new JMXServiceURL("rmi", bindAddress, rmiPort);
 
-        Map<String, Object> env = new HashMap<>();
+        Map<String, Object> env = new HashMap<String, Object>();
 
         PermanentExporter exporter = new PermanentExporter();
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/ManagementFactoryHelper.java openjdk-boot/jdk/src/share/classes/sun/management/ManagementFactoryHelper.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/ManagementFactoryHelper.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/ManagementFactoryHelper.java	2018-05-20 04:52:08.191912810 +0100
@@ -110,7 +110,7 @@
 
     public static List<MemoryPoolMXBean> getMemoryPoolMXBeans() {
         MemoryPoolMXBean[] pools = MemoryImpl.getMemoryPools();
-        List<MemoryPoolMXBean> list = new ArrayList<>(pools.length);
+        List<MemoryPoolMXBean> list = new ArrayList<MemoryPoolMXBean>(pools.length);
         for (MemoryPoolMXBean p : pools) {
             list.add(p);
         }
@@ -119,7 +119,7 @@
 
     public static List<MemoryManagerMXBean> getMemoryManagerMXBeans() {
         MemoryManagerMXBean[]  mgrs = MemoryImpl.getMemoryManagers();
-        List<MemoryManagerMXBean> result = new ArrayList<>(mgrs.length);
+        List<MemoryManagerMXBean> result = new ArrayList<MemoryManagerMXBean>(mgrs.length);
         for (MemoryManagerMXBean m : mgrs) {
             result.add(m);
         }
@@ -128,7 +128,7 @@
 
     public static List<GarbageCollectorMXBean> getGarbageCollectorMXBeans() {
         MemoryManagerMXBean[]  mgrs = MemoryImpl.getMemoryManagers();
-        List<GarbageCollectorMXBean> result = new ArrayList<>(mgrs.length);
+        List<GarbageCollectorMXBean> result = new ArrayList<GarbageCollectorMXBean>(mgrs.length);
         for (MemoryManagerMXBean m : mgrs) {
             if (GarbageCollectorMXBean.class.isInstance(m)) {
                  result.add(GarbageCollectorMXBean.class.cast(m));
@@ -205,7 +205,7 @@
     private static List<BufferPoolMXBean> bufferPools = null;
     public static synchronized List<BufferPoolMXBean> getBufferPoolMXBeans() {
         if (bufferPools == null) {
-            bufferPools = new ArrayList<>(2);
+            bufferPools = new ArrayList<BufferPoolMXBean>(2);
             bufferPools.add(createBufferPoolMXBean(sun.misc.SharedSecrets.getJavaNioAccess()
                 .getDirectBufferPool()));
             bufferPools.add(createBufferPoolMXBean(sun.nio.ch.FileChannelImpl
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/MappedMXBeanType.java openjdk-boot/jdk/src/share/classes/sun/management/MappedMXBeanType.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/MappedMXBeanType.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/MappedMXBeanType.java	2018-05-20 04:52:08.191912810 +0100
@@ -62,7 +62,7 @@
 @SuppressWarnings("unchecked")
 public abstract class MappedMXBeanType {
     private static final WeakHashMap<Type,MappedMXBeanType> convertedTypes =
-        new WeakHashMap<>();
+        new WeakHashMap<Type,MappedMXBeanType>();
 
     boolean  isBasicType = false;
     OpenType<?> openType = inProgress;
@@ -299,7 +299,7 @@
                 throw ode;
             }
 
-            openType = new ArrayType<>(dim, baseElementType.getOpenType());
+            openType = new ArrayType<OpenType<?>>(dim, baseElementType.getOpenType());
         }
 
         protected ArrayMXBeanType() {
@@ -395,7 +395,7 @@
                 throw ode;
             }
 
-            openType = new ArrayType<>(dim, baseElementType.getOpenType());
+            openType = new ArrayType<OpenType<?>>(dim, baseElementType.getOpenType());
         }
 
         Type getJavaType() {
@@ -445,7 +445,7 @@
                 ode.initCause(e);
                 throw ode;
             }
-            openType = new ArrayType<>(1, paramType.getOpenType());
+            openType = new ArrayType<OpenType<?>>(1, paramType.getOpenType());
         }
 
         Type getJavaType() {
@@ -473,7 +473,7 @@
             throws OpenDataException, InvalidObjectException {
 
             final Object[] openArray = (Object[]) data;
-            List<Object> result = new ArrayList<>(openArray.length);
+            List<Object> result = new ArrayList<Object>(openArray.length);
             for (Object o : openArray) {
                 result.add(paramType.toJavaTypeData(o));
             }
@@ -560,7 +560,7 @@
 
             final TabularData td = (TabularData) data;
 
-            Map<Object, Object> result = new HashMap<>();
+            Map<Object, Object> result = new HashMap<Object, Object>();
             for (CompositeData row : (Collection<CompositeData>) td.values()) {
                 Object key = keyType.toJavaTypeData(row.get(KEY));
                 Object value = valueType.toJavaTypeData(row.get(VALUE));
@@ -639,8 +639,8 @@
                             return javaClass.getMethods();
                         }
                     });
-                final List<String> names = new ArrayList<>();
-                final List<OpenType<?>> types = new ArrayList<>();
+                final List<String> names = new ArrayList<String>();
+                final List<OpenType<?>> types = new ArrayList<OpenType<?>>();
 
                 /* Select public methods that look like "T getX()" or "boolean
                    isX()", where T is not void and X is not the empty
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/NotificationEmitterSupport.java openjdk-boot/jdk/src/share/classes/sun/management/NotificationEmitterSupport.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/NotificationEmitterSupport.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/NotificationEmitterSupport.java	2018-05-20 04:52:08.191912810 +0100
@@ -71,7 +71,7 @@
            efficient solution would be to clone the listener list
            every time a notification is sent.  */
         synchronized (listenerLock) {
-            List<ListenerInfo> newList = new ArrayList<>(listenerList.size() + 1);
+            List<ListenerInfo> newList = new ArrayList<ListenerInfo>(listenerList.size() + 1);
             newList.addAll(listenerList);
             newList.add(new ListenerInfo(listener, filter, handback));
             listenerList = newList;
@@ -82,7 +82,7 @@
         throws ListenerNotFoundException {
 
         synchronized (listenerLock) {
-            List<ListenerInfo> newList = new ArrayList<>(listenerList);
+            List<ListenerInfo> newList = new ArrayList<ListenerInfo>(listenerList);
             /* We scan the list of listeners in reverse order because
                in forward order we would have to repeat the loop with
                the same index after a remove.  */
@@ -106,7 +106,7 @@
         boolean found = false;
 
         synchronized (listenerLock) {
-            List<ListenerInfo> newList = new ArrayList<>(listenerList);
+            List<ListenerInfo> newList = new ArrayList<ListenerInfo>(listenerList);
             final int size = newList.size();
             for (int i = 0; i < size; i++) {
                 ListenerInfo li =  newList.get(i);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/management/RuntimeImpl.java openjdk-boot/jdk/src/share/classes/sun/management/RuntimeImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/management/RuntimeImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/management/RuntimeImpl.java	2018-05-20 04:52:08.191912810 +0100
@@ -128,7 +128,7 @@
 
     public Map<String,String> getSystemProperties() {
         Properties sysProps = System.getProperties();
-        Map<String,String> map = new HashMap<>();
+        Map<String,String> map = new HashMap<String,String>();
 
         // Properties.entrySet() does not include the entries in
         // the default properties.  So use Properties.stringPropertyNames()
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/misc/ObjectInputFilter.java openjdk-boot/jdk/src/share/classes/sun/misc/ObjectInputFilter.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/misc/ObjectInputFilter.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/misc/ObjectInputFilter.java	2018-05-20 04:52:08.191912810 +0100
@@ -444,7 +444,7 @@
                 maxStreamBytes = Long.MAX_VALUE;
 
                 String[] patterns = pattern.split(";");
-                filters = new ArrayList<>(patterns.length);
+                filters = new ArrayList<GlobalFilter>(patterns.length);
                 for (int i = 0; i < patterns.length; i++) {
                     String p = patterns[i];
                     int nameLen = p.length();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/RegisteredDomain.java openjdk-boot/jdk/src/share/classes/sun/net/RegisteredDomain.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/RegisteredDomain.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/RegisteredDomain.java	2018-05-20 04:52:08.191912810 +0100
@@ -118,8 +118,8 @@
 private static Set<String>  usSubStateSet = new HashSet<String>(Arrays.asList("state",
                 "lib", "k12", "cc", "tec", "gen", "cog", "mus", "dst"));
 
-private static Map<String,Set<String>> topMap = new HashMap<>();
-private static Map<String,Set<String>> top3Map = new HashMap<>();
+private static Map<String,Set<String>> topMap = new HashMap<String,Set<String>>();
+private static Map<String,Set<String>> top3Map = new HashMap<String,Set<String>>();
 
 static {
     /*
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/spi/nameservice/dns/DNSNameService.java openjdk-boot/jdk/src/share/classes/sun/net/spi/nameservice/dns/DNSNameService.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/spi/nameservice/dns/DNSNameService.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/spi/nameservice/dns/DNSNameService.java	2018-05-20 04:52:08.191912810 +0100
@@ -52,7 +52,7 @@
 
     // Per-thread soft cache of the last temporary context
     private static ThreadLocal<SoftReference<ThreadContext>> contextRef =
-            new ThreadLocal<>();
+            new ThreadLocal<SoftReference<ThreadContext>>();
 
     // Simple class to encapsulate the temporary context
     private static class ThreadContext {
@@ -99,7 +99,7 @@
 
         // new thread context needs to be created
         if (thrCtxt == null) {
-            final Hashtable<String,Object> env = new Hashtable<>();
+            final Hashtable<String,Object> env = new Hashtable<String,Object>();
             env.put("java.naming.factory.initial",
                     "com.sun.jndi.dns.DnsContextFactory");
 
@@ -165,7 +165,7 @@
                                       final String[] ids, int depth)
             throws UnknownHostException
     {
-        ArrayList<String> results = new ArrayList<>();
+        ArrayList<String> results = new ArrayList<String>();
         Attributes attrs;
 
         // do the query
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/TransferProtocolClient.java openjdk-boot/jdk/src/share/classes/sun/net/TransferProtocolClient.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/TransferProtocolClient.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/TransferProtocolClient.java	2018-05-20 04:52:08.191912810 +0100
@@ -42,7 +42,7 @@
 
     /** Array of strings (usually 1 entry) for the last reply
         from the server. */
-    protected Vector<String> serverResponse = new Vector<>(1);
+    protected Vector<String> serverResponse = new Vector<String>(1);
 
     /** code for last reply */
     protected int       lastReplyCode;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationHeader.java openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationHeader.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationHeader.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationHeader.java	2018-05-20 04:52:08.191912810 +0100
@@ -139,7 +139,7 @@
         this.dontUseNegotiate = dontUseNegotiate;
         this.rsp = response;
         this.hdrname = hdrname;
-        this.schemes = new HashMap<>();
+        this.schemes = new HashMap<String, SchemeMapValue>();
         parse(disabledSchemes);
     }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/AuthenticationInfo.java	2018-05-20 04:52:08.191912810 +0100
@@ -120,7 +120,7 @@
      * at the same time, then all but the first will block until
      * the first completes its authentication.
      */
-    static private HashMap<String,Thread> requests = new HashMap<>();
+    static private HashMap<String,Thread> requests = new HashMap<String,Thread>();
 
     /* check if a request for this destination is in progress
      * return false immediately if not. Otherwise block until
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/HttpURLConnection.java openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/HttpURLConnection.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/HttpURLConnection.java	2018-05-20 04:38:34.896800446 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/HttpURLConnection.java	2018-05-20 04:52:08.191912810 +0100
@@ -224,7 +224,7 @@
         if (list == null || list.isEmpty())
             return Collections.emptySet();
 
-        Set<String> s = new HashSet<>();
+        Set<String> s = new HashSet<String>();
         String[] parts = list.split("\\s*,\\s*");
         for (String part : parts)
             s.add(part.toLowerCase(Locale.ROOT));
@@ -2739,7 +2739,7 @@
         if (filteredHeaders != null)
             return filteredHeaders;
 
-        Map<String, List<String>> headers, tmpMap = new HashMap<>();
+        Map<String, List<String>> headers, tmpMap = new HashMap<String, List<String>>();
 
         if (cachedHeaders != null)
             headers = cachedHeaders.getHeaders();
@@ -2748,7 +2748,7 @@
 
         for (Map.Entry<String, List<String>> e: headers.entrySet()) {
             String key = e.getKey();
-            List<String> values = e.getValue(), filteredVals = new ArrayList<>();
+            List<String> values = e.getValue(), filteredVals = new ArrayList<String>();
             for (String value : values) {
                 String fVal = filterHeaderField(key, value);
                 if (fVal != null)
@@ -2930,7 +2930,7 @@
          */
         Map<String, List<String>> userCookiesMap = null;
         if (userCookies != null || userCookies2 != null) {
-            userCookiesMap = new HashMap<>();
+            userCookiesMap = new HashMap<String, List<String>>();
             if (userCookies != null) {
                 userCookiesMap.put("Cookie", Arrays.asList(userCookies));
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/NegotiateAuthentication.java openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/NegotiateAuthentication.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/www/protocol/http/NegotiateAuthentication.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/www/protocol/http/NegotiateAuthentication.java	2018-05-20 04:52:08.191912810 +0100
@@ -128,7 +128,7 @@
      */
     private static synchronized boolean isSupportedImpl(HttpCallerInfo hci) {
         if (supported == null) {
-            supported = new HashMap<>();
+            supported = new HashMap<String, Boolean>();
         }
         String hostname = hci.host;
         hostname = hostname.toLowerCase();
@@ -145,7 +145,7 @@
                 cache = new ThreadLocal<HashMap<String, Negotiator>>() {
                     @Override
                     protected HashMap<String, Negotiator> initialValue() {
-                        return new HashMap<>();
+                        return new HashMap<String, Negotiator>();
                     }
                 };
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/net/www/URLConnection.java openjdk-boot/jdk/src/share/classes/sun/net/www/URLConnection.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/net/www/URLConnection.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/net/www/URLConnection.java	2018-05-20 04:52:08.191912810 +0100
@@ -234,7 +234,7 @@
         url = null;
     }
 
-    private static HashMap<String,Void> proxiedHosts = new HashMap<>();
+    private static HashMap<String,Void> proxiedHosts = new HashMap<String,Void>();
 
     public synchronized static void setProxiedHost(String host) {
         proxiedHosts.put(host.toLowerCase(), null);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/cs/AbstractCharsetProvider.java openjdk-boot/jdk/src/share/classes/sun/nio/cs/AbstractCharsetProvider.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/cs/AbstractCharsetProvider.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/cs/AbstractCharsetProvider.java	2018-05-20 04:52:08.191912810 +0100
@@ -49,22 +49,22 @@
     /* Maps canonical names to class names
      */
     private Map<String,String> classMap
-        = new TreeMap<>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
+        = new TreeMap<String,String>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
 
     /* Maps alias names to canonical names
      */
     private Map<String,String> aliasMap
-        = new TreeMap<>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
+        = new TreeMap<String,String>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
 
     /* Maps canonical names to alias-name arrays
      */
     private Map<String,String[]> aliasNameMap
-        = new TreeMap<>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
+        = new TreeMap<String,String[]>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
 
     /* Maps canonical names to soft references that hold cached instances
      */
     private Map<String,SoftReference<Charset>> cache
-        = new TreeMap<>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
+        = new TreeMap<String,SoftReference<Charset>>(ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
 
     private String packagePrefix;
 
@@ -167,7 +167,7 @@
         final ArrayList<String> ks;
         synchronized (this) {
             init();
-            ks = new ArrayList<>(classMap.keySet());
+            ks = new ArrayList<String>(classMap.keySet());
         }
 
         return new Iterator<Charset>() {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractAclFileAttributeView.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractAclFileAttributeView.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractAclFileAttributeView.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractAclFileAttributeView.java	2018-05-20 04:52:08.191912810 +0100
@@ -84,7 +84,7 @@
             throw new IllegalArgumentException("'" + name() + ":" +
                 attribute + "' not recognized");
         }
-        Map<String,Object> result = new HashMap<>(2);
+        Map<String,Object> result = new HashMap<String,Object>(2);
         if (acl)
             result.put(ACL_NAME, getAcl());
         if (owner)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java	2018-05-20 04:52:08.191912810 +0100
@@ -89,8 +89,8 @@
      * Used to build a map of attribute name/values.
      */
     static class AttributesBuilder {
-        private Set<String> names = new HashSet<>();
-        private Map<String,Object> map = new HashMap<>();
+        private Set<String> names = new HashSet<String>();
+        private Map<String,Object> map = new HashMap<String,Object>();
         private boolean copyAll;
 
         private AttributesBuilder(Set<String> allowed, String[] requested) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractPoller.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractPoller.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractPoller.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractPoller.java	2018-05-20 04:52:08.191912810 +0100
@@ -102,7 +102,7 @@
             throw new NullPointerException();
         if (events.length == 0)
             throw new IllegalArgumentException("No events to register");
-        Set<WatchEvent.Kind<?>> eventSet = new HashSet<>(events.length);
+        Set<WatchEvent.Kind<?>> eventSet = new HashSet<WatchEvent.Kind<?>>(events.length);
         for (WatchEvent.Kind<?> event: events) {
             // standard events
             if (event == StandardWatchEventKinds.ENTRY_CREATE ||
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java	2018-05-20 04:52:08.191912810 +0100
@@ -77,7 +77,7 @@
         throws IOException
     {
         // names of attributes to return
-        List<String> names = new ArrayList<>();
+        List<String> names = new ArrayList<String>();
         for (String name: attributes) {
             if (name.equals("*")) {
                 names = list();
@@ -90,7 +90,7 @@
         }
 
         // read each value and return in map
-        Map<String,Object> result = new HashMap<>();
+        Map<String,Object> result = new HashMap<String,Object>();
         for (String name: names) {
             int size = size(name);
             byte[] buf = new byte[size];
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java	2018-05-20 04:52:08.191912810 +0100
@@ -71,7 +71,7 @@
 
     @Override
     public Map<String,Object> readAttributes(String[] attributes) throws IOException {
-        Map<String,Object> result = new HashMap<>();
+        Map<String,Object> result = new HashMap<String,Object>();
         for (String attribute: attributes) {
             if (attribute.equals("*") || attribute.equals(OWNER_NAME)) {
                 result.put(OWNER_NAME, getOwner());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/Util.java openjdk-boot/jdk/src/share/classes/sun/nio/fs/Util.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/nio/fs/Util.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/nio/fs/Util.java	2018-05-20 04:52:08.191912810 +0100
@@ -63,7 +63,7 @@
      * Returns a Set containing the given elements.
      */
     static <E> Set<E> newSet(E... elements) {
-        HashSet<E> set = new HashSet<>();
+        HashSet<E> set = new HashSet<E>();
         for (E e: elements) {
             set.add(e);
         }
@@ -75,7 +75,7 @@
      * the given elements.
      */
     static <E> Set<E> newSet(Set<E> other, E... elements) {
-        HashSet<E> set = new HashSet<>(other);
+        HashSet<E> set = new HashSet<E>(other);
         for (E e: elements) {
             set.add(e);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java openjdk-boot/jdk/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	2018-05-20 04:38:34.320809575 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	2018-05-20 04:52:08.191912810 +0100
@@ -442,7 +442,7 @@
 
         Map<String, Class<?>> memberTypes = annotationType.memberTypes();
         // consistent with runtime Map type
-        Map<String, Object> mv = new LinkedHashMap<>();
+        Map<String, Object> mv = new LinkedHashMap<String, Object>();
 
         // If there are annotation members without values, that
         // situation is handled by the invoke method.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/reflect/generics/parser/SignatureParser.java openjdk-boot/jdk/src/share/classes/sun/reflect/generics/parser/SignatureParser.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/reflect/generics/parser/SignatureParser.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/reflect/generics/parser/SignatureParser.java	2018-05-20 04:52:08.191912810 +0100
@@ -229,7 +229,7 @@
      *     "<" FormalTypeParameter+ ">"
      */
     private FormalTypeParameter[] parseFormalTypeParameters(){
-        List<FormalTypeParameter> ftps =  new ArrayList<>(3);
+        List<FormalTypeParameter> ftps =  new ArrayList(3);
         assert(current() == '<'); // should not have been called at all
         if (current() != '<') { throw error("expected '<'");}
         advance();
@@ -308,7 +308,7 @@
         assert(current() == 'L');
         if (current() != 'L') { throw error("expected a class type");}
         advance();
-        List<SimpleClassTypeSignature> scts = new ArrayList<>(5);
+        List<SimpleClassTypeSignature> scts = new ArrayList(5);
         scts.add(parsePackageNameAndSimpleClassTypeSignature());
 
         parseClassTypeSignatureSuffix(scts);
@@ -391,7 +391,7 @@
      *     "<" TypeArgument+ ">"
      */
     private TypeArgument[] parseTypeArguments() {
-        List<TypeArgument> tas = new ArrayList<>(3);
+        List<TypeArgument> tas = new ArrayList(3);
         assert(current() == '<');
         if (current() != '<') { throw error("expected '<'");}
         advance();
@@ -529,7 +529,7 @@
      *     ":" FieldTypeSignature
      */
     private FieldTypeSignature[] parseBounds() {
-        List<FieldTypeSignature> fts = new ArrayList<>(3);
+        List<FieldTypeSignature> fts = new ArrayList(3);
 
         if (current() == ':') {
             advance();
@@ -557,7 +557,7 @@
      *     ClassTypeSignature
      */
     private ClassTypeSignature[] parseSuperInterfaces() {
-        List<ClassTypeSignature> cts = new ArrayList<>(5);
+        List<ClassTypeSignature> cts = new ArrayList(5);
         while(current() == 'L') {
             cts.add(parseClassTypeSignature());
         }
@@ -592,7 +592,7 @@
 
     // TypeSignature*
     private TypeSignature[] parseZeroOrMoreTypeSignatures() {
-        List<TypeSignature> ts = new ArrayList<>();
+        List<TypeSignature> ts = new ArrayList();
         boolean stop = false;
         while (!stop) {
             switch(current()) {
@@ -631,7 +631,7 @@
 
     // ThrowSignature*
     private FieldTypeSignature[] parseZeroOrMoreThrowsSignatures(){
-        List<FieldTypeSignature> ets = new ArrayList<>(3);
+        List<FieldTypeSignature> ets = new ArrayList(3);
         while( current() == '^') {
             ets.add(parseThrowsSignature());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/registry/RegistryImpl.java openjdk-boot/jdk/src/share/classes/sun/rmi/registry/RegistryImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/registry/RegistryImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/registry/RegistryImpl.java	2018-05-20 04:52:08.191912810 +0100
@@ -84,9 +84,9 @@
     /* indicate compatibility with JDK 1.1.x version of class */
     private static final long serialVersionUID = 4666870661827494597L;
     private Hashtable<String, Remote> bindings
-        = new Hashtable<>(101);
+        = new Hashtable<String, Remote>(101);
     private static Hashtable<InetAddress, InetAddress> allowedAccessCache
-        = new Hashtable<>(3);
+        = new Hashtable<InetAddress, InetAddress>(3);
     private static RegistryImpl registry;
     private static ObjID id = new ObjID(ObjID.REGISTRY_ID);
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/rmic/BatchEnvironment.java openjdk-boot/jdk/src/share/classes/sun/rmi/rmic/BatchEnvironment.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/rmic/BatchEnvironment.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/rmic/BatchEnvironment.java	2018-05-20 04:52:08.191912810 +0100
@@ -160,7 +160,7 @@
     }
 
     /** list of generated source files created in this environment */
-    private Vector<File> generatedFiles = new Vector<>();
+    private Vector<File> generatedFiles = new Vector<File>();
 
     /**
      * Remember a generated source file generated so that it
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/rmic/Main.java openjdk-boot/jdk/src/share/classes/sun/rmi/rmic/Main.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/rmic/Main.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/rmic/Main.java	2018-05-20 04:52:08.191912810 +0100
@@ -184,7 +184,7 @@
         destDir = null;
         flags = F_WARNINGS;
         tm = System.currentTimeMillis();
-        classes = new Vector<>();
+        classes = new Vector<String>();
         nowrite = false;
         nocompile = false;
         keepGenerated = false;
@@ -192,7 +192,7 @@
         if (generatorArgs == null) {
             return false;
         }
-        generators = new Vector<>();
+        generators = new Vector<Generator>();
 
         // Pre-process command line for @file arguments
         try {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/rmic/RMIGenerator.java openjdk-boot/jdk/src/share/classes/sun/rmi/rmic/RMIGenerator.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/rmic/RMIGenerator.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/rmic/RMIGenerator.java	2018-05-20 04:52:08.195912747 +0100
@@ -61,7 +61,7 @@
  */
 public class RMIGenerator implements RMIConstants, Generator {
 
-    private static final Hashtable<String, Integer> versionOptions = new Hashtable<>();
+    private static final Hashtable<String, Integer> versionOptions = new Hashtable<String, Integer>();
     static {
         versionOptions.put("-v1.1", new Integer(STUB_VERSION_1_1));
         versionOptions.put("-vcompat", new Integer(STUB_VERSION_FAT));
@@ -651,7 +651,7 @@
      * that no exceptions need to be caught.
      */
     private Vector<ClassDefinition> computeUniqueCatchList(ClassDeclaration[] exceptions) {
-        Vector<ClassDefinition> uniqueList = new Vector<>();       // unique exceptions to catch
+        Vector<ClassDefinition> uniqueList = new Vector<ClassDefinition>();       // unique exceptions to catch
 
         uniqueList.addElement(defRuntimeException);
         uniqueList.addElement(defRemoteException);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/ActivationGroupImpl.java openjdk-boot/jdk/src/share/classes/sun/rmi/server/ActivationGroupImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/ActivationGroupImpl.java	2018-05-20 04:38:34.900800383 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/server/ActivationGroupImpl.java	2018-05-20 04:52:08.195912747 +0100
@@ -66,10 +66,10 @@
 
     /** maps persistent IDs to activated remote objects */
     private final Hashtable<ActivationID,ActiveEntry> active =
-        new Hashtable<>();
+        new Hashtable<ActivationID,ActiveEntry>();
     private boolean groupInactive = false;
     private final ActivationGroupID groupID;
-    private final List<ActivationID> lockedIDs = new ArrayList<>();
+    private final List<ActivationID> lockedIDs = new ArrayList<ActivationID>();
 
     /**
      * Creates a default activation group implementation.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/Activation.java openjdk-boot/jdk/src/share/classes/sun/rmi/server/Activation.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/Activation.java	2018-05-20 04:38:34.964799367 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/server/Activation.java	2018-05-20 04:52:08.195912747 +0100
@@ -149,10 +149,10 @@
 
     /** maps activation id to its respective group id */
     private Map<ActivationID,ActivationGroupID> idTable =
-        new ConcurrentHashMap<>();
+        new ConcurrentHashMap<ActivationID,ActivationGroupID>();
     /** maps group id to its GroupEntry groups */
     private Map<ActivationGroupID,GroupEntry> groupTable =
-        new ConcurrentHashMap<>();
+        new ConcurrentHashMap<ActivationGroupID,GroupEntry>();
 
     private byte majorVersion = MAJOR_VERSION;
     private byte minorVersion = MINOR_VERSION;
@@ -288,10 +288,10 @@
     {
         ois.defaultReadObject();
         if (! (groupTable instanceof ConcurrentHashMap)) {
-            groupTable = new ConcurrentHashMap<>(groupTable);
+            groupTable = new ConcurrentHashMap<ActivationGroupID,GroupEntry>(groupTable);
         }
         if (! (idTable instanceof ConcurrentHashMap)) {
-            idTable = new ConcurrentHashMap<>(idTable);
+            idTable = new ConcurrentHashMap<ActivationID,ActivationGroupID>(idTable);
         }
     }
 
@@ -844,8 +844,8 @@
         ActivationGroupDesc desc = null;
         ActivationGroupID groupID = null;
         long incarnation = 0;
-        Map<ActivationID,ObjectEntry> objects = new HashMap<>();
-        Set<ActivationID> restartSet = new HashSet<>();
+        Map<ActivationID,ObjectEntry> objects = new HashMap<ActivationID,ObjectEntry>();
+        Set<ActivationID> restartSet = new HashSet<ActivationID>();
 
         transient ActivationInstantiator group = null;
         transient int status = NORMAL;
@@ -1398,7 +1398,7 @@
         cmdenv = desc.getCommandEnvironment();
 
         // argv is the literal command to exec
-        List<String> argv = new ArrayList<>();
+        List<String> argv = new ArrayList<String>();
 
         // Command name/path
         argv.add((cmdenv != null && cmdenv.getCommandPath() != null)
@@ -2003,7 +2003,7 @@
             }
 
             String log = null;
-            List<String> childArgs = new ArrayList<>();
+            List<String> childArgs = new ArrayList<String>();
 
             /*
              * Parse arguments
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/LoaderHandler.java openjdk-boot/jdk/src/share/classes/sun/rmi/server/LoaderHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/LoaderHandler.java	2018-05-20 04:38:34.900800383 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/server/LoaderHandler.java	2018-05-20 04:52:08.195912747 +0100
@@ -114,11 +114,11 @@
      * garbage collected.
      */
     private static final HashMap<LoaderKey, LoaderEntry> loaderTable
-        = new HashMap<>(5);
+        = new HashMap<LoaderKey, LoaderEntry>(5);
 
     /** reference queue for cleared class loader entries */
     private static final ReferenceQueue<Loader> refQueue
-        = new ReferenceQueue<>();
+        = new ReferenceQueue<Loader>();
 
     /*
      * Disallow anyone from creating one of these.
@@ -781,7 +781,7 @@
 
     /** map from weak(key=string) to [URL[], soft(key)] */
     private static final Map<String, Object[]> pathToURLsCache
-        = new WeakHashMap<>(5);
+        = new WeakHashMap<String, Object[]>(5);
 
     /**
      * Convert an array of URL objects into a corresponding string
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/MarshalInputStream.java openjdk-boot/jdk/src/share/classes/sun/rmi/server/MarshalInputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/MarshalInputStream.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/server/MarshalInputStream.java	2018-05-20 04:52:08.195912747 +0100
@@ -76,14 +76,14 @@
 
     /** table to hold sun classes to which access is explicitly permitted */
     protected static Map<String, Class<?>> permittedSunClasses
-        = new HashMap<>(3);
+        = new HashMap<String, Class<?>>(3);
 
     /** if true, don't try superclass first in resolveClass() */
     private boolean skipDefaultResolveClass = false;
 
     /** callbacks to make when done() called: maps Object to Runnable */
     private final Map<Object, Runnable> doneCallbacks
-        = new HashMap<>(3);
+        = new HashMap<Object, Runnable>(3);
 
     /**
      * if true, load classes (if not available locally) only from the
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/UnicastServerRef.java openjdk-boot/jdk/src/share/classes/sun/rmi/server/UnicastServerRef.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/UnicastServerRef.java	2018-05-20 04:38:34.900800383 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/server/UnicastServerRef.java	2018-05-20 04:52:08.195912747 +0100
@@ -580,7 +580,7 @@
         HashToMethod_Maps() {}
 
         protected Map<Long,Method> computeValue(Class<?> remoteClass) {
-            Map<Long,Method> map = new HashMap<>();
+            Map<Long,Method> map = new HashMap<Long,Method>();
             for (Class<?> cl = remoteClass;
                  cl != null;
                  cl = cl.getSuperclass())
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/Util.java openjdk-boot/jdk/src/share/classes/sun/rmi/server/Util.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/Util.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/server/Util.java	2018-05-20 04:52:08.195912747 +0100
@@ -208,7 +208,7 @@
      * @throws  NullPointerException if remoteClass is null
      */
     private static Class<?>[] getRemoteInterfaces(Class<?> remoteClass) {
-        ArrayList<Class<?>> list = new ArrayList<>();
+        ArrayList<Class<?>> list = new ArrayList<Class<?>>();
         getRemoteInterfaces(list, remoteClass);
         return list.toArray(new Class<?>[list.size()]);
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/WeakClassHashMap.java openjdk-boot/jdk/src/share/classes/sun/rmi/server/WeakClassHashMap.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/server/WeakClassHashMap.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/server/WeakClassHashMap.java	2018-05-20 04:52:08.195912747 +0100
@@ -46,7 +46,7 @@
  **/
 public abstract class WeakClassHashMap<V> {
 
-    private Map<Class<?>,ValueCell<V>> internalMap = new WeakHashMap<>();
+    private Map<Class<?>,ValueCell<V>> internalMap = new WeakHashMap<Class<?>,ValueCell<V>>();
 
     protected WeakClassHashMap() { }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/ConnectionInputStream.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/ConnectionInputStream.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/ConnectionInputStream.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/ConnectionInputStream.java	2018-05-20 04:52:08.195912747 +0100
@@ -43,7 +43,7 @@
     private boolean dgcAckNeeded = false;
 
     /** Hashtable mapping Endpoints to lists of LiveRefs to register */
-    private Map<Endpoint, List<LiveRef>> incomingRefTable = new HashMap<>(5);
+    private Map<Endpoint, List<LiveRef>> incomingRefTable = new HashMap<Endpoint, List<LiveRef>>(5);
 
     /** identifier for gc ack*/
     private UID ackID;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/DGCAckHandler.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/DGCAckHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/DGCAckHandler.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/DGCAckHandler.java	2018-05-20 04:52:08.195912747 +0100
@@ -78,7 +78,7 @@
         Collections.synchronizedMap(new HashMap<UID,DGCAckHandler>());
 
     private final UID id;
-    private List<Object> objList = new ArrayList<>(); // null if released
+    private List<Object> objList = new ArrayList<Object>(); // null if released
     private Future<?> task = null;
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/DGCClient.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/DGCClient.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/DGCClient.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/DGCClient.java	2018-05-20 04:52:08.195912747 +0100
@@ -197,9 +197,9 @@
         private DGC dgc;
 
         /** table of refs held for endpoint: maps LiveRef to RefEntry */
-        private Map<LiveRef, RefEntry> refTable = new HashMap<>(5);
+        private Map<LiveRef, RefEntry> refTable = new HashMap<LiveRef, RefEntry>(5);
         /** set of RefEntry instances from last (failed) dirty call */
-        private Set<RefEntry> invalidRefs = new HashSet<>(5);
+        private Set<RefEntry> invalidRefs = new HashSet<RefEntry>(5);
 
         /** true if this entry has been removed from the global table */
         private boolean removed = false;
@@ -221,12 +221,12 @@
         private boolean interruptible = false;
 
         /** reference queue for phantom references */
-        private ReferenceQueue<LiveRef> refQueue = new ReferenceQueue<>();
+        private ReferenceQueue<LiveRef> refQueue = new ReferenceQueue<LiveRef>();
         /** set of clean calls that need to be made */
-        private Set<CleanRequest> pendingCleans = new HashSet<>(5);
+        private Set<CleanRequest> pendingCleans = new HashSet<CleanRequest>(5);
 
         /** global endpoint table: maps Endpoint to EndpointEntry */
-        private static Map<Endpoint,EndpointEntry> endpointTable = new HashMap<>(5);
+        private static Map<Endpoint,EndpointEntry> endpointTable = new HashMap<Endpoint,EndpointEntry>(5);
         /** handle for GC latency request (for future cancellation) */
         private static GC.LatencyRequest gcLatencyRequest = null;
 
@@ -303,7 +303,7 @@
                         refEntry = new RefEntry(refClone);
                         refTable.put(refClone, refEntry);
                         if (refsToDirty == null) {
-                            refsToDirty = new HashSet<>(5);
+                            refsToDirty = new HashSet<RefEntry>(5);
                         }
                         refsToDirty.add(refEntry);
                     }
@@ -591,7 +591,7 @@
                             needRenewal = true;
                             if (!invalidRefs.isEmpty()) {
                                 refsToDirty = invalidRefs;
-                                invalidRefs = new HashSet<>(5);
+                                invalidRefs = new HashSet<RefEntry>(5);
                             }
                             sequenceNum = getNextSequenceNum();
                         }
@@ -637,12 +637,12 @@
                 if (refEntry.isRefSetEmpty()) {
                     if (refEntry.hasDirtyFailed()) {
                         if (strongCleans == null) {
-                            strongCleans = new HashSet<>(5);
+                            strongCleans = new HashSet<RefEntry>(5);
                         }
                         strongCleans.add(refEntry);
                     } else {
                         if (normalCleans == null) {
-                            normalCleans = new HashSet<>(5);
+                            normalCleans = new HashSet<RefEntry>(5);
                         }
                         normalCleans.add(refEntry);
                     }
@@ -738,7 +738,7 @@
             /** LiveRef value for this entry (not a registered instance) */
             private LiveRef ref;
             /** set of phantom references to registered instances */
-            private Set<PhantomLiveRef> refSet = new HashSet<>(5);
+            private Set<PhantomLiveRef> refSet = new HashSet<PhantomLiveRef>(5);
             /** true if a dirty call containing this ref has failed */
             private boolean dirtyFailed = false;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/DGCImpl.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/DGCImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/DGCImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/DGCImpl.java	2018-05-20 04:52:08.195912747 +0100
@@ -94,7 +94,7 @@
     /** remote implementation of DGC interface for this VM */
     private static DGCImpl dgc;
     /** table that maps VMID to LeaseInfo */
-    private Map<VMID,LeaseInfo> leaseTable = new HashMap<>();
+    private Map<VMID,LeaseInfo> leaseTable = new HashMap<VMID,LeaseInfo>();
     /** checks for lease expiration */
     private Future<?> checker = null;
 
@@ -290,7 +290,7 @@
         long time = System.currentTimeMillis();
 
         /* List of vmids that need to be removed from the leaseTable */
-        List<LeaseInfo> toUnregister = new ArrayList<>();
+        List<LeaseInfo> toUnregister = new ArrayList<LeaseInfo>();
 
         /* Build a list of leaseInfo objects that need to have
          * targets removed from their notifySet.  Remove expired
@@ -432,7 +432,7 @@
     private static class LeaseInfo {
         VMID vmid;
         long expiration;
-        Set<Target> notifySet = new HashSet<>();
+        Set<Target> notifySet = new HashSet<Target>();
 
         LeaseInfo(VMID vmid, long lease) {
             this.vmid = vmid;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/ObjectTable.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/ObjectTable.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/ObjectTable.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/ObjectTable.java	2018-05-20 04:52:08.195912747 +0100
@@ -62,9 +62,9 @@
 
     /** tables mapping to Target, keyed from ObjectEndpoint and impl object */
     private static final Map<ObjectEndpoint,Target> objTable =
-        new HashMap<>();
+        new HashMap<ObjectEndpoint,Target>();
     private static final Map<WeakRef,Target> implTable =
-        new HashMap<>();
+        new HashMap<WeakRef,Target>();
 
     /**
      * lock guarding keepAliveCount, reaper, and gcLatencyRequest.
@@ -79,7 +79,7 @@
     private static Thread reaper = null;
 
     /** queue notified when weak refs in the table are cleared */
-    static final ReferenceQueue<Object> reapQueue = new ReferenceQueue<>();
+    static final ReferenceQueue<Object> reapQueue = new ReferenceQueue<Object>();
 
     /** handle for GC latency request (for future cancellation) */
     private static GC.LatencyRequest gcLatencyRequest = null;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/proxy/CGIHandler.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/proxy/CGIHandler.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/proxy/CGIHandler.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/proxy/CGIHandler.java	2018-05-20 04:52:08.195912747 +0100
@@ -116,7 +116,7 @@
     /* construct table mapping command strings to handlers */
     private static Hashtable<String, CGICommandHandler> commandLookup;
     static {
-        commandLookup = new Hashtable<>();
+        commandLookup = new Hashtable<String, CGICommandHandler>();
         for (int i = 0; i < commands.length; ++ i)
             commandLookup.put(commands[i].getName(), commands[i]);
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/proxy/RMIMasterSocketFactory.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/proxy/RMIMasterSocketFactory.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/proxy/RMIMasterSocketFactory.java	2018-05-20 04:38:34.964799367 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/proxy/RMIMasterSocketFactory.java	2018-05-20 04:52:08.195912747 +0100
@@ -76,13 +76,13 @@
 
     /** table of hosts successfully connected to and the factory used */
     private Hashtable<String, RMISocketFactory> successTable =
-        new Hashtable<>();
+        new Hashtable<String, RMISocketFactory>();
 
     /** maximum number of hosts to remember successful connection to */
     private static final int MaxRememberedHosts = 64;
 
     /** list of the hosts in successTable in initial connection order */
-    private Vector<String> hostList = new Vector<>(MaxRememberedHosts);
+    private Vector<String> hostList = new Vector<String>(MaxRememberedHosts);
 
     /** default factory for initial use for direct socket connection */
     protected RMISocketFactory initialFactory = new RMIDirectSocketFactory();
@@ -97,7 +97,7 @@
      * socket connection fails.
      */
     public RMIMasterSocketFactory() {
-        altFactoryList = new Vector<>(2);
+        altFactoryList = new Vector<RMISocketFactory>(2);
         boolean setFactories = false;
 
         try {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/Target.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/Target.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/Target.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/Target.java	2018-05-20 04:52:08.195912747 +0100
@@ -54,10 +54,10 @@
     /** stub for remote object */
     private final Remote stub;
     /** set of clients that hold references to this target */
-    private final Vector<VMID> refSet = new Vector<>();
+    private final Vector<VMID> refSet = new Vector<VMID>();
     /** table that maps client endpoints to sequence numbers */
     private final Hashtable<VMID, SequenceEntry> sequenceTable =
-        new Hashtable<>(5);
+        new Hashtable<VMID, SequenceEntry>(5);
     /** access control context in which target was created */
     private final AccessControlContext acc;
     /** context class loader in which target was created */
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/tcp/ConnectionMultiplexer.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/tcp/ConnectionMultiplexer.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/tcp/ConnectionMultiplexer.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/tcp/ConnectionMultiplexer.java	2018-05-20 04:52:08.195912747 +0100
@@ -86,7 +86,7 @@
     private DataOutputStream dataOut;
 
     /** table holding currently open connection IDs and related info */
-    private Hashtable<Integer, MultiplexConnectionInfo> connectionTable = new Hashtable<>(7);
+    private Hashtable<Integer, MultiplexConnectionInfo> connectionTable = new Hashtable<Integer, MultiplexConnectionInfo>(7);
 
     /** number of currently open connections */
     private int numConnections = 0;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/tcp/TCPChannel.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/tcp/TCPChannel.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/tcp/TCPChannel.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/tcp/TCPChannel.java	2018-05-20 04:52:08.195912747 +0100
@@ -64,7 +64,7 @@
     private final TCPTransport tr;
     /** list of cached connections */
     private final List<TCPConnection> freeList =
-        new ArrayList<>();
+        new ArrayList<TCPConnection>();
     /** frees cached connections that have expired (guarded by freeList) */
     private Future<?> reaper = null;
 
@@ -480,7 +480,7 @@
     private TCPTransport transport;
 
     /** queue of connections to be accepted */
-    private List<Connection> queue = new ArrayList<>();
+    private List<Connection> queue = new ArrayList<Connection>();
 
     /** thread ID counter */
     private static int threadNum = 0;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/tcp/TCPEndpoint.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/tcp/TCPEndpoint.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/tcp/TCPEndpoint.java	2018-05-20 04:38:34.900800383 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/tcp/TCPEndpoint.java	2018-05-20 04:52:08.195912747 +0100
@@ -148,7 +148,7 @@
     // TBD: should this be a weak hash table?
     private static final
         Map<TCPEndpoint,LinkedList<TCPEndpoint>> localEndpoints =
-        new HashMap<>();
+        new HashMap<TCPEndpoint,LinkedList<TCPEndpoint>>();
 
     /**
      * Create an endpoint for a specified host and port.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/tcp/TCPTransport.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/tcp/TCPTransport.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/tcp/TCPTransport.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/tcp/TCPTransport.java	2018-05-20 04:52:08.195912747 +0100
@@ -129,7 +129,7 @@
 
     /** client host for the current thread's connection */
     private static final ThreadLocal<ConnectionHandler>
-        threadConnectionHandler = new ThreadLocal<>();
+        threadConnectionHandler = new ThreadLocal<ConnectionHandler>();
 
     /** an AccessControlContext with no permissions */
     private static final AccessControlContext NOPERMS_ACC;
@@ -147,7 +147,7 @@
     private ServerSocket server = null;
     /** table mapping endpoints to channels */
     private final Map<TCPEndpoint,Reference<TCPChannel>> channelTable =
-        new WeakHashMap<>();
+        new WeakHashMap<TCPEndpoint,Reference<TCPChannel>>();
 
     static final RMISocketFactory defaultSocketFactory =
         RMISocketFactory.getDefaultSocketFactory();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/Transport.java openjdk-boot/jdk/src/share/classes/sun/rmi/transport/Transport.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/rmi/transport/Transport.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/rmi/transport/Transport.java	2018-05-20 04:52:08.195912747 +0100
@@ -67,7 +67,7 @@
         Log.getLog("sun.rmi.transport.misc", "transport", Transport.logLevel);
 
     /** References the current transport when a call is being serviced */
-    private static final ThreadLocal<Transport> currentTransport = new ThreadLocal<>();
+    private static final ThreadLocal<Transport> currentTransport = new ThreadLocal<Transport>();
 
     /** ObjID for DGCImpl */
     private static final ObjID dgcID = new ObjID(ObjID.DGC_ID);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/AclEntryImpl.java openjdk-boot/jdk/src/share/classes/sun/security/acl/AclEntryImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/AclEntryImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/acl/AclEntryImpl.java	2018-05-20 04:52:08.195912747 +0100
@@ -36,7 +36,7 @@
  */
 public class AclEntryImpl implements AclEntry {
     private Principal user = null;
-    private Vector<Permission> permissionSet = new Vector<>(10, 10);
+    private Vector<Permission> permissionSet = new Vector<Permission>(10, 10);
     private boolean negative = false;
 
     /**
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/AclImpl.java openjdk-boot/jdk/src/share/classes/sun/security/acl/AclImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/AclImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/acl/AclImpl.java	2018-05-20 04:52:08.195912747 +0100
@@ -41,15 +41,15 @@
     // or principal.
     //
     private Hashtable<Principal, AclEntry> allowedUsersTable =
-                                        new Hashtable<>(23);
+        new Hashtable<Principal,AclEntry>(23);
     private Hashtable<Principal, AclEntry> allowedGroupsTable =
-                                        new Hashtable<>(23);
+        new Hashtable<Principal, AclEntry>(23);
     private Hashtable<Principal, AclEntry> deniedUsersTable =
-                                        new Hashtable<>(23);
+        new Hashtable<Principal, AclEntry>(23);
     private Hashtable<Principal, AclEntry> deniedGroupsTable =
-                                        new Hashtable<>(23);
+        new Hashtable<Principal, AclEntry>(23);
     private String aclName = null;
-    private Vector<Permission> zeroSet = new Vector<>(1,1);
+    private Vector<Permission> zeroSet = new Vector<Permission>(1,1);
 
 
     /**
@@ -294,7 +294,7 @@
     //
     private static Enumeration<Permission> union(Enumeration<Permission> e1,
                 Enumeration<Permission> e2) {
-        Vector<Permission> v = new Vector<>(20, 20);
+        Vector<Permission> v = new Vector<Permission>(20, 20);
 
         while (e1.hasMoreElements())
             v.addElement(e1.nextElement());
@@ -313,7 +313,7 @@
     //
     private Enumeration<Permission> subtract(Enumeration<Permission> e1,
                 Enumeration<Permission> e2) {
-        Vector<Permission> v = new Vector<>(20, 20);
+        Vector<Permission> v = new Vector<Permission>(20, 20);
 
         while (e1.hasMoreElements())
             v.addElement(e1.nextElement());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/GroupImpl.java openjdk-boot/jdk/src/share/classes/sun/security/acl/GroupImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/acl/GroupImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/acl/GroupImpl.java	2018-05-20 04:52:08.199912684 +0100
@@ -34,7 +34,7 @@
  * @author      Satish Dharmaraj
  */
 public class GroupImpl implements Group {
-    private Vector<Principal> groupMembers = new Vector<>(50, 100);
+    private Vector<Principal> groupMembers = new Vector<Principal>(50, 100);
     private String group;
 
     /**
@@ -131,7 +131,7 @@
         if (groupMembers.contains(member)) {
             return true;
         } else {
-            Vector<Group> alreadySeen = new Vector<>(10);
+            Vector<Group> alreadySeen = new Vector<Group>(10);
             return isMemberRecurse(member, alreadySeen);
         }
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/jca/ProviderList.java openjdk-boot/jdk/src/share/classes/sun/security/jca/ProviderList.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/jca/ProviderList.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/jca/ProviderList.java	2018-05-20 04:52:08.199912684 +0100
@@ -97,7 +97,7 @@
         if (providerList.getProvider(p.getName()) != null) {
             return providerList;
         }
-        List<ProviderConfig> list = new ArrayList<>
+        List<ProviderConfig> list = new ArrayList<ProviderConfig>
                                     (Arrays.asList(providerList.configs));
         int n = list.size();
         if ((position < 0) || (position > n)) {
@@ -161,7 +161,7 @@
      * Return a new ProviderList parsed from the java.security Properties.
      */
     private ProviderList() {
-        List<ProviderConfig> configList = new ArrayList<>();
+        List<ProviderConfig> configList = new ArrayList<ProviderConfig>();
         for (int i = 1; true; i++) {
             String entry = Security.getProperty("security.provider." + i);
             if (entry == null) {
@@ -201,7 +201,7 @@
      * possible recursion and deadlock during verification.
      */
     ProviderList getJarList(String[] jarClassNames) {
-        List<ProviderConfig> newConfigs = new ArrayList<>();
+        List<ProviderConfig> newConfigs = new ArrayList<ProviderConfig>();
         for (String className : jarClassNames) {
             ProviderConfig newConfig = new ProviderConfig(className);
             for (ProviderConfig config : configs) {
@@ -357,7 +357,7 @@
      */
     @Deprecated
     public List<Service> getServices(String type, List<String> algorithms) {
-        List<ServiceId> ids = new ArrayList<>();
+        List<ServiceId> ids = new ArrayList<ServiceId>();
         for (String alg : algorithms) {
             ids.add(new ServiceId(type, alg));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/jca/Providers.java openjdk-boot/jdk/src/share/classes/sun/security/jca/Providers.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/jca/Providers.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/jca/Providers.java	2018-05-20 04:52:08.199912684 +0100
@@ -37,7 +37,7 @@
 public class Providers {
 
     private static final ThreadLocal<ProviderList> threadLists =
-        new InheritableThreadLocal<>();
+        new InheritableThreadLocal<ProviderList>();
 
     // number of threads currently using thread-local provider lists
     // tracked to allow an optimization if == 0
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/jgss/krb5/Krb5Util.java openjdk-boot/jdk/src/share/classes/sun/security/jgss/krb5/Krb5Util.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/jgss/krb5/Krb5Util.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/jgss/krb5/Krb5Util.java	2018-05-20 04:52:08.199912684 +0100
@@ -251,7 +251,7 @@
         }
 
         public KerberosKey[] getKKeys() {
-                List<KerberosKey> keys = new ArrayList<>();
+                List<KerberosKey> keys = new ArrayList<KerberosKey>();
             for (KerberosKey k: kk) {
                 keys.add(k);
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/Config.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/Config.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/Config.java	2018-05-20 04:38:34.320809575 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/Config.java	2018-05-20 04:52:08.199912684 +0100
@@ -610,7 +610,7 @@
                 }
                 })));
                 String Line;
-                Vector<String> v = new Vector<>();
+                Vector<String> v = new Vector<String>();
                 String previous = null;
                 while ((Line = br.readLine()) != null) {
                     // ignore comments and blank line in the configuration file.
@@ -671,7 +671,7 @@
             throw new KrbException("I/O error while reading" +
                         " configuration file.");
         }
-        Hashtable<String,Object> table = new Hashtable<>();
+        Hashtable<String,Object> table = new Hashtable<String,Object>();
         for (int i = 0; i < v.size(); i++) {
             String line = v.elementAt(i).trim();
             if (line.equalsIgnoreCase("[realms]")) {
@@ -680,7 +680,7 @@
                     if ((count == v.size()) ||
                         (v.elementAt(count).startsWith("["))) {
                         Hashtable<String,Hashtable<String,Vector<String>>> temp =
-                            new Hashtable<>();
+                            new Hashtable<String,Hashtable<String,Vector<String>>>();
                         temp = parseRealmField(v, i + 1, count);
                         table.put("realms", temp);
                         i = count - 1;
@@ -693,7 +693,7 @@
                     if ((count == v.size()) ||
                         (v.elementAt(count).startsWith("["))) {
                         Hashtable<String,Hashtable<String,Vector<String>>> temp =
-                            new Hashtable<>();
+                            new Hashtable<String,Hashtable<String,Vector<String>>>();
                         temp = parseRealmField(v, i + 1, count);
                         table.put("capaths", temp);
                         i = count - 1;
@@ -845,7 +845,7 @@
      * Parses key-value pairs under a stanza name.
      */
     private Hashtable<String,String>  parseField(Vector<String> v, int start, int end) {
-        Hashtable<String,String> table = new Hashtable<>();
+      Hashtable<String,String> table = new Hashtable<String,String>();
         String line;
         for (int i = start; i < end; i++) {
             line = v.elementAt(i);
@@ -867,7 +867,7 @@
      * information for the realm given within a pair of braces.
      */
     private Hashtable<String,Hashtable<String,Vector<String>>> parseRealmField(Vector<String> v, int start, int end) {
-        Hashtable<String,Hashtable<String,Vector<String>>> table = new Hashtable<>();
+        Hashtable<String,Hashtable<String,Vector<String>>> table = new Hashtable<String,Hashtable<String,Vector<String>>>();
         String line;
         for (int i = start; i < end; i++) {
             line = v.elementAt(i).trim();
@@ -907,9 +907,9 @@
      * Parses key-value pairs within each braces under [realms].
      */
     private Hashtable<String,Vector<String>> parseRealmFieldEx(Vector<String> v, int start, int end) {
-        Hashtable<String,Vector<String>> table = new Hashtable<>();
-        Vector<String> keyVector = new Vector<>();
-        Vector<String> nameVector = new Vector<>();
+        Hashtable<String,Vector<String>> table = new Hashtable<String,Vector<String>>();
+        Vector<String> keyVector = new Vector<String>();
+        Vector<String> nameVector = new Vector<String>();
         String line = "";
         String key;
         for (int i = start; i < end; i++) {
@@ -1016,7 +1016,7 @@
             }
             st = new StringTokenizer(default_enctypes, delim);
             int len = st.countTokens();
-            ArrayList<Integer> ls = new ArrayList<>(len);
+            ArrayList<Integer> ls = new ArrayList<Integer>(len);
             int type;
             for (int i = 0; i < len; i++) {
                 type = getType(st.nextToken());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/Authenticator.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/Authenticator.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/Authenticator.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/Authenticator.java	2018-05-20 04:52:08.199912684 +0100
@@ -173,7 +173,7 @@
      * @exception IOException if an I/O error occurs while reading encoded data.
      */
     public byte[] asn1Encode() throws Asn1Exception, IOException {
-        Vector<DerValue> v = new Vector<>();
+        Vector<DerValue> v = new Vector<DerValue>();
         DerOutputStream temp = new DerOutputStream();
         temp.putInteger(BigInteger.valueOf(authenticator_vno));
         v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte) 0x00), temp.toByteArray()));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/AuthorizationData.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/AuthorizationData.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/AuthorizationData.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/AuthorizationData.java	2018-05-20 04:52:08.199912684 +0100
@@ -99,7 +99,7 @@
      * @exception IOException if an I/O error occurs while reading encoded data.
      */
     public AuthorizationData(DerValue der) throws Asn1Exception, IOException {
-        Vector<AuthorizationDataEntry> v = new Vector<>();
+        Vector<AuthorizationDataEntry> v = new Vector<AuthorizationDataEntry>();
         if (der.getTag() != DerValue.tag_Sequence) {
             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java	2018-05-20 04:38:34.964799367 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java	2018-05-20 04:52:08.199912684 +0100
@@ -569,7 +569,7 @@
 
     private static String exec(String c) {
         StringTokenizer st = new StringTokenizer(c);
-        Vector<String> v = new Vector<>();
+        Vector<String> v = new Vector<String>();
         while (st.hasMoreTokens()) {
             v.addElement(st.nextToken());
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/crypto/EType.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/crypto/EType.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/crypto/EType.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/crypto/EType.java	2018-05-20 04:52:08.199912684 +0100
@@ -257,7 +257,7 @@
                 + configName);
         }
 
-        List<Integer> list = new ArrayList<>(answer.length);
+        List<Integer> list = new ArrayList<Integer>(answer.length);
         for (int i = 0; i < answer.length; i++) {
             if (EncryptionKey.findKey(answer[i], keys) != null) {
                 list.add(answer[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/EncAPRepPart.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/EncAPRepPart.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/EncAPRepPart.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/EncAPRepPart.java	2018-05-20 04:52:08.199912684 +0100
@@ -133,7 +133,7 @@
      * @exception IOException if an I/O error occurs while reading encoded data.
      */
     public byte[] asn1Encode() throws Asn1Exception, IOException {
-        Vector<DerValue> v = new Vector<>();
+        Vector<DerValue> v = new Vector<DerValue>();
         DerOutputStream temp = new DerOutputStream();
         v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT,
                 true, (byte) 0x00), ctime.asn1Encode()));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/HostAddresses.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/HostAddresses.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/HostAddresses.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/HostAddresses.java	2018-05-20 04:52:08.199912684 +0100
@@ -179,7 +179,7 @@
     */
     public HostAddresses(DerValue encoding)
         throws  Asn1Exception, IOException {
-        Vector<HostAddress> tempAddresses = new Vector<>();
+        Vector<HostAddress> tempAddresses = new Vector<HostAddress>();
         DerValue der = null;
         while (encoding.getData().available() > 0) {
             der = encoding.getData().getDerValue();
@@ -265,7 +265,7 @@
         if (addresses == null || addresses.length == 0)
             return null;
 
-        ArrayList<InetAddress> ipAddrs = new ArrayList<>(addresses.length);
+        ArrayList<InetAddress> ipAddrs = new ArrayList<InetAddress>(addresses.length);
 
         for (int i = 0; i < addresses.length; i++) {
             try {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KDCReqBody.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KDCReqBody.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KDCReqBody.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KDCReqBody.java	2018-05-20 04:52:08.199912684 +0100
@@ -165,7 +165,7 @@
             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
         }
         der = encoding.getData().getDerValue();
-        Vector<Integer> v = new Vector<>();
+        Vector<Integer> v = new Vector<Integer>();
         if ((der.getTag() & (byte)0x1F) == (byte)0x08) {
             subDer = der.getData().getDerValue();
 
@@ -190,7 +190,7 @@
             encAuthorizationData = EncryptedData.parse(encoding.getData(), (byte)0x0A, true);
         }
         if (encoding.getData().available() > 0) {
-            Vector<Ticket> tempTickets = new Vector<>();
+            Vector<Ticket> tempTickets = new Vector<Ticket>();
             der = encoding.getData().getDerValue();
             if ((der.getTag() & (byte)0x1F) == (byte)0x0B) {
                 subDer = der.getData().getDerValue();
@@ -223,7 +223,7 @@
      *
      */
     public byte[] asn1Encode(int msgType) throws Asn1Exception, IOException {
-        Vector<DerValue> v = new Vector<>();
+        Vector<DerValue> v = new Vector<DerValue>();
         v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x00), kdcOptions.asn1Encode()));
         if (msgType == Krb5.KRB_AS_REQ) {
             if (cname != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KDCReq.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KDCReq.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KDCReq.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KDCReq.java	2018-05-20 04:52:08.199912684 +0100
@@ -150,7 +150,7 @@
             if (subsubDer.getTag() != DerValue.tag_SequenceOf) {
                 throw new Asn1Exception(Krb5.ASN1_BAD_ID);
             }
-            Vector<PAData> v = new Vector<>();
+            Vector<PAData> v = new Vector<PAData>();
             while (subsubDer.getData().available() > 0) {
                 v.addElement(new PAData(subsubDer.getData().getDerValue()));
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KrbCredInfo.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KrbCredInfo.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KrbCredInfo.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KrbCredInfo.java	2018-05-20 04:52:08.199912684 +0100
@@ -150,7 +150,7 @@
      * @exception IOException if an I/O error occurs while reading encoded data.
      */
     public byte[] asn1Encode() throws Asn1Exception, IOException {
-        Vector<DerValue> v = new Vector<>();
+        Vector<DerValue> v = new Vector<DerValue>();
         v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x00), key.asn1Encode()));
         if (pname != null) {
             v.addElement(new DerValue(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x01), pname.getRealm().asn1Encode()));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KRBCred.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KRBCred.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KRBCred.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KRBCred.java	2018-05-20 04:52:08.199912684 +0100
@@ -134,7 +134,7 @@
             if (subsubDer.getTag() != DerValue.tag_SequenceOf) {
                 throw new Asn1Exception(Krb5.ASN1_BAD_ID);
             }
-            Vector<Ticket> v = new Vector<>();
+            Vector<Ticket> v = new Vector<Ticket>();
             while (subsubDer.getData().available() > 0) {
                 v.addElement(new Ticket(subsubDer.getData().getDerValue()));
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KRBError.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KRBError.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/KRBError.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/KRBError.java	2018-05-20 04:52:08.199912684 +0100
@@ -249,7 +249,7 @@
     private void parsePAData(byte[] data)
             throws IOException, Asn1Exception {
         DerValue derPA = new DerValue(data);
-        List<PAData> paList = new ArrayList<>();
+        List<PAData> paList = new ArrayList<PAData>();
         while (derPA.data.available() > 0) {
             // read the PA-DATA
             DerValue tmp = derPA.data.getDerValue();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java	2018-05-20 04:38:34.964799367 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java	2018-05-20 04:52:08.199912684 +0100
@@ -67,7 +67,7 @@
 
     // Attention: Currently there is no way to remove a keytab from this map,
     // this might lead to a memory leak.
-    private static Map<String,KeyTab> map = new HashMap<>();
+    private static Map<String,KeyTab> map = new HashMap<String,KeyTab>();
 
     // KeyTab file does not exist. Note: a missing keytab is still valid
     private boolean isMissing = false;
@@ -79,7 +79,7 @@
     private long lastModified;
     private int kt_vno = KRB5_KT_VNO;
 
-    private Vector<KeyTabEntry> entries = new Vector<>();
+    private Vector<KeyTabEntry> entries = new Vector<KeyTabEntry>();
 
     /**
      * Constructs a KeyTab object.
@@ -282,7 +282,7 @@
         KeyTabEntry entry;
         EncryptionKey key;
         int size = entries.size();
-        ArrayList<EncryptionKey> keys = new ArrayList<>(size);
+        ArrayList<EncryptionKey> keys = new ArrayList<EncryptionKey>(size);
         for (int i = size-1; i >= 0; i--) {
             entry = entries.elementAt(i);
             if (entry.service.match(service)) {
@@ -484,7 +484,7 @@
         int count = 0;
 
         // Remember the highest KVNO for each etype. Used for kvno == -2
-        Map<Integer,Integer> highest = new HashMap<>();
+        Map<Integer,Integer> highest = new HashMap<Integer, Integer>();
 
         for (int i = entries.size()-1; i >= 0; i--) {
             KeyTabEntry e = entries.get(i);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/LastReq.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/LastReq.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/internal/LastReq.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/internal/LastReq.java	2018-05-20 04:52:08.199912684 +0100
@@ -77,7 +77,7 @@
      */
 
     public LastReq(DerValue encoding) throws Asn1Exception, IOException {
-        Vector<LastReqEntry> v= new Vector<>();
+        Vector<LastReqEntry> v= new Vector<LastReqEntry>();
         if (encoding.getTag() != DerValue.tag_Sequence) {
             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/KdcComm.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/KdcComm.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/KdcComm.java	2018-05-20 04:38:34.968799304 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/KdcComm.java	2018-05-20 04:52:08.199912684 +0100
@@ -468,7 +468,7 @@
      */
     static class KdcAccessibility {
         // Known bad KDCs
-        private static Set<String> bads = new HashSet<>();
+        private static Set<String> bads = new HashSet<String>();
 
         private static synchronized void addBad(String kdc) {
             if (DEBUG) {
@@ -498,9 +498,9 @@
         // Returns a preferred KDC list by putting the bad ones at the end
         private static synchronized String[] list(String kdcList) {
             StringTokenizer st = new StringTokenizer(kdcList);
-            List<String> list = new ArrayList<>();
+            List<String> list = new ArrayList<String>();
             if (badPolicy == BpType.TRY_LAST) {
-                List<String> badkdcs = new ArrayList<>();
+                List<String> badkdcs = new ArrayList<String>();
                 while (st.hasMoreTokens()) {
                     String t = st.nextToken();
                     if (bads.contains(t)) badkdcs.add(t);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/KrbServiceLocator.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/KrbServiceLocator.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/KrbServiceLocator.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/KrbServiceLocator.java	2018-05-20 04:52:08.199912684 +0100
@@ -85,7 +85,7 @@
             // the initial context constructor. This avoids having the initial
             // context constructor call itself (when processing the URL
             // argument in the getAttributes call).
-            final Context ctx = NamingManager.getURLContext("dns", new Hashtable<>(0));
+            final Context ctx = NamingManager.getURLContext("dns", new Hashtable<Object, Object>(0));
             if (!(ctx instanceof DirContext)) {
                 return null; // cannot create a DNS context
             }
@@ -158,7 +158,7 @@
             // the initial context constructor. This avoids having the initial
             // context constructor call itself (when processing the URL
             // argument in the getAttributes call).
-            final Context ctx = NamingManager.getURLContext("dns", new Hashtable<>(0));
+            final Context ctx = NamingManager.getURLContext("dns", new Hashtable<Object, Object>(0));
             if (!(ctx instanceof DirContext)) {
                 return null; // cannot create a DNS context
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/PrincipalName.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/PrincipalName.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/PrincipalName.java	2018-05-20 04:38:34.900800383 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/PrincipalName.java	2018-05-20 04:52:08.199912684 +0100
@@ -265,7 +265,7 @@
             if (subDer.getTag() != DerValue.tag_SequenceOf) {
                 throw new Asn1Exception(Krb5.ASN1_BAD_ID);
             }
-            Vector<String> v = new Vector<>();
+            Vector<String> v = new Vector<String>();
             DerValue subSubDer;
             while(subDer.getData().available() > 0) {
                 subSubDer = subDer.getData().getDerValue();
@@ -321,7 +321,7 @@
     // Code repetition, realm parsed again by class Realm
     private static String[] parseName(String name) {
 
-        Vector<String> tempStrings = new Vector<>();
+        Vector<String> tempStrings = new Vector<String>();
         String temp = name;
         int i = 0;
         int componentStart = 0;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/Realm.java openjdk-boot/jdk/src/share/classes/sun/security/krb5/Realm.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/krb5/Realm.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/krb5/Realm.java	2018-05-20 04:52:08.199912684 +0100
@@ -375,7 +375,7 @@
             return null;
         }
 
-        LinkedList<String> path = new LinkedList<>();
+        LinkedList<String> path = new LinkedList<String>();
 
         String head = sRealm;
         while (true) {
@@ -437,7 +437,7 @@
         // DEVEL.EXAMPLE.COM   3       2
         // PROD.EXAMPLE.ORG    3       2
 
-        LinkedList<String> path = new LinkedList<>();
+        LinkedList<String> path = new LinkedList<String>();
 
         // Un-common ones for client side
         for (int i=0; i<=cPos; i++) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/pkcs/SignerInfo.java openjdk-boot/jdk/src/share/classes/sun/security/pkcs/SignerInfo.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/pkcs/SignerInfo.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/pkcs/SignerInfo.java	2018-05-20 04:52:08.199912684 +0100
@@ -268,7 +268,7 @@
         if (userCert == null)
             return null;
 
-        ArrayList<X509Certificate> certList = new ArrayList<>();
+        ArrayList<X509Certificate> certList = new ArrayList<X509Certificate>();
         certList.add(userCert);
 
         X509Certificate[] pkcsCerts = block.getCertificates();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java openjdk-boot/jdk/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java	2018-05-20 04:52:08.199912684 +0100
@@ -254,7 +254,7 @@
             this.keyId = keyId;
             this.alias = alias;
             this.trustedKeyUsage = trustedKeyUsage;
-            this.attributes = new HashSet<>();
+            this.attributes = new HashSet<PKCS12Attribute>();
             if (attributes != null) {
                 this.attributes.addAll(attributes);
             }
@@ -636,7 +636,7 @@
                 throw new KeyStoreException("Unsupported Key type");
             }
 
-            entry.attributes = new HashSet<>();
+            entry.attributes = new HashSet<PKCS12Attribute>();
             if (attributes != null) {
                 entry.attributes.addAll(attributes);
             }
@@ -1323,7 +1323,7 @@
     private Set<PKCS12Attribute> getAttributes(Entry entry) {
 
         if (entry.attributes == null) {
-            entry.attributes = new HashSet<>();
+            entry.attributes = new HashSet<PKCS12Attribute>();
         }
 
         // friendlyName
@@ -1430,7 +1430,7 @@
         // Check for loops in the chain. If there are repeated certs,
         // the Set of certs in the chain will contain fewer certs than
         // the chain
-        Set<Certificate> set = new HashSet<>(Arrays.asList(certChain));
+        Set<Certificate> set = new HashSet<Certificate>(Arrays.asList(certChain));
         return set.size() == certChain.length;
     }
 
@@ -2188,7 +2188,7 @@
             String alias = null;
             byte[] keyId = null;
             ObjectIdentifier[] trustedKeyUsage = null;
-            Set<PKCS12Attribute> attributes = new HashSet<>();
+            Set<PKCS12Attribute> attributes = new HashSet<PKCS12Attribute>();
 
             if (attrSet != null) {
                 for (int j = 0; j < attrSet.length; j++) {
@@ -2268,7 +2268,7 @@
                     keyList.add((PrivateKeyEntry) entry);
                 }
                 if (entry.attributes == null) {
-                    entry.attributes = new HashSet<>();
+                    entry.attributes = new HashSet<PKCS12Attribute>();
                 }
                 entry.attributes.addAll(attributes);
                 if (alias == null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/AdjacencyList.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/AdjacencyList.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/AdjacencyList.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/AdjacencyList.java	2018-05-20 04:52:08.203912620 +0100
@@ -167,7 +167,7 @@
                 // successful step? If there's only one entry without
                 // a throwable, then that's the successful step. Otherwise,
                 // we'll have to make some guesses...
-                List<Vertex> possibles = new ArrayList<>();
+                List<Vertex> possibles = new ArrayList<Vertex>();
                 for (Vertex v : l) {
                     if (v.getThrowable() == null)
                         possibles.add(v);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/Builder.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/Builder.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/Builder.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/Builder.java	2018-05-20 04:52:08.203912620 +0100
@@ -399,7 +399,7 @@
                 (!initialPolicies.contains(PolicyChecker.ANY_POLICY)) &&
                 (buildParams.policyMappingInhibited()))
             {
-                matchingPolicies = new HashSet<>(initialPolicies);
+                matchingPolicies = new HashSet<String>(initialPolicies);
                 matchingPolicies.add(PolicyChecker.ANY_POLICY);
             } else {
                 // we just return an empty set to make sure that there is
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/CertStoreHelper.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/CertStoreHelper.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/CertStoreHelper.java	2018-05-20 04:38:34.904800318 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/CertStoreHelper.java	2018-05-20 04:52:08.203912620 +0100
@@ -51,7 +51,7 @@
 public abstract class CertStoreHelper {
 
     private static final int NUM_TYPES = 2;
-    private final static Map<String,String> classMap = new HashMap<>(NUM_TYPES);
+    private final static Map<String,String> classMap = new HashMap<String,String>(NUM_TYPES);
     static {
         classMap.put(
             "LDAP",
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/CollectionCertStore.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/CollectionCertStore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/CollectionCertStore.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/CollectionCertStore.java	2018-05-20 04:52:08.203912620 +0100
@@ -122,7 +122,7 @@
         // Tolerate a few ConcurrentModificationExceptions
         for (int c = 0; c < 10; c++) {
             try {
-                HashSet<Certificate> result = new HashSet<>();
+                HashSet<Certificate> result = new HashSet<Certificate>();
                 if (selector != null) {
                     for (Object o : coll) {
                         if ((o instanceof Certificate) &&
@@ -164,7 +164,7 @@
         // Tolerate a few ConcurrentModificationExceptions
         for (int c = 0; c < 10; c++) {
             try {
-                HashSet<CRL> result = new HashSet<>();
+                HashSet<CRL> result = new HashSet<CRL>();
                 if (selector != null) {
                     for (Object o : coll) {
                         if ((o instanceof CRL) && selector.match((CRL) o))
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java	2018-05-20 04:38:34.904800318 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java	2018-05-20 04:52:08.203912620 +0100
@@ -146,7 +146,7 @@
             }
             List<DistributionPoint> points =
                     ext.get(CRLDistributionPointsExtension.POINTS);
-            Set<X509CRL> results = new HashSet<>();
+            Set<X509CRL> results = new HashSet<X509CRL>();
             for (Iterator<DistributionPoint> t = points.iterator();
                  t.hasNext() && !Arrays.equals(reasonsMask, ALL_REASONS); ) {
                 DistributionPoint point = t.next();
@@ -208,7 +208,7 @@
                 return Collections.emptySet();
             }
         }
-        Collection<X509CRL> possibleCRLs = new ArrayList<>();
+        Collection<X509CRL> possibleCRLs = new ArrayList<X509CRL>();
         CertStoreException savedCSE = null;
         for (Iterator<GeneralName> t = fullName.iterator(); t.hasNext(); ) {
             try {
@@ -234,7 +234,7 @@
             throw savedCSE;
         }
 
-        Collection<X509CRL> crls = new ArrayList<>(2);
+        Collection<X509CRL> crls = new ArrayList<X509CRL>(2);
         for (X509CRL crl : possibleCRLs) {
             try {
                 // make sure issuer is not set
@@ -313,7 +313,7 @@
         X509CRLSelector xcs = new X509CRLSelector();
         xcs.addIssuer(name.asX500Principal());
         xcs.addIssuer(certIssuer);
-        Collection<X509CRL> crls = new ArrayList<>();
+        Collection<X509CRL> crls = new ArrayList<X509CRL>();
         CertStoreException savedCSE = null;
         for (CertStore store : certStores) {
             try {
@@ -672,7 +672,7 @@
             // In addition to the performance improvement, another benefit is to
             // break the dead loop while looking for the issuer back and forth
             // between the delegated self-issued certificate and its issuer.
-            Set<TrustAnchor> newTrustAnchors = new HashSet<>(trustAnchors);
+            Set<TrustAnchor> newTrustAnchors = new HashSet<TrustAnchor>(trustAnchors);
 
             if (prevKey != null) {
                 // Add the previous certificate as a trust anchor.
@@ -762,7 +762,7 @@
     private static GeneralNames getFullNames(X500Name issuer, RDN rdn)
         throws IOException
     {
-        List<RDN> rdns = new ArrayList<>(issuer.rdns());
+        List<RDN> rdns = new ArrayList<RDN>(issuer.rdns());
         rdns.add(rdn);
         X500Name fullName = new X500Name(rdns.toArray(new RDN[0]));
         GeneralNames fullNames = new GeneralNames();
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/ForwardBuilder.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/ForwardBuilder.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/ForwardBuilder.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/ForwardBuilder.java	2018-05-20 04:52:08.203912620 +0100
@@ -122,7 +122,7 @@
          * As each cert is added, it is sorted based on the PKIXCertComparator
          * algorithm.
          */
-        Set<X509Certificate> certs = new TreeSet<>(comparator);
+        Set<X509Certificate> certs = new TreeSet<X509Certificate>(comparator);
 
         /*
          * Only look for EE certs if search has just started.
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/IndexedCollectionCertStore.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/IndexedCollectionCertStore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/IndexedCollectionCertStore.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/IndexedCollectionCertStore.java	2018-05-20 04:52:08.203912620 +0100
@@ -180,7 +180,7 @@
                 if (cert.equals(oldEntry)) {
                     return;
                 }
-                List<X509Certificate> list = new ArrayList<>(2);
+                List<X509Certificate> list = new ArrayList<X509Certificate>(2);
                 list.add(cert);
                 list.add((X509Certificate)oldEntry);
                 certSubjects.put(subject, list);
@@ -206,7 +206,7 @@
                 if (crl.equals(oldEntry)) {
                     return;
                 }
-                List<X509CRL> list = new ArrayList<>(2);
+                List<X509CRL> list = new ArrayList<X509CRL>(2);
                 list.add(crl);
                 list.add((X509CRL)oldEntry);
                 crlIssuers.put(issuer, list);
@@ -240,14 +240,14 @@
 
         // no selector means match all
         if (selector == null) {
-            Set<Certificate> matches = new HashSet<>();
+            Set<Certificate> matches = new HashSet<Certificate>();
             matchX509Certs(new X509CertSelector(), matches);
             matches.addAll(otherCertificates);
             return matches;
         }
 
         if (selector instanceof X509CertSelector == false) {
-            Set<Certificate> matches = new HashSet<>();
+            Set<Certificate> matches = new HashSet<Certificate>();
             matchX509Certs(selector, matches);
             for (Certificate cert : otherCertificates) {
                 if (selector.match(cert)) {
@@ -286,7 +286,7 @@
                 // See certSubjects javadoc.
                 @SuppressWarnings("unchecked")
                 List<X509Certificate> list = (List<X509Certificate>)entry;
-                Set<X509Certificate> matches = new HashSet<>(16);
+                Set<X509Certificate> matches = new HashSet<X509Certificate>(16);
                 for (X509Certificate cert : list) {
                     if (x509Selector.match(cert)) {
                         matches.add(cert);
@@ -296,7 +296,7 @@
             }
         }
         // cannot use index, iterate all
-        Set<Certificate> matches = new HashSet<>(16);
+        Set<Certificate> matches = new HashSet<Certificate>(16);
         matchX509Certs(x509Selector, matches);
         return matches;
     }
@@ -344,14 +344,14 @@
             throws CertStoreException {
 
         if (selector == null) {
-            Set<CRL> matches = new HashSet<>();
+            Set<CRL> matches = new HashSet<CRL>();
             matchX509CRLs(new X509CRLSelector(), matches);
             matches.addAll(otherCRLs);
             return matches;
         }
 
         if (selector instanceof X509CRLSelector == false) {
-            Set<CRL> matches = new HashSet<>();
+            Set<CRL> matches = new HashSet<CRL>();
             matchX509CRLs(selector, matches);
             for (CRL crl : otherCRLs) {
                 if (selector.match(crl)) {
@@ -368,7 +368,7 @@
         // see if the issuer is specified
         Collection<X500Principal> issuers = x509Selector.getIssuers();
         if (issuers != null) {
-            HashSet<CRL> matches = new HashSet<>(16);
+            HashSet<CRL> matches = new HashSet<CRL>(16);
             for (X500Principal issuer : issuers) {
                 Object entry = crlIssuers.get(issuer);
                 if (entry == null) {
@@ -392,7 +392,7 @@
             return matches;
         }
         // cannot use index, iterate all
-        Set<CRL> matches = new HashSet<>(16);
+        Set<CRL> matches = new HashSet<CRL>(16);
         matchX509CRLs(x509Selector, matches);
         return matches;
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/OCSPResponse.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/OCSPResponse.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/OCSPResponse.java	2018-05-20 04:38:34.904800318 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/OCSPResponse.java	2018-05-20 04:52:08.203912620 +0100
@@ -309,7 +309,7 @@
 
         // responses
         DerValue[] singleResponseDer = seqDerIn.getSequence(1);
-        singleResponseMap = new HashMap<>(singleResponseDer.length);
+        singleResponseMap = new HashMap<CertId,SingleResponse>(singleResponseDer.length);
         if (debug != null) {
             debug.println("OCSP number of SingleResponses: "
                           + singleResponseDer.length);
@@ -320,7 +320,8 @@
         }
 
         // responseExtensions
-        Map<String, java.security.cert.Extension> tmpExtMap = new HashMap<>();
+        Map<String, java.security.cert.Extension> tmpExtMap =
+	    new HashMap<String,java.security.cert.Extension>();
         if (seqDerIn.available() > 0) {
             seq = seqDerIn.getDerValue();
             if (seq.isContextSpecific((byte)1)) {
@@ -737,7 +738,7 @@
         parseExtensions(DerValue derVal) throws IOException {
         DerValue[] extDer = derVal.data.getSequence(3);
         Map<String, java.security.cert.Extension> extMap =
-                new HashMap<>(extDer.length);
+	        new HashMap<String, java.security.cert.Extension>(extDer.length);
 
         for (DerValue extDerVal : extDer) {
             Extension ext = new Extension(extDerVal);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PKIXCertPathValidator.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PKIXCertPathValidator.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PKIXCertPathValidator.java	2018-05-20 04:38:34.904800318 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PKIXCertPathValidator.java	2018-05-20 04:52:08.203912620 +0100
@@ -172,7 +172,7 @@
         int certPathLen = params.certificates().size();
 
         // create PKIXCertPathCheckers
-        List<PKIXCertPathChecker> certPathCheckers = new ArrayList<>();
+        List<PKIXCertPathChecker> certPathCheckers = new ArrayList<PKIXCertPathChecker>();
         // add standard checkers that we will be using
         certPathCheckers.add(untrustedChecker);
         certPathCheckers.add(new AlgorithmChecker(anchor, null, params.date(),
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PKIX.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PKIX.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PKIX.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PKIX.java	2018-05-20 04:52:08.203912620 +0100
@@ -136,7 +136,7 @@
                     // Reverse the ordering for validation so that the target
                     // cert is the last certificate
                     @SuppressWarnings("unchecked")
-                    List<X509Certificate> xc = new ArrayList<>
+                    List<X509Certificate> xc = new ArrayList<X509Certificate>
                         ((List<X509Certificate>)certPath.getCertificates());
                     Collections.reverse(xc);
                     certs = xc;
@@ -240,7 +240,7 @@
         @Override List<CertStore> certStores() {
             if (stores == null) {
                 // reorder CertStores so that local CertStores are tried first
-                stores = new ArrayList<>(params.getCertStores());
+                stores = new ArrayList<CertStore>(params.getCertStores());
                 Collections.sort(stores, new CertStoreComparator());
             }
             return stores;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PKIXRevocationChecker.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PKIXRevocationChecker.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PKIXRevocationChecker.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PKIXRevocationChecker.java	2018-05-20 04:52:08.203912620 +0100
@@ -188,7 +188,7 @@
         if (responses == null) {
             this.ocspStapled = Collections.<X509Certificate, byte[]>emptyMap();
         } else {
-            Map<X509Certificate, byte[]> copy = new HashMap<>(responses.size());
+            Map<X509Certificate, byte[]> copy = new HashMap<X509Certificate,byte[]>(responses.size());
             for (Map.Entry<X509Certificate, byte[]> e : responses.entrySet()) {
                 copy.put(e.getKey(), e.getValue().clone());
             }
@@ -207,7 +207,7 @@
      *        Returns an empty map if no responses have been specified.
      */
     public Map<X509Certificate, byte[]> getOCSPStapledResponses() {
-        Map<X509Certificate, byte[]> copy = new HashMap<>(ocspStapled.size());
+        Map<X509Certificate, byte[]> copy = new HashMap<X509Certificate,byte[]>(ocspStapled.size());
         for (Map.Entry<X509Certificate, byte[]> e : ocspStapled.entrySet()) {
             copy.put(e.getKey(), e.getValue().clone());
         }
@@ -239,8 +239,8 @@
     @Override
     public Object clone() {
         PKIXRevocationChecker copy = (PKIXRevocationChecker)super.clone();
-        copy.ocspExtensions = new ArrayList<>(ocspExtensions);
-        copy.ocspStapled = new HashMap<>(ocspStapled);
+        copy.ocspExtensions = new ArrayList<Extension>(ocspExtensions);
+        copy.ocspStapled = new HashMap<X509Certificate,byte[]>(ocspStapled);
         // deep-copy the encoded stapled responses, since they are mutable
         for (Map.Entry<X509Certificate, byte[]> entry :
                  copy.ocspStapled.entrySet())
@@ -248,7 +248,7 @@
             byte[] encoded = entry.getValue();
             entry.setValue(encoded.clone());
         }
-        copy.options = new HashSet<>(options);
+        copy.options = new HashSet<Option>(options);
         return copy;
     }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PolicyChecker.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PolicyChecker.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PolicyChecker.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PolicyChecker.java	2018-05-20 04:52:08.203912620 +0100
@@ -431,7 +431,7 @@
         boolean policiesCritical = false;
         List<PolicyInformation> policyInfo;
         PolicyNodeImpl rootNode = null;
-        Set<PolicyQualifierInfo> anyQuals = new HashSet<>();
+        Set<PolicyQualifierInfo> anyQuals = new HashSet<PolicyQualifierInfo>();
 
         if (origRootNode == null)
             rootNode = null;
@@ -602,7 +602,7 @@
         PolicyNodeImpl parentNode = (PolicyNodeImpl)anyNode.getParent();
         parentNode.deleteChild(anyNode);
         // see if there are any initialPolicies not represented by leaf nodes
-        Set<String> initial = new HashSet<>(initPolicies);
+        Set<String> initial = new HashSet<String>(initPolicies);
         for (PolicyNodeImpl node : rootNode.getPolicyNodes(certIndex)) {
             initial.remove(node.getValidPolicy());
         }
@@ -699,7 +699,7 @@
                         }
                     }
 
-                    Set<String> expPols = new HashSet<>();
+                    Set<String> expPols = new HashSet<String>();
                     expPols.add(curParExpPol);
 
                     curNode = new PolicyNodeImpl
@@ -817,7 +817,7 @@
                         PolicyNodeImpl curAnyNodeParent =
                             (PolicyNodeImpl) curAnyNode.getParent();
 
-                        Set<String> expPols = new HashSet<>();
+                        Set<String> expPols = new HashSet<String>();
                         expPols.add(subjectDomain);
 
                         PolicyNodeImpl curNode = new PolicyNodeImpl
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PolicyNodeImpl.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PolicyNodeImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/PolicyNodeImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/PolicyNodeImpl.java	2018-05-20 04:52:08.203912620 +0100
@@ -300,7 +300,7 @@
      * @return a <code>Set</code> of all nodes at the specified depth
      */
     Set<PolicyNodeImpl> getPolicyNodes(int depth) {
-        Set<PolicyNodeImpl> set = new HashSet<>();
+        Set<PolicyNodeImpl> set = new HashSet<PolicyNodeImpl>();
         getPolicyNodes(depth, set);
         return set;
     }
@@ -344,7 +344,7 @@
     private Set<PolicyNodeImpl> getPolicyNodesExpectedHelper(int depth,
         String expectedOID, boolean matchAny) {
 
-        HashSet<PolicyNodeImpl> set = new HashSet<>();
+        HashSet<PolicyNodeImpl> set = new HashSet<PolicyNodeImpl>();
 
         if (mDepth < depth) {
             for (PolicyNodeImpl node : mChildren) {
@@ -374,7 +374,7 @@
      * @return a Set of matched <code>PolicyNode</code>s
      */
     Set<PolicyNodeImpl> getPolicyNodesValid(int depth, String validOID) {
-        HashSet<PolicyNodeImpl> set = new HashSet<>();
+        HashSet<PolicyNodeImpl> set = new HashSet<PolicyNodeImpl>();
 
         if (mDepth < depth) {
             for (PolicyNodeImpl node : mChildren) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/ReverseBuilder.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/ReverseBuilder.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/ReverseBuilder.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/ReverseBuilder.java	2018-05-20 04:52:08.203912620 +0100
@@ -178,7 +178,7 @@
         sel.setBasicConstraints(-2);
 
         /* Retrieve matching certs from CertStores */
-        HashSet<X509Certificate> eeCerts = new HashSet<>();
+        HashSet<X509Certificate> eeCerts = new HashSet<X509Certificate>();
         addMatchingCerts(sel, certStores, eeCerts, true);
 
         if (debug != null) {
@@ -251,7 +251,7 @@
         sel.setBasicConstraints(0);
 
         /* Retrieve matching certs from CertStores */
-        ArrayList<X509Certificate> reverseCerts = new ArrayList<>();
+        ArrayList<X509Certificate> reverseCerts = new ArrayList<X509Certificate>();
         addMatchingCerts(sel, certStores, reverseCerts, true);
 
         /* Sort remaining certs using name constraints */
@@ -371,7 +371,7 @@
          * of the same certificate, we reverse the certpathlist first
          */
         if ((certPathList != null) && (!certPathList.isEmpty())) {
-            List<X509Certificate> reverseCertList = new ArrayList<>();
+            List<X509Certificate> reverseCertList = new ArrayList<X509Certificate>();
             for (X509Certificate c : certPathList) {
                 reverseCertList.add(0, c);
             }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/ReverseState.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/ReverseState.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/ReverseState.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/ReverseState.java	2018-05-20 04:52:08.203912620 +0100
@@ -189,7 +189,7 @@
         certIndex = 1;
 
         /* Initialize policy tree */
-        Set<String> initExpPolSet = new HashSet<>(1);
+        Set<String> initExpPolSet = new HashSet<String>(1);
         initExpPolSet.add(PolicyChecker.ANY_POLICY);
 
         rootNode = new PolicyNodeImpl(null, PolicyChecker.ANY_POLICY, null,
@@ -199,7 +199,7 @@
          * Initialize each user-defined checker
          * Shallow copy the checkers
          */
-        userCheckers = new ArrayList<>(buildParams.certPathCheckers());
+        userCheckers = new ArrayList<PKIXCertPathChecker>(buildParams.certPathCheckers());
         /* initialize each checker (just in case) */
         for (PKIXCertPathChecker checker : userCheckers) {
             checker.init(false);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/RevocationChecker.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/RevocationChecker.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/RevocationChecker.java	2018-05-20 04:38:34.904800318 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/RevocationChecker.java	2018-05-20 04:52:08.203912620 +0100
@@ -144,7 +144,7 @@
 
         this.anchor = anchor;
         this.params = params;
-        this.certStores = new ArrayList<>(params.certStores());
+        this.certStores = new ArrayList<CertStore>(params.certStores());
         try {
             this.certStores.add(CertStore.getInstance("Collection",
                 new CollectionCertStoreParameters(params.certificates())));
@@ -480,8 +480,8 @@
                  BasicReason.UNDETERMINED_REVOCATION_STATUS);
         }
 
-        Set<X509CRL> possibleCRLs = new HashSet<>();
-        Set<X509CRL> approvedCRLs = new HashSet<>();
+        Set<X509CRL> possibleCRLs = new HashSet<X509CRL>();
+        Set<X509CRL> approvedCRLs = new HashSet<X509CRL>();
         X509CRLSelector sel = new X509CRLSelector();
         sel.setCertificateChecking(cert);
         CertPathHelper.setDateAndTime(sel, params.date(), MAX_CLOCK_SKEW);
@@ -822,7 +822,7 @@
             } else {
                 points = ext.get(CRLDistributionPointsExtension.POINTS);
             }
-            Set<X509CRL> results = new HashSet<>();
+            Set<X509CRL> results = new HashSet<X509CRL>();
             for (DistributionPoint point : points) {
                 for (X509CRL crl : crls) {
                     if (DistributionPointFetcher.verifyCRL(
@@ -944,7 +944,7 @@
             debug.println("RevocationChecker.buildToNewKey()" +
                           " starting work");
         }
-        Set<PublicKey> badKeys = new HashSet<>();
+        Set<PublicKey> badKeys = new HashSet<PublicKey>();
         if (prevKey != null) {
             badKeys.add(prevKey);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/ssl/SSLServerCertStore.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/ssl/SSLServerCertStore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/ssl/SSLServerCertStore.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/ssl/SSLServerCertStore.java	2018-05-20 04:52:08.203912620 +0100
@@ -138,7 +138,7 @@
         if (selector == null) {
             return certs;
         }
-        List<X509Certificate> matchedCerts = new ArrayList<>(certs.size());
+        List<X509Certificate> matchedCerts = new ArrayList<X509Certificate>(certs.size());
         for (X509Certificate cert : certs) {
             if (selector.match(cert)) {
                 matchedCerts.add(cert);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/SunCertPathBuilder.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/SunCertPathBuilder.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/SunCertPathBuilder.java	2018-05-20 04:38:34.904800318 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/SunCertPathBuilder.java	2018-05-20 04:52:08.203912620 +0100
@@ -131,7 +131,7 @@
     }
 
     private PKIXCertPathBuilderResult build() throws CertPathBuilderException {
-        List<List<Vertex>> adjList = new ArrayList<>();
+        List<List<Vertex>> adjList = new ArrayList<List<Vertex>>();
         PKIXCertPathBuilderResult result = buildCertPath(false, adjList);
         if (result == null) {
             if (debug != null) {
@@ -158,7 +158,7 @@
         trustAnchor = null;
         finalPublicKey = null;
         policyTreeResult = null;
-        LinkedList<X509Certificate> certPathList = new LinkedList<>();
+        LinkedList<X509Certificate> certPathList = new LinkedList<X509Certificate>();
         try {
             if (buildParams.buildForward()) {
                 buildForward(adjList, certPathList, searchAllCertStores);
@@ -412,7 +412,7 @@
                     debug.println("SunCertPathBuilder.depthFirstSearchForward()"
                                   + ": commencing final verification");
 
-                List<X509Certificate> appendedCerts = new ArrayList<>(cpList);
+                List<X509Certificate> appendedCerts = new ArrayList<X509Certificate>(cpList);
 
                 /*
                  * if the trust anchor selected is specified as a trusted
@@ -430,7 +430,7 @@
                 PolicyNodeImpl rootNode = new PolicyNodeImpl(null,
                     PolicyChecker.ANY_POLICY, null, false, initExpPolSet, false);
 
-                List<PKIXCertPathChecker> checkers = new ArrayList<>();
+                List<PKIXCertPathChecker> checkers = new ArrayList<PKIXCertPathChecker>();
                 PolicyChecker policyChecker
                     = new PolicyChecker(buildParams.initialPolicies(),
                                         appendedCerts.size(),
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/URICertStore.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/URICertStore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/URICertStore.java	2018-05-20 04:38:34.964799367 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/URICertStore.java	2018-05-20 04:52:08.203912620 +0100
@@ -340,7 +340,7 @@
         if (selector == null) {
             return certs;
         }
-        List<X509Certificate> matchedCerts = new ArrayList<>(certs.size());
+        List<X509Certificate> matchedCerts = new ArrayList<X509Certificate>(certs.size());
         for (X509Certificate cert : certs) {
             if (selector.match(cert)) {
                 matchedCerts.add(cert);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/X509CertPath.java openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/X509CertPath.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/certpath/X509CertPath.java	2018-05-20 04:38:34.320809575 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/certpath/X509CertPath.java	2018-05-20 04:52:08.203912620 +0100
@@ -82,7 +82,7 @@
     private static final Collection<String> encodingList;
 
     static {
-        List<String> list = new ArrayList<>(2);
+        List<String> list = new ArrayList<String>(2);
         list.add(PKIPATH_ENCODING);
         list.add(PKCS7_ENCODING);
         encodingList = Collections.unmodifiableCollection(list);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/JavaKeyStore.java openjdk-boot/jdk/src/share/classes/sun/security/provider/JavaKeyStore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/JavaKeyStore.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/JavaKeyStore.java	2018-05-20 04:52:08.203912620 +0100
@@ -691,7 +691,7 @@
                     // Read the certificate chain
                     int numOfCerts = dis.readInt();
                     if (numOfCerts > 0) {
-                        List<Certificate> certs = new ArrayList<>(
+                        List<Certificate> certs = new ArrayList<Certificate>(
                                 numOfCerts > 10 ? 10 : numOfCerts);
                         for (int j = 0; j < numOfCerts; j++) {
                             if (xVersion == 2) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/PolicyFile.java openjdk-boot/jdk/src/share/classes/sun/security/provider/PolicyFile.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/PolicyFile.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/PolicyFile.java	2018-05-20 04:52:08.207912557 +0100
@@ -1324,7 +1324,7 @@
 
         List<PolicyParser.PrincipalEntry> entryPs = entry.getPrincipals();
         if (debug != null) {
-            ArrayList<PolicyParser.PrincipalEntry> accPs = new ArrayList<>();
+            ArrayList<PolicyParser.PrincipalEntry> accPs = new ArrayList<PolicyParser.PrincipalEntry>();
             if (principals != null) {
                 for (int i = 0; i < principals.length; i++) {
                     accPs.add(new PolicyParser.PrincipalEntry
@@ -1405,7 +1405,7 @@
                     // check if the PrincipalComparator
                     // implies the current thread's principals
 
-                    Set<Principal> pSet = new HashSet<>(principals.length);
+                    Set<Principal> pSet = new HashSet<Principal>(principals.length);
                     for (int j = 0; j < principals.length; j++) {
                         pSet.add(principals[j]);
                     }
@@ -1688,7 +1688,7 @@
             // build an info array for every principal
             // in the current domain which has a principal class
             // that is equal to policy entry principal class name
-            List<Principal> plist = new ArrayList<>();
+            List<Principal> plist = new ArrayList<Principal>();
             for (int i = 0; i < pdp.length; i++) {
                 if(pe.principalClass.equals(pdp[i].getClass().getName()))
                     plist.add(pdp[i]);
@@ -1758,7 +1758,7 @@
             // Done
             return certs;
 
-        ArrayList<Certificate> userCertList = new ArrayList<>();
+        ArrayList<Certificate> userCertList = new ArrayList<Certificate>();
         i = 0;
         while (i < certs.length) {
             userCertList.add(certs[i]);
@@ -2237,7 +2237,7 @@
                     if (this.certs == null) {
                         // extract the signer certs
                         ArrayList<Certificate> signerCerts =
-                            new ArrayList<>();
+                            new ArrayList<Certificate>();
                         i = 0;
                         while (i < certs.length) {
                             signerCerts.add(certs[i]);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/Sun.java openjdk-boot/jdk/src/share/classes/sun/security/provider/Sun.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/Sun.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/Sun.java	2018-05-20 04:52:08.207912557 +0100
@@ -55,7 +55,7 @@
             SunEntries.putEntries(this);
         } else {
             // use LinkedHashMap to preserve the order of the PRNGs
-            Map<Object, Object> map = new LinkedHashMap<>();
+            Map<Object, Object> map = new LinkedHashMap<Object, Object>();
             SunEntries.putEntries(map);
             AccessController.doPrivileged(new PutAllAction(this, map));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/VerificationProvider.java openjdk-boot/jdk/src/share/classes/sun/security/provider/VerificationProvider.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/VerificationProvider.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/VerificationProvider.java	2018-05-20 04:52:08.207912557 +0100
@@ -76,7 +76,7 @@
             SunRsaSignEntries.putEntries(this);
         } else {
             // use LinkedHashMap to preserve the order of the PRNGs
-            Map<Object, Object> map = new LinkedHashMap<>();
+            Map<Object, Object> map = new LinkedHashMap<Object, Object>();
             SunEntries.putEntries(map);
             SunRsaSignEntries.putEntries(map);
             AccessController.doPrivileged(new PutAllAction(this, map));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/X509Factory.java openjdk-boot/jdk/src/share/classes/sun/security/provider/X509Factory.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/provider/X509Factory.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/provider/X509Factory.java	2018-05-20 04:52:08.207912557 +0100
@@ -431,7 +431,7 @@
         int peekByte;
         byte[] data;
         PushbackInputStream pbis = new PushbackInputStream(is);
-        Collection<X509CertImpl> coll = new ArrayList<>();
+        Collection<X509CertImpl> coll = new ArrayList<X509CertImpl>();
 
         // Test the InputStream for end-of-stream.  If the stream's
         // initial state is already at end-of-stream then return
@@ -439,7 +439,7 @@
         // stream and let readOneBlock look for the first certificate.
         peekByte = pbis.read();
         if (peekByte == -1) {
-            return new ArrayList<>(0);
+            return new ArrayList<Certificate>(0);
         } else {
             pbis.unread(peekByte);
             data = readOneBlock(pbis);
@@ -459,7 +459,7 @@
                 return Arrays.asList(certs);
             } else {
                 // no certificates provided
-                return new ArrayList<>(0);
+                return new ArrayList<Certificate>(0);
             }
         } catch (ParsingException e) {
             while (data != null) {
@@ -482,7 +482,7 @@
         int peekByte;
         byte[] data;
         PushbackInputStream pbis = new PushbackInputStream(is);
-        Collection<X509CRLImpl> coll = new ArrayList<>();
+        Collection<X509CRLImpl> coll = new ArrayList<X509CRLImpl>();
 
         // Test the InputStream for end-of-stream.  If the stream's
         // initial state is already at end-of-stream then return
@@ -490,7 +490,7 @@
         // stream and let readOneBlock look for the first CRL.
         peekByte = pbis.read();
         if (peekByte == -1) {
-            return new ArrayList<>(0);
+            return new ArrayList<CRL>(0);
         } else {
             pbis.unread(peekByte);
             data = readOneBlock(pbis);
@@ -510,7 +510,7 @@
                 return Arrays.asList(crls);
             } else {
                 // no crls provided
-                return new ArrayList<>(0);
+                return new ArrayList<java.security.cert.CRL>(0);
             }
         } catch (ParsingException e) {
             while (data != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/rsa/RSACore.java openjdk-boot/jdk/src/share/classes/sun/security/rsa/RSACore.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/rsa/RSACore.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/rsa/RSACore.java	2018-05-20 04:52:08.207912557 +0100
@@ -57,7 +57,7 @@
     // use a weak hashmap so that cached values are automatically cleared
     // when the modulus is GC'ed
     private final static Map<BigInteger, BlindingParameters>
-                blindingCache = new WeakHashMap<>();
+      blindingCache = new WeakHashMap<BigInteger, BlindingParameters>();
 
     private RSACore() {
         // empty
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/rsa/SunRsaSign.java openjdk-boot/jdk/src/share/classes/sun/security/rsa/SunRsaSign.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/rsa/SunRsaSign.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/rsa/SunRsaSign.java	2018-05-20 04:52:08.207912557 +0100
@@ -52,7 +52,7 @@
             SunRsaSignEntries.putEntries(this);
         } else {
             // use LinkedHashMap to preserve the order of the PRNGs
-            Map<Object, Object> map = new HashMap<>();
+            Map<Object, Object> map = new HashMap<Object, Object>();
             SunRsaSignEntries.putEntries(map);
             AccessController.doPrivileged(new PutAllAction(this, map));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/CipherSuite.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/CipherSuite.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/CipherSuite.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/CipherSuite.java	2018-05-20 04:52:08.207912557 +0100
@@ -399,7 +399,7 @@
 
         // Map BulkCipher -> Boolean(available)
         private final static Map<BulkCipher,Boolean> availableCache =
-                                            new HashMap<>(8);
+            new HashMap<BulkCipher,Boolean>(8);
 
         // descriptive name including key size, e.g. AES/128
         final String description;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java	2018-05-20 04:52:08.207912557 +0100
@@ -805,7 +805,7 @@
         if (certRequest != null) {
             X509ExtendedKeyManager km = sslContext.getX509KeyManager();
 
-            ArrayList<String> keytypesTmp = new ArrayList<>(4);
+            ArrayList<String> keytypesTmp = new ArrayList<String>(4);
 
             for (int i = 0; i < certRequest.types.length; i++) {
                 String typeName;
@@ -1375,7 +1375,7 @@
                         "Can't reuse existing SSL client session");
                 }
 
-                Collection<CipherSuite> cipherList = new ArrayList<>(2);
+                Collection<CipherSuite> cipherList = new ArrayList<CipherSuite>(2);
                 cipherList.add(sessionSuite);
                 if (!secureRenegotiation &&
                         cipherSuites.contains(CipherSuite.C_SCSV)) {
@@ -1393,7 +1393,7 @@
         // exclude SCSV for secure renegotiation
         if (secureRenegotiation && cipherSuites.contains(CipherSuite.C_SCSV)) {
             Collection<CipherSuite> cipherList =
-                        new ArrayList<>(cipherSuites.size() - 1);
+                        new ArrayList<CipherSuite>(cipherSuites.size() - 1);
             for (CipherSuite suite : cipherSuites.collection()) {
                 if (suite != CipherSuite.C_SCSV) {
                     cipherList.add(suite);
@@ -1675,7 +1675,7 @@
                 if ((subAltDnsName != null) && !subAltDnsName.isEmpty()) {
                     if (subAltDnsNames == null) {
                         subAltDnsNames =
-                                new HashSet<>(subjectAltNames.size());
+                                new HashSet<String>(subjectAltNames.size());
                     }
                     subAltDnsNames.add(subAltDnsName);
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/DHCrypt.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/DHCrypt.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/DHCrypt.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/DHCrypt.java	2018-05-20 04:52:08.207912557 +0100
@@ -493,7 +493,7 @@
                 }
             }
 
-            Map<Integer,DHParameterSpec> defaultParams = new HashMap<>();
+            Map<Integer,DHParameterSpec> defaultParams = new HashMap<Integer,DHParameterSpec>();
             if (property != null && !property.isEmpty()) {
                 Matcher syntaxMatcher = syntaxPattern.matcher(property);
                 if (syntaxMatcher.matches()) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/EllipticCurvesExtension.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/EllipticCurvesExtension.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/EllipticCurvesExtension.java	2018-05-20 04:38:32.124844379 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/EllipticCurvesExtension.java	2018-05-20 04:52:08.207912557 +0100
@@ -50,12 +50,12 @@
     private static final int ARBITRARY_CHAR2 = 0xff02;
 
     // speed up the searching
-    private static final Map<String, Integer> oidToIdMap = new HashMap<>();
-    private static final Map<Integer, String> idToOidMap = new HashMap<>();
+    private static final Map<String, Integer> oidToIdMap = new HashMap<String, Integer>();
+    private static final Map<Integer, String> idToOidMap = new HashMap<Integer, String>();
 
     // speed up the parameters construction
     private static final Map<Integer,
-                AlgorithmParameters> idToParams = new HashMap<>();
+	AlgorithmParameters> idToParams = new HashMap<Integer, AlgorithmParameters>();
 
     // the supported elliptic curves
     private static final int[] supportedCurveIds;
@@ -126,7 +126,7 @@
         ArrayList<Integer> idList;
         if (property != null && property.length() != 0) {   // customized curves
             String[] curves = property.split(",");
-            idList = new ArrayList<>(curves.length);
+            idList = new ArrayList<Integer>(curves.length);
             for (String curve : curves) {
                 curve = curve.trim();
                 if (!curve.isEmpty()) {
@@ -150,7 +150,7 @@
 		23, 24, 25
 	    };
 
-            idList = new ArrayList<>(ids.length);
+            idList = new ArrayList<Integer>(ids.length);
             for (int curveId : ids) {
                 if (isAvailableCurve(curveId)) {
                     idList.add(curveId);
@@ -225,7 +225,7 @@
     static EllipticCurvesExtension createExtension(
                 AlgorithmConstraints constraints) {
 
-        ArrayList<Integer> idList = new ArrayList<>(supportedCurveIds.length);
+        ArrayList<Integer> idList = new ArrayList<Integer>(supportedCurveIds.length);
         for (int curveId : supportedCurveIds) {
             if (constraints.permits(
                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/EllipticPointFormatsExtension.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/EllipticPointFormatsExtension.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/EllipticPointFormatsExtension.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/EllipticPointFormatsExtension.java	2018-05-20 04:52:08.207912557 +0100
@@ -92,7 +92,7 @@
     }
 
     public String toString() {
-        List<String> list = new ArrayList<>();
+        List<String> list = new ArrayList<String>();
         for (byte format : formats) {
             list.add(toString(format));
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ExtensionType.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/ExtensionType.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ExtensionType.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/ExtensionType.java	2018-05-20 04:52:08.207912557 +0100
@@ -42,7 +42,7 @@
         return name;
     }
 
-    static List<ExtensionType> knownExtensions = new ArrayList<>(14);
+    static List<ExtensionType> knownExtensions = new ArrayList<ExtensionType>(14);
 
     static ExtensionType get(int id) {
         for (ExtensionType ext : knownExtensions) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java	2018-05-20 04:38:34.324809511 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/HandshakeMessage.java	2018-05-20 04:52:08.207912557 +0100
@@ -255,7 +255,7 @@
     // add server_name extension
     void addServerNameIndicationExtension(String hostname) {
         // We would have checked that the hostname ia a FQDN.
-        ArrayList<String> hostnames = new ArrayList<>(1);
+        ArrayList<String> hostnames = new ArrayList<String>(1);
         hostnames.add(hostname);
 
         try {
@@ -435,7 +435,7 @@
 
     CertificateMsg(HandshakeInStream input) throws IOException {
         int chainLen = input.getInt24();
-        List<Certificate> v = new ArrayList<>(4);
+        List<Certificate> v = new ArrayList<Certificate>(4);
 
         CertificateFactory cf = null;
         while (chainLen > 0) {
@@ -1343,7 +1343,7 @@
 
         // read the certificate_authorities
         int len = input.getInt16();
-        ArrayList<DistinguishedName> v = new ArrayList<>();
+        ArrayList<DistinguishedName> v = new ArrayList<DistinguishedName>();
         while (len >= 3) {
             DistinguishedName dn = new DistinguishedName(input);
             v.add(dn);
@@ -1734,7 +1734,7 @@
     // Note that this will prevent the Spi classes from being GC'd. We assume
     // that is not a problem.
     private final static Map<Class<?>,Object> methodCache =
-                                        new ConcurrentHashMap<>();
+	new ConcurrentHashMap<Class<?>, Object>();
 
     private static void digestKey(MessageDigest md, SecretKey key) {
         try {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/Handshaker.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/Handshaker.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/Handshaker.java	2018-05-20 04:38:34.908800255 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/Handshaker.java	2018-05-20 04:52:08.207912557 +0100
@@ -618,7 +618,7 @@
                 activeProtocols = getActiveProtocols();
             }
 
-            ArrayList<CipherSuite> suites = new ArrayList<>();
+            ArrayList<CipherSuite> suites = new ArrayList<CipherSuite>();
             if (!(activeProtocols.collection().isEmpty()) &&
                     activeProtocols.min.v != ProtocolVersion.NONE.v) {
                 boolean checkedCurves = false;
@@ -694,7 +694,7 @@
             boolean enabledSSL20Hello = false;
             boolean checkedCurves = false;
             boolean hasCurves = false;
-            ArrayList<ProtocolVersion> protocols = new ArrayList<>(4);
+            ArrayList<ProtocolVersion> protocols = new ArrayList<ProtocolVersion>(4);
             EnumSet<CryptoPrimitive> cryptoPrimitives =
                 EnumSet.<CryptoPrimitive>of(CryptoPrimitive.KEY_AGREEMENT);
             for (ProtocolVersion protocol : enabledProtocols.collection()) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ProtocolList.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/ProtocolList.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ProtocolList.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/ProtocolList.java	2018-05-20 04:52:08.207912557 +0100
@@ -79,7 +79,7 @@
             throw new IllegalArgumentException("Protocols may not be null");
         }
 
-        ArrayList<ProtocolVersion> versions = new ArrayList<>(3);
+        ArrayList<ProtocolVersion> versions = new ArrayList<ProtocolVersion>(3);
         for (int i = 0; i < names.length; i++ ) {
             ProtocolVersion version = ProtocolVersion.valueOf(names[i]);
             if (versions.contains(version) == false) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ProtocolVersion.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/ProtocolVersion.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/ProtocolVersion.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/ProtocolVersion.java	2018-05-20 04:52:08.207912557 +0100
@@ -106,7 +106,7 @@
 
     // Initialize the available protocols.
     static {
-        Set<ProtocolVersion> protocols = new HashSet<>(5);
+        Set<ProtocolVersion> protocols = new HashSet<ProtocolVersion>(5);
 
         ProtocolVersion[] pvs = new ProtocolVersion[] {
                 SSL20Hello, SSL30, TLS10, TLS11, TLS12};
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java	2018-05-20 04:52:08.207912557 +0100
@@ -156,7 +156,7 @@
     static Collection<SignatureAndHashAlgorithm>
             getSupportedAlgorithms(AlgorithmConstraints constraints) {
 
-        Collection<SignatureAndHashAlgorithm> supported = new ArrayList<>();
+        Collection<SignatureAndHashAlgorithm> supported = new ArrayList<SignatureAndHashAlgorithm>();
         synchronized (priorityMap) {
             for (SignatureAndHashAlgorithm sigAlg : priorityMap.values()) {
                 if (sigAlg.priority <= SUPPORTED_ALG_PRIORITY_MAX_NUM &&
@@ -174,7 +174,7 @@
     static Collection<SignatureAndHashAlgorithm> getSupportedAlgorithms(
             AlgorithmConstraints constraints,
             Collection<SignatureAndHashAlgorithm> algorithms ) {
-        Collection<SignatureAndHashAlgorithm> supported = new ArrayList<>();
+        Collection<SignatureAndHashAlgorithm> supported = new ArrayList<SignatureAndHashAlgorithm>();
         for (SignatureAndHashAlgorithm sigAlg : algorithms) {
             if (sigAlg.priority <= SUPPORTED_ALG_PRIORITY_MAX_NUM &&
                     constraints.permits(SIGNATURE_PRIMITIVE_SET,
@@ -188,7 +188,7 @@
 
     static String[] getAlgorithmNames(
             Collection<SignatureAndHashAlgorithm> algorithms) {
-        ArrayList<String> algorithmNames = new ArrayList<>();
+        ArrayList<String> algorithmNames = new ArrayList<String>();
         if (algorithms != null) {
             for (SignatureAndHashAlgorithm sigAlg : algorithms) {
                 algorithmNames.add(sigAlg.algorithm);
@@ -201,7 +201,7 @@
 
     static Set<String> getHashAlgorithmNames(
             Collection<SignatureAndHashAlgorithm> algorithms) {
-        Set<String> algorithmNames = new HashSet<>();
+        Set<String> algorithmNames = new HashSet<String>();
         if (algorithms != null) {
             for (SignatureAndHashAlgorithm sigAlg : algorithms) {
                 if (sigAlg.hash.value > 0) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLAlgorithmDecomposer.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLAlgorithmDecomposer.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLAlgorithmDecomposer.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLAlgorithmDecomposer.java	2018-05-20 04:52:08.207912557 +0100
@@ -48,7 +48,7 @@
     }
 
     private Set<String> decomposes(CipherSuite.KeyExchange keyExchange) {
-        Set<String> components = new HashSet<>();
+        Set<String> components = new HashSet<String>();
         switch (keyExchange) {
             case K_NULL:
                 if (!onlyX509) {
@@ -143,7 +143,7 @@
     }
 
     private Set<String> decomposes(CipherSuite.BulkCipher bulkCipher) {
-        Set<String> components = new HashSet<>();
+        Set<String> components = new HashSet<String>();
 
         if (bulkCipher.transformation != null) {
             components.addAll(super.decompose(bulkCipher.transformation));
@@ -175,7 +175,7 @@
 
     private Set<String> decomposes(CipherSuite.MacAlg macAlg,
             BulkCipher cipher) {
-        Set<String> components = new HashSet<>();
+        Set<String> components = new HashSet<String>();
 
         if (macAlg == M_NULL) {
             components.add("M_NULL");
@@ -201,7 +201,7 @@
 
     private Set<String> decompose(KeyExchange keyExchange, BulkCipher cipher,
             MacAlg macAlg) {
-        Set<String> components = new HashSet<>();
+        Set<String> components = new HashSet<String>();
 
         if (keyExchange != null) {
             components.addAll(decomposes(keyExchange));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLContextImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLContextImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLContextImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLContextImpl.java	2018-05-20 04:52:08.207912557 +0100
@@ -329,7 +329,7 @@
         Collection<CipherSuite> allowedCipherSuites =
                                     CipherSuite.allowedCipherSuites();
 
-        TreeSet<CipherSuite> suites = new TreeSet<>();
+        TreeSet<CipherSuite> suites = new TreeSet<CipherSuite>();
         if (!(protocols.collection().isEmpty()) &&
                 protocols.min.v != ProtocolVersion.NONE.v) {
             for (CipherSuite suite : allowedCipherSuites) {
@@ -387,7 +387,7 @@
 
         List<String> availableProtocols = Collections.<String>emptyList();
         if (protocolCandidates != null && protocolCandidates.length != 0) {
-            availableProtocols = new ArrayList<>(protocolCandidates.length);
+            availableProtocols = new ArrayList<String>(protocolCandidates.length);
             for (ProtocolVersion p : protocolCandidates) {
                 if (ProtocolVersion.availableProtocols.contains(p)) {
                     availableProtocols.add(p.name);
@@ -770,7 +770,7 @@
                 return defaultKeyManagers;
             }
 
-            final Map<String,String> props = new HashMap<>();
+            final Map<String,String> props = new HashMap<String,String>();
             AccessController.doPrivileged(
                         new PrivilegedExceptionAction<Object>() {
                 public Object run() throws Exception {
@@ -1016,7 +1016,7 @@
             // Does the certificate chain end with a trusted certificate?
             int checkedLength = chain.length - 1;
 
-            Collection<X509Certificate> trustedCerts = new HashSet<>();
+            Collection<X509Certificate> trustedCerts = new HashSet<X509Certificate>();
             X509Certificate[] certs = tm.getAcceptedIssuers();
             if ((certs != null) && (certs.length > 0)){
                 Collections.addAll(trustedCerts, certs);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java	2018-05-20 04:52:08.207912557 +0100
@@ -651,7 +651,7 @@
      * key and the calling security context. This is important since
      * sessions can be shared across different protection domains.
      */
-    private Hashtable<SecureKey, Object> table = new Hashtable<>();
+    private Hashtable<SecureKey, Object> table = new Hashtable<SecureKey, Object>();
 
     /**
      * Assigns a session value.  Session change events are given if
@@ -719,7 +719,7 @@
      */
     public String[] getValueNames() {
         Enumeration<SecureKey> e;
-        Vector<Object> v = new Vector<>();
+        Vector<Object> v = new Vector<Object>();
         SecureKey key;
         Object securityCtx = SecureKey.getCurrentSecurityContext();
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLSocketImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLSocketImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SSLSocketImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SSLSocketImpl.java	2018-05-20 04:52:08.211912493 +0100
@@ -2561,7 +2561,7 @@
             entrySet, HandshakeCompletedEvent e) {
 
             super("HandshakeCompletedNotify-Thread");
-            targets = new HashSet<>(entrySet);          // clone the entry set
+            targets = new HashSet(entrySet);          // clone the entry set
             event = e;
         }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SunX509KeyManagerImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/SunX509KeyManagerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/SunX509KeyManagerImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/SunX509KeyManagerImpl.java	2018-05-20 04:52:08.211912493 +0100
@@ -337,7 +337,7 @@
 
         X500Principal[] x500Issuers = (X500Principal[])issuers;
         // the algorithm below does not produce duplicates, so avoid Set
-        List<String> aliases = new ArrayList<>();
+        List<String> aliases = new ArrayList<String>();
 
         for (Map.Entry<String,X509Credentials> entry :
                                                 credentialsMap.entrySet()) {
@@ -397,7 +397,7 @@
      * possible. Principals that cannot be converted are ignored.
      */
     private static X500Principal[] convertPrincipals(Principal[] principals) {
-        List<X500Principal> list = new ArrayList<>(principals.length);
+        List<X500Principal> list = new ArrayList<X500Principal>(principals.length);
         for (int i = 0; i < principals.length; i++) {
             Principal p = principals[i];
             if (p instanceof X500Principal) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/TrustManagerFactoryImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/TrustManagerFactoryImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/TrustManagerFactoryImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/TrustManagerFactoryImpl.java	2018-05-20 04:52:08.211912493 +0100
@@ -134,7 +134,7 @@
         FileInputStream fis = null;
         String defaultTrustStoreType;
         String defaultTrustStoreProvider;
-        final HashMap<String,String> props = new HashMap<>();
+        final HashMap<String,String> props = new HashMap<String,String>();
         final String sep = File.separator;
         KeyStore ks = null;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/X509KeyManagerImpl.java openjdk-boot/jdk/src/share/classes/sun/security/ssl/X509KeyManagerImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/ssl/X509KeyManagerImpl.java	2018-05-20 04:38:34.324809511 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/ssl/X509KeyManagerImpl.java	2018-05-20 04:52:08.211912493 +0100
@@ -310,7 +310,7 @@
                 (keyTypes.length == 0) || (keyTypes[0] == null)) {
             return null;
         }
-        List<KeyType> list = new ArrayList<>(keyTypes.length);
+        List<KeyType> list = new ArrayList<KeyType>(keyTypes.length);
         for (String keyType : keyTypes) {
             list.add(new KeyType(keyType));
         }
@@ -432,7 +432,7 @@
     // make a Set out of the array
     private Set<Principal> getIssuerSet(Principal[] issuers) {
         if ((issuers != null) && (issuers.length != 0)) {
-            return new HashSet<>(Arrays.asList(issuers));
+            return new HashSet<Principal>(Arrays.asList(issuers));
         } else {
             return null;
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/jarsigner/Main.java openjdk-boot/jdk/src/share/classes/sun/security/tools/jarsigner/Main.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/jarsigner/Main.java	2018-05-20 04:38:34.968799304 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/tools/jarsigner/Main.java	2018-05-20 04:52:08.211912493 +0100
@@ -134,14 +134,14 @@
     boolean token = false; // token-based keystore
     String jarfile;  // jar files to sign or verify
     String alias;    // alias to sign jar with
-    List<String> ckaliases = new ArrayList<>(); // aliases in -verify
+    List<String> ckaliases = new ArrayList<String>(); // aliases in -verify
     char[] storepass; // keystore password
     boolean protectedPath; // protected authentication path
     String storetype; // keystore type
     String providerName; // provider name
     Vector<String> providers = null; // list of providers
     // arguments for provider constructors
-    HashMap<String,String> providerArgs = new HashMap<>();
+    HashMap<String,String> providerArgs = new HashMap<String,String>();
     char[] keypass; // private key password
     String sigfile; // name of .SF file
     String sigalg; // name of signature algorithm
@@ -592,14 +592,14 @@
     {
         boolean anySigned = false;  // if there exists entry inside jar signed
         JarFile jf = null;
-        Map<String,String> digestMap = new HashMap<>();
-        Map<String,PKCS7> sigMap = new HashMap<>();
-        Map<String,String> sigNameMap = new HashMap<>();
-        Map<String,String> unparsableSignatures = new HashMap<>();
+        Map<String,String> digestMap = new HashMap<String,String>();
+        Map<String,PKCS7> sigMap = new HashMap<String,PKCS7>();
+        Map<String,String> sigNameMap = new HashMap<String,String>();
+        Map<String,String> unparsableSignatures = new HashMap<String,String>();
 
         try {
             jf = new JarFile(jarName, true);
-            Vector<JarEntry> entriesVec = new Vector<>();
+            Vector<JarEntry> entriesVec = new Vector<JarEntry>();
             byte[] buffer = new byte[8192];
 
             Enumeration<JarEntry> entries = jf.entries();
@@ -662,7 +662,7 @@
             // The map to record display info, only used when -verbose provided
             //      key: signer info string
             //      value: the list of files with common key
-            Map<String,List<String>> output = new LinkedHashMap<>();
+            Map<String,List<String>> output = new LinkedHashMap<String,List<String>>();
 
             if (man != null) {
                 if (verbose != null) System.out.println();
@@ -1167,7 +1167,7 @@
             .append(signTimeForm.format(source)).append("]").toString();
     }
 
-    private Map<CodeSigner,Integer> cacheForInKS = new IdentityHashMap<>();
+    private Map<CodeSigner,Integer> cacheForInKS = new IdentityHashMap<CodeSigner,Integer>();
 
     private int inKeyStoreForOneSigner(CodeSigner signer) {
         if (cacheForInKS.containsKey(signer)) {
@@ -1210,7 +1210,7 @@
         return result;
     }
 
-    Hashtable<Certificate, String> storeHash = new Hashtable<>();
+    Hashtable<Certificate, String> storeHash = new Hashtable<Certificate,String>();
 
     int inKeyStore(CodeSigner[] signers) {
 
@@ -1340,7 +1340,7 @@
              *   generated one. (This may invalidate existing signatures!)
              */
             BASE64Encoder encoder = new JarBASE64Encoder();
-            Vector<ZipEntry> mfFiles = new Vector<>();
+            Vector<ZipEntry> mfFiles = new Vector<ZipEntry>();
 
             boolean wasSigned = false;
 
@@ -1709,7 +1709,7 @@
         return SignatureFileVerifier.isSigningRelated(name);
     }
 
-    Map<CodeSigner,String> cacheForSignerInfo = new IdentityHashMap<>();
+    Map<CodeSigner,String> cacheForSignerInfo = new IdentityHashMap<CodeSigner,String>();
 
     /**
      * Returns a string of singer info, with a newline at the end
@@ -1810,7 +1810,7 @@
 
             certificateFactory = CertificateFactory.getInstance("X.509");
             validator = CertPathValidator.getInstance("PKIX");
-            Set<TrustAnchor> tas = new HashSet<>();
+            Set<TrustAnchor> tas = new HashSet<TrustAnchor>();
             try {
                 KeyStore caks = KeyStoreUtil.getCacertsKeyStore();
                 if (caks != null) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/keytool/Main.java openjdk-boot/jdk/src/share/classes/sun/security/tools/keytool/Main.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/keytool/Main.java	2018-05-20 04:38:34.972799241 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/tools/keytool/Main.java	2018-05-20 04:52:08.211912493 +0100
@@ -159,11 +159,11 @@
     private KeyStore caks = null; // "cacerts" keystore
     private char[] srcstorePass = null;
     private String srcstoretype = null;
-    private Set<char[]> passwords = new HashSet<>();
+    private Set<char[]> passwords = new HashSet<char[]>();
     private String startDate = null;
 
-    private List<String> ids = new ArrayList<>();   // used in GENCRL
-    private List<String> v3ext = new ArrayList<>();
+    private List<String> ids = new ArrayList<String>();   // used in GENCRL
+    private List<String> v3ext = new ArrayList<String>();
 
     // In-place importkeystore is special.
     // A backup is needed, and no need to prompt for deststorepass.
@@ -171,7 +171,7 @@
     private String inplaceBackupName = null;
 
     // Warnings on weak algorithms etc
-    private List<String> weakWarnings = new ArrayList<>();
+    private List<String> weakWarnings = new ArrayList<String>();
 
     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
             new DisabledAlgorithmConstraints(
@@ -2262,7 +2262,7 @@
      */
     public static List<CRL> readCRLsFromCert(X509Certificate cert)
             throws Exception {
-        List<CRL> crls = new ArrayList<>();
+        List<CRL> crls = new ArrayList<CRL>();
         CRLDistributionPointsExtension ext =
                 X509CertImpl.toImpl(cert).getCRLDistributionPointsExtension();
         if (ext == null) return crls;
@@ -2465,7 +2465,7 @@
         if (jarfile != null) {
             JarFile jf = new JarFile(jarfile, true);
             Enumeration<JarEntry> entries = jf.entries();
-            Set<CodeSigner> ss = new HashSet<>();
+            Set<CodeSigner> ss = new HashSet<CodeSigner>();
             byte[] buffer = new byte[8192];
             int pos = 0;
             while (entries.hasMoreElements()) {
@@ -3131,7 +3131,7 @@
     private static Pair<String,Certificate>
             getSigner(Certificate cert, KeyStore ks) throws Exception {
         if (ks.getCertificateAlias(cert) != null) {
-            return new Pair<>("", cert);
+            return new Pair<String, Certificate>("", cert);
         }
         for (Enumeration<String> aliases = ks.aliases();
                 aliases.hasMoreElements(); ) {
@@ -3140,7 +3140,7 @@
             if (trustedCert != null) {
                 try {
                     cert.verify(trustedCert.getPublicKey());
-                    return new Pair<>(name, trustedCert);
+                    return new Pair<String, Certificate>(name, trustedCert);
                 } catch (Exception e) {
                     // Not verified, skip to the next one
                 }
@@ -3558,22 +3558,22 @@
         // name are stored in the same hash table entry as a vector.
         Hashtable<Principal, Vector<Pair<String,X509Certificate>>> certs = null;
         if (keyStore.size() > 0) {
-            certs = new Hashtable<>(11);
+            certs = new Hashtable<Principal, Vector<Pair<String,X509Certificate>>>(11);
             keystorecerts2Hashtable(keyStore, certs);
         }
         if (trustcacerts) {
             if (caks!=null && caks.size()>0) {
                 if (certs == null) {
-                    certs = new Hashtable<>(11);
+                    certs = new Hashtable<Principal, Vector<Pair<String,X509Certificate>>>(11);
                 }
                 keystorecerts2Hashtable(caks, certs);
             }
         }
 
         // start building chain
-        Vector<Pair<String,X509Certificate>> chain = new Vector<>(2);
+	    Vector<Pair<String,X509Certificate>> chain = new Vector<Pair<String,X509Certificate>>(2);
         if (buildChain(
-                new Pair<>(rb.getString("the.input"),
+	        new Pair<String,X509Certificate>(rb.getString("the.input"),
                            (X509Certificate) certToVerify),
                 chain, certs)) {
             for (Pair<String,X509Certificate> p : chain) {
@@ -3703,7 +3703,7 @@
             Certificate cert = ks.getCertificate(alias);
             if (cert != null) {
                 Principal subjectDN = ((X509Certificate)cert).getSubjectDN();
-                Pair<String,X509Certificate> pair = new Pair<>(
+                Pair<String,X509Certificate> pair = new Pair<String, X509Certificate>(
                         String.format(
                                 rb.getString(ks == caks ?
                                         "alias.in.cacerts" :
@@ -3712,7 +3712,7 @@
                         (X509Certificate)cert);
                 Vector<Pair<String,X509Certificate>> vec = hash.get(subjectDN);
                 if (vec == null) {
-                    vec = new Vector<>();
+                    vec = new Vector<Pair<String,X509Certificate>>();
                     vec.addElement(pair);
                 } else {
                     if (!vec.contains(pair)) {
@@ -4095,7 +4095,7 @@
                         break;
                     case 2:     // EKU
                         if(value != null) {
-                            Vector<ObjectIdentifier> v = new Vector<>();
+                            Vector<ObjectIdentifier> v = new Vector<ObjectIdentifier>();
                             for (String s: value.split(",")) {
                                 int p = oneOf(s,
                                         "anyExtendedKeyUsage",
@@ -4165,7 +4165,7 @@
                         }
                         if(value != null) {
                             List<AccessDescription> accessDescriptions =
-                                    new ArrayList<>();
+                                    new ArrayList<AccessDescription>();
                             String[] ps = value.split(",");
                             for(String item: ps) {
                                 colonpos = item.indexOf(':');
@@ -4476,7 +4476,7 @@
     }
 
     public static <A,B> Pair<A,B> of(A a, B b) {
-        return new Pair<>(a,b);
+        return new Pair<A,B>(a,b);
     }
 }
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/policytool/PolicyTool.java openjdk-boot/jdk/src/share/classes/sun/security/tools/policytool/PolicyTool.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/tools/policytool/PolicyTool.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/tools/policytool/PolicyTool.java	2018-05-20 04:52:08.211912493 +0100
@@ -645,7 +645,7 @@
         Class<?> pc = Class.forName(type, true,
                 Thread.currentThread().getContextClassLoader());
         Constructor<?> c = null;
-        Vector<String> objects = new Vector<>(2);
+        Vector<String> objects = new Vector<String>(2);
         if (name != null) objects.add(name);
         if (actions != null) objects.add(actions);
         switch (objects.size()) {
@@ -1725,7 +1725,7 @@
                         new PolicyParser.GrantEntry(signedby, codebase);
 
         // get the new Principals
-        LinkedList<PolicyParser.PrincipalEntry> prins = new LinkedList<>();
+        LinkedList<PolicyParser.PrincipalEntry> prins = new LinkedList<PolicyParser.PrincipalEntry>();
         TaggedList prinList = (TaggedList)getComponent(PE_PRIN_LIST);
         for (int i = 0; i < prinList.getItemCount(); i++) {
             prins.add((PolicyParser.PrincipalEntry)prinList.getObject(i));
@@ -1733,7 +1733,7 @@
         ge.principals = prins;
 
         // get the new Permissions
-        Vector<PolicyParser.PermissionEntry> perms = new Vector<>();
+        Vector<PolicyParser.PermissionEntry> perms = new Vector<PolicyParser.PermissionEntry>();
         TaggedList permList = (TaggedList)getComponent(PE_PERM_LIST);
         for (int i = 0; i < permList.getItemCount(); i++) {
             perms.addElement((PolicyParser.PermissionEntry)permList.getObject(i));
@@ -3665,7 +3665,7 @@
 class TaggedList extends List {
     private static final long serialVersionUID = -5676238110427785853L;
 
-    private java.util.List<Object> data = new LinkedList<>();
+    private java.util.List<Object> data = new LinkedList<Object>();
     public TaggedList(int i, boolean b) {
         super(i, b);
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/util/AlgorithmDecomposer.java openjdk-boot/jdk/src/share/classes/sun/security/util/AlgorithmDecomposer.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/util/AlgorithmDecomposer.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/util/AlgorithmDecomposer.java	2018-05-20 04:52:08.211912493 +0100
@@ -45,7 +45,7 @@
         // algorithm/mode/padding
         String[] transTockens = transPattern.split(algorithm);
 
-        Set<String> elements = new HashSet<>();
+        Set<String> elements = new HashSet<String>();
         for (String transTocken : transTockens) {
             if (transTocken == null || transTocken.length() == 0) {
                 continue;
@@ -80,7 +80,7 @@
      */
     public Set<String> decompose(String algorithm) {
         if (algorithm == null || algorithm.length() == 0) {
-            return new HashSet<>();
+            return new HashSet<String>();
         }
 
         Set<String> elements = decomposeImpl(algorithm);
@@ -167,7 +167,7 @@
      */
     public static Set<String> decomposeOneHash(String algorithm) {
         if (algorithm == null || algorithm.length() == 0) {
-            return new HashSet<>();
+            return new HashSet<String>();
         }
 
         Set<String> elements = decomposeImpl(algorithm);
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/util/AnchorCertificates.java openjdk-boot/jdk/src/share/classes/sun/security/util/AnchorCertificates.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/util/AnchorCertificates.java	2018-05-20 04:38:34.968799304 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/util/AnchorCertificates.java	2018-05-20 04:52:08.211912493 +0100
@@ -61,7 +61,7 @@
                     try {
 			fis = new FileInputStream(f);
                         cacerts.load(fis, null);
-                        certs = new HashSet<>();
+                        certs = new HashSet<String>();
                         Enumeration<String> list = cacerts.aliases();
                         String alias;
                         while (list.hasMoreElements()) {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/util/DisabledAlgorithmConstraints.java openjdk-boot/jdk/src/share/classes/sun/security/util/DisabledAlgorithmConstraints.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/util/DisabledAlgorithmConstraints.java	2018-05-20 04:38:34.324809511 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/util/DisabledAlgorithmConstraints.java	2018-05-20 04:52:08.211912493 +0100
@@ -229,7 +229,7 @@
      */
 
     private static class Constraints {
-        private Map<String, List<Constraint>> constraintsMap = new HashMap<>();
+        private Map<String, List<Constraint>> constraintsMap = new HashMap<String, List<Constraint>>();
 
         private static class Holder {
             private static final Pattern DENY_AFTER_PATTERN = Pattern.compile(
@@ -257,7 +257,7 @@
 
                 List<Constraint> constraintList = constraintsMap.get(algorithm);
                 if (constraintList == null) {
-                    constraintList = new ArrayList<>(1);
+                    constraintList = new ArrayList<Constraint>(1);
                 }
 
                 // Consider the impact of algorithm aliases.
@@ -407,7 +407,7 @@
             }
 
             // Get all signature algorithms to check for constraints
-            Set<String> algorithms = new HashSet<>();
+            Set<String> algorithms = new HashSet<String>();
             if (algorithm != null) {
                 algorithms.addAll(AlgorithmDecomposer.decomposeOneHash(algorithm));
             }
@@ -1477,7 +1477,7 @@
     private static class AvailableCalendarTypes {
         private static final Set<String> SET;
         static {
-            Set<String> set = new HashSet<>(3);
+            Set<String> set = new HashSet<String>(3);
             set.add("gregory");
             set.add("buddhist");
             set.add("japanese");
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/util/ManifestDigester.java openjdk-boot/jdk/src/share/classes/sun/security/util/ManifestDigester.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/util/ManifestDigester.java	2018-05-20 15:21:43.778280298 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/util/ManifestDigester.java	2018-05-20 15:22:11.881836570 +0100
@@ -203,7 +203,7 @@
         // According to the JAR File Specification: "If there are multiple
         // individual sections for the same file entry, the attributes in
         // these sections are merged."
-        private List<Section> sections = new ArrayList<>();
+        private List<Section> sections = new ArrayList<Section>();
         boolean oldStyle;
 
         private Entry addSection(Section sec)
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java openjdk-boot/jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java	2018-05-20 04:52:08.211912493 +0100
@@ -96,7 +96,7 @@
     private CertificateFactory certificateFactory = null;
 
     /** Algorithms that have been checked if they are weak. */
-    private Map<String, Boolean> permittedAlgs= new HashMap<>();
+    private Map<String, Boolean> permittedAlgs= new HashMap<String, Boolean>();
 
     /** TSA timestamp of signed jar.  The newest timestamp is used.  If there
      *  was no TSA timestamp used when signed, current time is used ("null").
@@ -231,7 +231,7 @@
     private MessageDigest getDigest(String algorithm)
             throws SignatureException {
         if (createdDigests == null)
-            createdDigests = new HashMap<>();
+            createdDigests = new HashMap<String, MessageDigest>();
 
         MessageDigest digest = createdDigests.get(algorithm);
 
@@ -723,7 +723,7 @@
             ArrayList<X509Certificate> chain = info.getCertificateChain(block);
             CertPath certChain = certificateFactory.generateCertPath(chain);
             if (signers == null) {
-                signers = new ArrayList<>();
+                signers = new ArrayList<CodeSigner>();
             }
             // Append the new code signer
             signers.add(new CodeSigner(certChain, info.getTimestamp()));
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/x509/X509CertImpl.java openjdk-boot/jdk/src/share/classes/sun/security/x509/X509CertImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/x509/X509CertImpl.java	2018-05-20 04:38:34.908800255 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/x509/X509CertImpl.java	2018-05-20 04:52:08.211912493 +0100
@@ -1278,7 +1278,7 @@
             if (exts == null) {
                 return null;
             }
-            Set<String> extSet = new TreeSet<>();
+            Set<String> extSet = new TreeSet<String>();
             for (Extension ex : exts.getAllExtensions()) {
                 if (ex.isCritical()) {
                     extSet.add(ex.getExtensionId().toString());
@@ -1308,7 +1308,7 @@
             if (exts == null) {
                 return null;
             }
-            Set<String> extSet = new TreeSet<>();
+            Set<String> extSet = new TreeSet<String>();
             for (Extension ex : exts.getAllExtensions()) {
                 if (!ex.isCritical()) {
                     extSet.add(ex.getExtensionId().toString());
@@ -1545,10 +1545,10 @@
         if (names.isEmpty()) {
             return Collections.<List<?>>emptySet();
         }
-        List<List<?>> newNames = new ArrayList<>();
+        List<List<?>> newNames = new ArrayList<List<?>>();
         for (GeneralName gname : names.names()) {
             GeneralNameInterface name = gname.getName();
-            List<Object> nameEntry = new ArrayList<>(2);
+            List<Object> nameEntry = new ArrayList<Object>(2);
             nameEntry.add(Integer.valueOf(name.getType()));
             switch (name.getType()) {
             case GeneralNameInterface.NAME_RFC822:
@@ -1606,12 +1606,12 @@
             }
         }
         if (mustClone) {
-            List<List<?>> namesCopy = new ArrayList<>();
+            List<List<?>> namesCopy = new ArrayList<List<?>>();
             for (List<?> nameEntry : altNames) {
                 Object nameObject = nameEntry.get(1);
                 if (nameObject instanceof byte[]) {
                     List<Object> nameEntryCopy =
-                                        new ArrayList<>(nameEntry);
+                                        new ArrayList<Object>(nameEntry);
                     nameEntryCopy.set(1, ((byte[])nameObject).clone());
                     namesCopy.add(Collections.unmodifiableList(nameEntryCopy));
                 } else {
@@ -1930,7 +1930,7 @@
     }
 
     private ConcurrentHashMap<String,String> fingerprints =
-            new ConcurrentHashMap<>(2);
+	new ConcurrentHashMap<String, String>(2);
 
     public String getFingerprint(String algorithm) {
         String fingerprint = null;
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/x509/X509CRLEntryImpl.java openjdk-boot/jdk/src/share/classes/sun/security/x509/X509CRLEntryImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/x509/X509CRLEntryImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/x509/X509CRLEntryImpl.java	2018-05-20 04:52:08.211912493 +0100
@@ -350,7 +350,7 @@
         if (extensions == null) {
             return null;
         }
-        Set<String> extSet = new TreeSet<>();
+        Set<String> extSet = new TreeSet<String>();
         for (Extension ex : extensions.getAllExtensions()) {
             if (ex.isCritical()) {
                 extSet.add(ex.getExtensionId().toString());
@@ -371,7 +371,7 @@
         if (extensions == null) {
             return null;
         }
-        Set<String> extSet = new TreeSet<>();
+        Set<String> extSet = new TreeSet<String>();
         for (Extension ex : extensions.getAllExtensions()) {
             if (!ex.isCritical()) {
                 extSet.add(ex.getExtensionId().toString());
@@ -508,7 +508,7 @@
             return Collections.emptyMap();
         }
         Collection<Extension> exts = extensions.getAllExtensions();
-        Map<String, java.security.cert.Extension> map = new TreeMap<>();
+        Map<String, java.security.cert.Extension> map = new TreeMap<String, java.security.cert.Extension>();
         for (Extension ext : exts) {
             map.put(ext.getId(), ext);
         }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/security/x509/X509CRLImpl.java openjdk-boot/jdk/src/share/classes/sun/security/x509/X509CRLImpl.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/security/x509/X509CRLImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/security/x509/X509CRLImpl.java	2018-05-20 04:52:08.215912430 +0100
@@ -103,8 +103,8 @@
     private X500Principal    issuerPrincipal = null;
     private Date             thisUpdate = null;
     private Date             nextUpdate = null;
-    private Map<X509IssuerSerial,X509CRLEntry> revokedMap = new TreeMap<>();
-    private List<X509CRLEntry> revokedList = new LinkedList<>();
+    private Map<X509IssuerSerial,X509CRLEntry> revokedMap = new TreeMap<X509IssuerSerial,X509CRLEntry>();
+    private List<X509CRLEntry> revokedList = new LinkedList<X509CRLEntry>();
     private CRLExtensions    extensions = null;
     private final static boolean isExplicit = true;
     private static final long YR_2050 = 2524636800000L;
@@ -908,7 +908,7 @@
         if (extensions == null) {
             return null;
         }
-        Set<String> extSet = new TreeSet<>();
+        Set<String> extSet = new TreeSet<String>();
         for (Extension ex : extensions.getAllExtensions()) {
             if (ex.isCritical()) {
                 extSet.add(ex.getExtensionId().toString());
@@ -929,7 +929,7 @@
         if (extensions == null) {
             return null;
         }
-        Set<String> extSet = new TreeSet<>();
+        Set<String> extSet = new TreeSet<String>();
         for (Extension ex : extensions.getAllExtensions()) {
             if (!ex.isCritical()) {
                 extSet.add(ex.getExtensionId().toString());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/tools/jar/CommandLine.java openjdk-boot/jdk/src/share/classes/sun/tools/jar/CommandLine.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/tools/jar/CommandLine.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/tools/jar/CommandLine.java	2018-05-20 04:52:08.215912430 +0100
@@ -55,7 +55,7 @@
     public static String[] parse(String[] args)
         throws IOException
     {
-        List<String> newArgs = new ArrayList<>(args.length);
+        List<String> newArgs = new ArrayList<String>(args.length);
         for (int i = 0; i < args.length; i++) {
             String arg = args[i];
             if (arg.length() > 1 && arg.charAt(0) == '@') {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/tools/jar/Manifest.java openjdk-boot/jdk/src/share/classes/sun/tools/jar/Manifest.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/tools/jar/Manifest.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/tools/jar/Manifest.java	2018-05-20 04:52:08.215912430 +0100
@@ -47,10 +47,10 @@
     /* list of headers that all pertain to a particular
      * file in the archive
      */
-    private Vector<MessageHeader> entries = new Vector<>();
+    private Vector<MessageHeader> entries = new Vector<MessageHeader>();
     private byte[] tmpbuf = new byte[512];
     /* a hashtable of entries, for fast lookup */
-    private Hashtable<String, MessageHeader> tableEntries = new Hashtable<>();
+    private Hashtable<String, MessageHeader> tableEntries = new Hashtable<String, MessageHeader>();
 
     static final String[] hashes = {"SHA"};
     static final byte[] EOL = {(byte)'\r', (byte)'\n'};
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/tools/jar/SignatureFile.java openjdk-boot/jdk/src/share/classes/sun/tools/jar/SignatureFile.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/tools/jar/SignatureFile.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/tools/jar/SignatureFile.java	2018-05-20 04:52:08.215912430 +0100
@@ -66,7 +66,7 @@
 
     /* list of headers that all pertain to a particular file in the
      * archive */
-    private Vector<MessageHeader> entries = new Vector<>();
+    private Vector<MessageHeader> entries = new Vector<MessageHeader>();
 
     /* Right now we only support SHA hashes */
     static final String[] hashes = {"SHA"};
@@ -98,7 +98,7 @@
      * character in length.  */
     private SignatureFile(String name) throws JarException {
 
-        entries = new Vector<>();
+        entries = new Vector<MessageHeader>();
 
         if (name != null) {
             if (name.length() > 8 || name.indexOf('.') != -1) {
@@ -322,7 +322,7 @@
         }
     }
 
-    private Hashtable<String, MessageDigest> digests = new Hashtable<>();
+    private Hashtable<String, MessageDigest> digests = new Hashtable<String, MessageDigest>();
 
     private MessageDigest getDigest(String algorithm)
     throws NoSuchAlgorithmException {
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/tools/native2ascii/Main.java openjdk-boot/jdk/src/share/classes/sun/tools/native2ascii/Main.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/tools/native2ascii/Main.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/tools/native2ascii/Main.java	2018-05-20 04:52:08.215912430 +0100
@@ -94,7 +94,7 @@
      * Run the converter
      */
     public synchronized boolean convert(String argv[]){
-        List<String> v = new ArrayList<>(2);
+        List<String> v = new ArrayList<String>(2);
         File outputFile = null;
         boolean createOutputFile = false;
 
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/InternalLocaleBuilder.java openjdk-boot/jdk/src/share/classes/sun/util/locale/InternalLocaleBuilder.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/InternalLocaleBuilder.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/locale/InternalLocaleBuilder.java	2018-05-20 04:52:08.215912430 +0100
@@ -113,7 +113,7 @@
         }
         // Use case insensitive string to prevent duplication
         if (uattributes == null) {
-            uattributes = new HashSet<>(4);
+            uattributes = new HashSet<CaseInsensitiveString>(4);
         }
         uattributes.add(new CaseInsensitiveString(attribute));
         return this;
@@ -157,7 +157,7 @@
                 }
             }
             if (ukeywords == null) {
-                ukeywords = new HashMap<>(4);
+                ukeywords = new HashMap<CaseInsensitiveString,String>(4);
             }
             ukeywords.put(cikey, type);
         }
@@ -211,7 +211,7 @@
                 setUnicodeLocaleExtension(val);
             } else {
                 if (extensions == null) {
-                    extensions = new HashMap<>(4);
+                    extensions = new HashMap<CaseInsensitiveChar,String>(4);
                 }
                 extensions.put(key, val);
             }
@@ -262,7 +262,7 @@
                 }
 
                 if (extensions == null) {
-                    extensions = new ArrayList<>(4);
+                    extensions = new ArrayList<String>(4);
                 }
                 extensions.add(sb.toString());
             } else {
@@ -313,7 +313,7 @@
         clearExtensions();
 
         if (!LocaleUtils.isEmpty(bcpExtensions)) {
-            Set<CaseInsensitiveChar> done = new HashSet<>(bcpExtensions.size());
+            Set<CaseInsensitiveChar> done = new HashSet<CaseInsensitiveChar>(bcpExtensions.size());
             for (String bcpExt : bcpExtensions) {
                 CaseInsensitiveChar key = new CaseInsensitiveChar(bcpExt);
                 // ignore duplicates
@@ -323,7 +323,7 @@
                         setUnicodeLocaleExtension(bcpExt.substring(2));
                     } else {
                         if (extensions == null) {
-                            extensions = new HashMap<>(4);
+                            extensions = new HashMap<CaseInsensitiveChar,String>(4);
                         }
                         extensions.put(key, bcpExt.substring(2));
                     }
@@ -334,7 +334,7 @@
         if (privateuse != null && privateuse.length() > 0) {
             // privateuse string contains prefix, e.g. "x-abc-def"
             if (extensions == null) {
-                extensions = new HashMap<>(1);
+                extensions = new HashMap<CaseInsensitiveChar,String>(1);
             }
             extensions.put(new CaseInsensitiveChar(privateuse), privateuse.substring(2));
         }
@@ -442,19 +442,19 @@
                     UnicodeLocaleExtension ue = (UnicodeLocaleExtension)e;
                     for (String uatr : ue.getUnicodeLocaleAttributes()) {
                         if (uattributes == null) {
-                            uattributes = new HashSet<>(4);
+                            uattributes = new HashSet<CaseInsensitiveString>(4);
                         }
                         uattributes.add(new CaseInsensitiveString(uatr));
                     }
                     for (String ukey : ue.getUnicodeLocaleKeys()) {
                         if (ukeywords == null) {
-                            ukeywords = new HashMap<>(4);
+                            ukeywords = new HashMap<CaseInsensitiveString,String>(4);
                         }
                         ukeywords.put(new CaseInsensitiveString(ukey), ue.getUnicodeLocaleType(ukey));
                     }
                 } else {
                     if (extensions == null) {
-                        extensions = new HashMap<>(4);
+                        extensions = new HashMap<CaseInsensitiveChar,String>(4);
                     }
                     extensions.put(new CaseInsensitiveChar(key), e.getValue());
                 }
@@ -604,7 +604,7 @@
                 break;
             }
             if (uattributes == null) {
-                uattributes = new HashSet<>(4);
+                uattributes = new HashSet<CaseInsensitiveString>(4);
             }
             uattributes.add(new CaseInsensitiveString(itr.current()));
             itr.next();
@@ -622,7 +622,7 @@
                     assert(typeStart == -1 || typeEnd != -1);
                     type = (typeStart == -1) ? "" : subtags.substring(typeStart, typeEnd);
                     if (ukeywords == null) {
-                        ukeywords = new HashMap<>(4);
+                        ukeywords = new HashMap<CaseInsensitiveString,String>(4);
                     }
                     ukeywords.put(key, type);
 
@@ -652,7 +652,7 @@
                     assert(typeStart == -1 || typeEnd != -1);
                     type = (typeStart == -1) ? "" : subtags.substring(typeStart, typeEnd);
                     if (ukeywords == null) {
-                        ukeywords = new HashMap<>(4);
+                        ukeywords = new HashMap<CaseInsensitiveString,String>(4);
                     }
                     ukeywords.put(key, type);
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LanguageTag.java openjdk-boot/jdk/src/share/classes/sun/util/locale/LanguageTag.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LanguageTag.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/locale/LanguageTag.java	2018-05-20 04:52:08.215912430 +0100
@@ -62,7 +62,7 @@
     // Map contains grandfathered tags and its preferred mappings from
     // http://www.ietf.org/rfc/rfc5646.txt
     // Keys are lower-case strings.
-    private static final Map<String, String[]> GRANDFATHERED = new HashMap<>();
+    private static final Map<String, String[]> GRANDFATHERED = new HashMap<String,String[]>();
 
     static {
         // grandfathered = irregular           ; non-redundant tags registered
@@ -257,7 +257,7 @@
             }
             found = true;
             if (extlangs.isEmpty()) {
-                extlangs = new ArrayList<>(3);
+                extlangs = new ArrayList<String>(3);
             }
             extlangs.add(s);
             sts.parseLength = itr.currentEnd();
@@ -322,7 +322,7 @@
             }
             found = true;
             if (variants.isEmpty()) {
-                variants = new ArrayList<>(3);
+                variants = new ArrayList<String>(3);
             }
             variants.add(s);
             sts.parseLength = itr.currentEnd();
@@ -365,7 +365,7 @@
                 }
 
                 if (extensions.isEmpty()) {
-                    extensions = new ArrayList<>(4);
+                    extensions = new ArrayList<String>(4);
                 }
                 extensions.add(sb.toString());
                 found = true;
@@ -462,7 +462,7 @@
                     break;
                 }
                 if (variants == null) {
-                    variants = new ArrayList<>();
+                    variants = new ArrayList<String>();
                 }
                 variants.add(var);  // Do not canonicalize!
                 varitr.next();
@@ -503,7 +503,7 @@
                     privateuse = ext.getValue();
                 } else {
                     if (extensions == null) {
-                        extensions = new ArrayList<>();
+                        extensions = new ArrayList<String>();
                     }
                     extensions.add(locextKey.toString() + SEP + ext.getValue());
                 }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LocaleExtensions.java openjdk-boot/jdk/src/share/classes/sun/util/locale/LocaleExtensions.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LocaleExtensions.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/locale/LocaleExtensions.java	2018-05-20 04:52:08.215912430 +0100
@@ -81,7 +81,7 @@
         }
 
         // Build extension map
-        SortedMap<Character, Extension> map = new TreeMap<>();
+        SortedMap<Character, Extension> map = new TreeMap<Character,Extension>();
         if (hasExtension) {
             for (Entry<CaseInsensitiveChar, String> ext : extensions.entrySet()) {
                 char key = LocaleUtils.toLower(ext.getKey().value());
@@ -104,14 +104,14 @@
             SortedMap<String, String> ukmap = null;
 
             if (hasUAttributes) {
-                uaset = new TreeSet<>();
+                uaset = new TreeSet<String>();
                 for (CaseInsensitiveString cis : uattributes) {
                     uaset.add(LocaleUtils.toLowerString(cis.value()));
                 }
             }
 
             if (hasUKeywords) {
-                ukmap = new TreeMap<>();
+                ukmap = new TreeMap<String,String>();
                 for (Entry<CaseInsensitiveString, String> kwd : ukeywords.entrySet()) {
                     String key = LocaleUtils.toLowerString(kwd.getKey().value());
                     String type = LocaleUtils.toLowerString(kwd.getValue());
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java openjdk-boot/jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java	2018-05-20 04:52:08.215912430 +0100
@@ -38,14 +38,14 @@
 
 public abstract class LocaleObjectCache<K, V> {
     private ConcurrentMap<K, CacheEntry<K, V>> map;
-    private ReferenceQueue<V> queue = new ReferenceQueue<>();
+    private ReferenceQueue<V> queue = new ReferenceQueue<V>();
 
     public LocaleObjectCache() {
         this(16, 0.75f, 16);
     }
 
     public LocaleObjectCache(int initialCapacity, float loadFactor, int concurrencyLevel) {
-        map = new ConcurrentHashMap<>(initialCapacity, loadFactor, concurrencyLevel);
+        map = new ConcurrentHashMap<K, CacheEntry<K,V>>(initialCapacity, loadFactor, concurrencyLevel);
     }
 
     public V get(K key) {
@@ -66,7 +66,7 @@
                 return null;
             }
 
-            CacheEntry<K, V> newEntry = new CacheEntry<>(key, newVal, queue);
+            CacheEntry<K, V> newEntry = new CacheEntry<K,V>(key, newVal, queue);
 
             entry = map.putIfAbsent(key, newEntry);
             if (entry == null) {
@@ -83,7 +83,7 @@
     }
 
     protected V put(K key, V value) {
-        CacheEntry<K, V> entry = new CacheEntry<>(key, value, queue);
+        CacheEntry<K, V> entry = new CacheEntry<K,V>(key, value, queue);
         CacheEntry<K, V> oldEntry = map.put(key, entry);
         return (oldEntry == null) ? null : oldEntry.get();
     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/LocaleServiceProviderPool.java openjdk-boot/jdk/src/share/classes/sun/util/LocaleServiceProviderPool.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/LocaleServiceProviderPool.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/LocaleServiceProviderPool.java	2018-05-20 04:52:08.215912430 +0100
@@ -59,7 +59,7 @@
      * set of provider implementations of a particular locale sensitive service.
      */
     private static ConcurrentMap<Class<? extends LocaleServiceProvider>, LocaleServiceProviderPool> poolOfPools =
-        new ConcurrentHashMap<>();
+        new ConcurrentHashMap<Class<? extends LocaleServiceProvider>, LocaleServiceProviderPool>();
 
     /**
      * A Set containing locale service providers that implement the
@@ -264,7 +264,7 @@
             synchronized (LocaleServiceProviderPool.class) {
                 if (availableJRELocales == null) {
                     Locale[] allLocales = LocaleData.getAvailableLocales();
-                    List<Locale> tmpList = new ArrayList<>(allLocales.length);
+                    List<Locale> tmpList = new ArrayList<Locale>(allLocales.length);
                     for (Locale locale : allLocales) {
                         tmpList.add(getLookupLocale(locale));
                     }
diff -Nru openjdk-boot.orig/jdk/src/share/classes/sun/util/logging/PlatformLogger.java openjdk-boot/jdk/src/share/classes/sun/util/logging/PlatformLogger.java
--- openjdk-boot.orig/jdk/src/share/classes/sun/util/logging/PlatformLogger.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/classes/sun/util/logging/PlatformLogger.java	2018-05-20 04:52:08.215912430 +0100
@@ -187,7 +187,7 @@
 
     // Table of known loggers.  Maps names to PlatformLoggers.
     private static Map<String,WeakReference<PlatformLogger>> loggers =
-        new HashMap<>();
+        new HashMap<String,WeakReference<PlatformLogger>>();
 
     /**
      * Returns a PlatformLogger of a given name.
@@ -200,7 +200,7 @@
         }
         if (log == null) {
             log = new PlatformLogger(name);
-            loggers.put(name, new WeakReference<>(log));
+            loggers.put(name, new WeakReference<PlatformLogger>(log));
         }
         return log;
     }
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/Demo.java openjdk-boot/jdk/src/share/demo/nio/zipfs/Demo.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/Demo.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/Demo.java	2018-05-20 04:52:08.215912430 +0100
@@ -160,7 +160,7 @@
         }
 
         Action action = Action.valueOf(args[0]);
-        Map<String, Object> env = env = new HashMap<>();
+        Map<String, Object> env = env = new HashMap<String,Object>();
         if (action == Action.create)
             env.put("create", "true");
         try (FileSystem fs = provider.newFileSystem(Paths.get(args[1]), env)) {
@@ -656,9 +656,9 @@
 
     private static void fchCopy(Path src, Path dst) throws IOException
     {
-        Set<OpenOption> read = new HashSet<>();
+        Set<OpenOption> read = new HashSet<OpenOption>();
         read.add(READ);
-        Set<OpenOption> openwrite = new HashSet<>();
+        Set<OpenOption> openwrite = new HashSet<OpenOption>();
         openwrite.add(CREATE_NEW);
         openwrite.add(WRITE);
 
@@ -676,9 +676,9 @@
 
     private static void chCopy(Path src, Path dst) throws IOException
     {
-        Set<OpenOption> read = new HashSet<>();
+        Set<OpenOption> read = new HashSet<OpenOption>();
         read.add(READ);
-        Set<OpenOption> openwrite = new HashSet<>();
+        Set<OpenOption> openwrite = new HashSet<OpenOption>();
         openwrite.add(CREATE_NEW);
         openwrite.add(WRITE);
 
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipCoder.java openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipCoder.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipCoder.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipCoder.java	2018-05-20 04:52:08.215912430 +0100
@@ -142,8 +142,8 @@
         return new ZipCoder(Charset.defaultCharset());
     }
 
-    private final ThreadLocal<CharsetDecoder> decTL = new ThreadLocal<>();
-    private final ThreadLocal<CharsetEncoder> encTL = new ThreadLocal<>();
+    private final ThreadLocal<CharsetDecoder> decTL = new ThreadLocal<CharsetDecoder>();
+    private final ThreadLocal<CharsetEncoder> encTL = new ThreadLocal<CharsetEncoder>();r
 
     private CharsetDecoder decoder() {
         CharsetDecoder dec = decTL.get();
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileAttributeView.java openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileAttributeView.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileAttributeView.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileAttributeView.java	2018-05-20 04:52:08.215912430 +0100
@@ -134,7 +134,7 @@
         throws IOException
     {
         ZipFileAttributes zfas = readAttributes();
-        LinkedHashMap<String, Object> map = new LinkedHashMap<>();
+        LinkedHashMap<String, Object> map = new LinkedHashMap<String,Object>();
         if ("*".equals(attributes)) {
             for (AttrID id : AttrID.values()) {
                 try {
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystem.java openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystem.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystem.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystem.java	2018-05-20 04:52:08.215912430 +0100
@@ -157,7 +157,7 @@
 
     @Override
     public Iterable<Path> getRootDirectories() {
-        ArrayList<Path> pathArr = new ArrayList<>();
+        ArrayList<Path> pathArr = new ArrayList<Path>();
         pathArr.add(new ZipPath(this, new byte[]{'/'}));
         return pathArr;
     }
@@ -202,7 +202,7 @@
 
     @Override
     public Iterable<FileStore> getFileStores() {
-        ArrayList<FileStore> list = new ArrayList<>(1);
+        ArrayList<FileStore> list = new ArrayList<FileStore>(1);
         list.add(new ZipFileStore(new ZipPath(this, new byte[]{'/'})));
         return list;
     }
@@ -268,7 +268,7 @@
             endWrite();
         }
         if (!streams.isEmpty()) {       // unlock and close all remaining streams
-            Set<InputStream> copy = new HashSet<>(streams);
+            Set<InputStream> copy = new HashSet<InputStream>(streams);
             for (InputStream is: copy)
                 is.close();
         }
@@ -396,7 +396,7 @@
             IndexNode inode = getInode(path);
             if (inode == null)
                 throw new NotDirectoryException(getString(path));
-            List<Path> list = new ArrayList<>();
+            List<Path> list = new ArrayList<Path>();
             IndexNode child = inode.child;
             while (child != null) {
                 ZipPath zp = toZipPath(child.name);
@@ -832,7 +832,7 @@
 
     // the ex-channel and ex-path that need to close when their outstanding
     // input streams are all closed by the obtainers.
-    private Set<ExChannelCloser> exChClosers = new HashSet<>();
+    private Set<ExChannelCloser> exChClosers = new HashSet<ExChannelCloser>();
 
     private Set<Path> tmppaths = Collections.synchronizedSet(new HashSet<Path>());
     private Path getTempPathForEntry(byte[] path) throws IOException {
@@ -1029,7 +1029,7 @@
     private byte[] initCEN() throws IOException {
         end = findEND();
         if (end.endpos == 0) {
-            inodes = new LinkedHashMap<>(10);
+            inodes = new LinkedHashMap<IndexNode,IndexNode>(10);
             locpos = 0;
             buildNodeTree();
             return null;         // only END header present
@@ -1050,7 +1050,7 @@
             zerror("read CEN tables failed");
         }
         // Iterate through the entries in the central directory
-        inodes = new LinkedHashMap<>(end.centot + 1);
+        inodes = new LinkedHashMap<IndexNode,IndexNode>(end.centot + 1);
         int pos = 0;
         int limit = cen.length - ENDHDR;
         while (pos < limit) {
@@ -1197,7 +1197,7 @@
         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE)))
         {
-            ArrayList<Entry> elist = new ArrayList<>(inodes.size());
+            ArrayList<Entry> elist = new ArrayList(inodes.size());
             long written = 0;
             byte[] buf = new byte[8192];
             Entry e = null;
@@ -1608,7 +1608,7 @@
     // Maxmum number of de/inflater we cache
     private final int MAX_FLATER = 20;
     // List of available Inflater objects for decompression
-    private final List<Inflater> inflaters = new ArrayList<>();
+    private final List<Inflater> inflaters = new ArrayList<Inflater>();
 
     // Gets an inflater from the list of available inflaters or allocates
     // a new one.
@@ -1637,7 +1637,7 @@
     }
 
     // List of available Deflater objects for compression
-    private final List<Deflater> deflaters = new ArrayList<>();
+    private final List<Deflater> deflaters = new ArrayList<Deflater>();
 
     // Gets an deflater from the list of available deflaters or allocates
     // a new one.
@@ -2347,7 +2347,7 @@
     private void buildNodeTree() throws IOException {
         beginWrite();
         try {
-            HashSet<IndexNode> dirs = new HashSet<>();
+            HashSet<IndexNode> dirs = new HashSet<IndexNode>();
             IndexNode root = new IndexNode(ROOTPATH, -1);
             inodes.put(root, root);
             dirs.add(root);
diff -Nru openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystemProvider.java openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystemProvider.java
--- openjdk-boot.orig/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystemProvider.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/share/demo/nio/zipfs/src/com/sun/nio/zipfs/ZipFileSystemProvider.java	2018-05-20 04:52:08.215912430 +0100
@@ -62,7 +62,7 @@
 public class ZipFileSystemProvider extends FileSystemProvider {
 
 
-    private final Map<Path, ZipFileSystem> filesystems = new HashMap<>();
+    private final Map<Path, ZipFileSystem> filesystems = new HashMap<Path,ZipFileSystem>();
 
     public ZipFileSystemProvider() {}
 
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/java/lang/ProcessEnvironment.java openjdk-boot/jdk/src/solaris/classes/java/lang/ProcessEnvironment.java
--- openjdk-boot.orig/jdk/src/solaris/classes/java/lang/ProcessEnvironment.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/java/lang/ProcessEnvironment.java	2018-05-20 04:52:08.215912430 +0100
@@ -68,7 +68,7 @@
         // We cache the C environment.  This means that subsequent calls
         // to putenv/setenv from C will not be visible from Java code.
         byte[][] environ = environ();
-        theEnvironment = new HashMap<>(environ.length/2 + 3);
+        theEnvironment = new HashMap<Variable,Value>(environ.length/2 + 3);
         // Read environment variables back to front,
         // so that earlier variables override later ones.
         for (int i = environ.length-1; i > 0; i-=2)
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java openjdk-boot/jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java
--- openjdk-boot.orig/jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java	2018-05-20 04:38:34.968799304 +0100
+++ openjdk-boot/jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java	2018-05-20 04:52:08.215912430 +0100
@@ -354,7 +354,7 @@
      * log against that map.  The resulting map is then written back
      * to the disk.
      */
-    final List<Change> changeLog = new ArrayList<>();
+    final List<Change> changeLog = new ArrayList<Change>();
 
     /**
      * Represents a change to a preference.
@@ -507,7 +507,7 @@
         });
         if (newNode) {
             // These 2 things guarantee node will get wrtten at next flush/sync
-            prefsCache = new TreeMap<>();
+            prefsCache = new TreeMap<String, String>();
             nodeCreate = new NodeCreate();
             changeLog.add(nodeCreate);
         }
@@ -550,7 +550,7 @@
             loadCache();
         } catch(Exception e) {
             // assert lastSyncTime == 0;
-            prefsCache = new TreeMap<>();
+            prefsCache = new TreeMap<String, String>();
         }
     }
 
@@ -567,7 +567,7 @@
             AccessController.doPrivileged(
                 new PrivilegedExceptionAction<Void>() {
                 public Void run() throws BackingStoreException {
-                    Map<String, String> m = new TreeMap<>();
+                    Map<String, String> m = new TreeMap<String, String>();
                     long newLastSyncTime = 0;
                     FileInputStream fis = null;
                     try {
@@ -581,7 +581,7 @@
                             prefsFile.renameTo( new File(
                                                     prefsFile.getParentFile(),
                                                   "IncorrectFormatPrefs.xml"));
-                            m = new TreeMap<>();
+                            m = new TreeMap<String, String>();
                         } else if (e instanceof FileNotFoundException) {
                         getLogger().warning("Prefs file removed in background "
                                            + prefsFile.getPath());
@@ -662,7 +662,7 @@
         return AccessController.doPrivileged(
             new PrivilegedAction<String[]>() {
                 public String[] run() {
-                    List<String> result = new ArrayList<>();
+                    List<String> result = new ArrayList<String>();
                     File[] dirContents = dir.listFiles();
                     if (dirContents != null) {
                         for (int i = 0; i < dirContents.length; i++)
@@ -810,7 +810,7 @@
         } else if (lastSyncTime != 0 && !dir.exists()) {
             // This node was removed in the background.  Playback any changes
             // against a virgin (empty) Map.
-            prefsCache = new TreeMap<>();
+            prefsCache = new TreeMap<String, String>();
             replayChanges();
         }
         if (!changeLog.isEmpty()) {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/net/dns/ResolverConfigurationImpl.java openjdk-boot/jdk/src/solaris/classes/sun/net/dns/ResolverConfigurationImpl.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/net/dns/ResolverConfigurationImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/net/dns/ResolverConfigurationImpl.java	2018-05-20 04:52:08.215912430 +0100
@@ -60,7 +60,7 @@
                                           int maxperkeyword,
                                           int maxkeywords)
     {
-        LinkedList<String> ll = new LinkedList<>();
+        LinkedList<String> ll = new LinkedList<String>();
 
         try {
             BufferedReader in =
@@ -209,7 +209,7 @@
         // no local domain so try fallback (RPC) domain or
         // hostName
 
-        sl = new LinkedList<>();
+        sl = new LinkedList<String>();
         String domain = fallbackDomain0();
         if (domain != null && domain.length() > 0) {
             sl.add(domain);
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/net/www/protocol/jar/JarFileFactory.java openjdk-boot/jdk/src/solaris/classes/sun/net/www/protocol/jar/JarFileFactory.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/net/www/protocol/jar/JarFileFactory.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/net/www/protocol/jar/JarFileFactory.java	2018-05-20 04:52:08.215912430 +0100
@@ -43,10 +43,10 @@
 class JarFileFactory implements URLJarFile.URLJarFileCloseController {
 
     /* the url to file cache */
-    private static final HashMap<String, JarFile> fileCache = new HashMap<>();
+    private static final HashMap<String, JarFile> fileCache = new HashMap<String, JarFile>();
 
     /* the file to url cache */
-    private static final HashMap<JarFile, URL> urlCache = new HashMap<>();
+    private static final HashMap<JarFile, URL> urlCache = new HashMap<JarFile, URL>();
 
     private static final JarFileFactory instance = new JarFileFactory();
 
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/ch/DevPollArrayWrapper.java openjdk-boot/jdk/src/solaris/classes/sun/nio/ch/DevPollArrayWrapper.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/ch/DevPollArrayWrapper.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/ch/DevPollArrayWrapper.java	2018-05-20 04:52:08.215912430 +0100
@@ -133,7 +133,7 @@
         pollArrayAddress = pollArray.address();
         wfd = init();
         if (OPEN_MAX > MAX_UPDATE_ARRAY_SIZE)
-            eventsHigh = new HashMap<>();
+            eventsHigh = new HashMap<Integer,Byte>();
     }
 
     void initInterrupt(int fd0, int fd1) {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/ch/EPollArrayWrapper.java openjdk-boot/jdk/src/solaris/classes/sun/nio/ch/EPollArrayWrapper.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/ch/EPollArrayWrapper.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/ch/EPollArrayWrapper.java	2018-05-20 04:52:08.215912430 +0100
@@ -136,7 +136,7 @@
 
         // eventHigh needed when using file descriptors > 64k
         if (OPEN_MAX > MAX_UPDATE_ARRAY_SIZE)
-            eventsHigh = new HashMap<>();
+            eventsHigh = new HashMap<Integer, Byte>();
     }
 
     void initInterrupt(int fd0, int fd1) {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/ch/EPollSelectorImpl.java openjdk-boot/jdk/src/solaris/classes/sun/nio/ch/EPollSelectorImpl.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/ch/EPollSelectorImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/ch/EPollSelectorImpl.java	2018-05-20 04:52:08.215912430 +0100
@@ -67,7 +67,7 @@
         fd1 = (int) pipeFds;
         pollWrapper = new EPollArrayWrapper();
         pollWrapper.initInterrupt(fd0, fd1);
-        fdToKey = new HashMap<>();
+        fdToKey = new HashMap<Integer, SelectionKeyImpl>();
     }
 
     protected int doSelect(long timeout) throws IOException {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/ch/SctpNet.java openjdk-boot/jdk/src/solaris/classes/sun/nio/ch/SctpNet.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/ch/SctpNet.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/ch/SctpNet.java	2018-05-20 04:52:08.215912430 +0100
@@ -113,7 +113,7 @@
             SocketAddress[] saa)
     {
          SecurityManager sm = System.getSecurityManager();
-         Set<SocketAddress> set = new HashSet<>(saa.length);
+         Set<SocketAddress> set = new HashSet<SocketAddress>(saa.length);
          for (SocketAddress sa : saa) {
              set.add(getRevealedLocalAddress(sa, sm));
          }
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/cs/ext/CompoundTextSupport.java openjdk-boot/jdk/src/solaris/classes/sun/nio/cs/ext/CompoundTextSupport.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/cs/ext/CompoundTextSupport.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/cs/ext/CompoundTextSupport.java	2018-05-20 04:52:08.215912430 +0100
@@ -153,12 +153,12 @@
 
     static {
         HashMap<ControlSequence, String> tSequenceToEncodingMap =
-            new HashMap<>(33, 1.0f);
+            new HashMap<ControlSequence, String>(33, 1.0f);
         HashMap<ControlSequence, Boolean> tHighBitsMap =
-            new HashMap<>(31, 1.0f);
+            new HashMap<ControlSequence, Boolean>(31, 1.0f);
         HashMap<String, ControlSequence> tEncodingToSequenceMap =
-            new HashMap<>(21, 1.0f);
-        ArrayList<String> tEncodings = new ArrayList<>(21);
+            new HashMap<String, ControlSequence>(21, 1.0f);
+        ArrayList<String> tEncodings = new ArrayList<String>(21);
 
         if (!(isEncodingSupported("US-ASCII") &&
               isEncodingSupported("ISO-8859-1")))
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java	2018-05-20 04:52:08.219912367 +0100
@@ -53,7 +53,7 @@
         static final Set<String> supportedFileAttributeViews =
             supportedFileAttributeViews();
         private static Set<String> supportedFileAttributeViews() {
-            Set<String> result = new HashSet<>();
+            Set<String> result = new HashSet<String>();
             result.addAll(standardFileAttributeViews());
             // additional Linux-specific views
             result.add("dos");
@@ -76,7 +76,7 @@
      * Returns object to iterate over the mount entries in the given fstab file.
      */
     Iterable<UnixMountEntry> getMountEntries(String fstab) {
-        ArrayList<UnixMountEntry> entries = new ArrayList<>();
+        ArrayList<UnixMountEntry> entries = new ArrayList<UnixMountEntry>();
         try {
             long fp = setmntent(fstab.getBytes(), "r".getBytes());
             try {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java	2018-05-20 04:52:08.219912367 +0100
@@ -63,7 +63,7 @@
 
     // Parses buffer as array of NULL-terminated C strings.
     private List<String> asList(long address, int size) {
-        List<String> list = new ArrayList<>();
+        List<String> list = new ArrayList<String>();
         int start = 0;
         int pos = 0;
         while (pos < size) {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisAclFileAttributeView.java	2018-05-20 04:52:08.219912367 +0100
@@ -198,7 +198,7 @@
      * Decode the buffer, returning an ACL
      */
     private static List<AclEntry> decode(long address, int n) {
-        ArrayList<AclEntry> acl = new ArrayList<>(n);
+        ArrayList<AclEntry> acl = new ArrayList<AclEntry>(n);
         for (int i=0; i<n; i++) {
             long offset = address + i*SIZEOF_ACE_T;
 
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisFileSystem.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisFileSystem.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisFileSystem.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisFileSystem.java	2018-05-20 04:52:08.219912367 +0100
@@ -76,7 +76,7 @@
         static final Set<String> supportedFileAttributeViews =
             supportedFileAttributeViews();
         private static Set<String> supportedFileAttributeViews() {
-            Set<String> result = new HashSet<>();
+            Set<String> result = new HashSet<String>();
             result.addAll(standardFileAttributeViews());
             // additional Solaris-specific views
             result.add("acl");
@@ -101,7 +101,7 @@
      */
     @Override
     Iterable<UnixMountEntry> getMountEntries() {
-        ArrayList<UnixMountEntry> entries = new ArrayList<>();
+        ArrayList<UnixMountEntry> entries = new ArrayList<UnixMountEntry>();
         try {
             UnixPath mnttab = new UnixPath(this, "/etc/mnttab");
             long fp = fopen(mnttab, "r");
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/SolarisUserDefinedFileAttributeView.java	2018-05-20 04:52:08.219912367 +0100
@@ -83,7 +83,7 @@
                 }
 
                 // read list of extended attributes
-                List<String> list = new ArrayList<>();
+                List<String> list = new ArrayList<String>();
                 try {
                     byte[] name;
                     while ((name = readdir(dp)) != null) {
diff -Nru openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributes.java openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributes.java
--- openjdk-boot.orig/jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributes.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributes.java	2018-05-20 04:52:08.219912367 +0100
@@ -194,7 +194,7 @@
     @Override
     public Set<PosixFilePermission> permissions() {
         int bits = (st_mode & UnixConstants.S_IAMB);
-        HashSet<PosixFilePermission> perms = new HashSet<>();
+        HashSet<PosixFilePermission> perms = new HashSet<PosixFilePermission>();
 
         if ((bits & UnixConstants.S_IRUSR) > 0)
             perms.add(PosixFilePermission.OWNER_READ);
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/java/lang/ProcessEnvironment.java openjdk-boot/jdk/src/windows/classes/java/lang/ProcessEnvironment.java
--- openjdk-boot.orig/jdk/src/windows/classes/java/lang/ProcessEnvironment.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/java/lang/ProcessEnvironment.java	2018-05-20 04:52:08.219912367 +0100
@@ -250,7 +250,8 @@
                                    envblock.substring(eql+1,end));
         }
 
-        theCaseInsensitiveEnvironment = new TreeMap<>(nameComparator);
+        theCaseInsensitiveEnvironment
+            = new TreeMap<String,String>(nameComparator);
         theCaseInsensitiveEnvironment.putAll(theEnvironment);
     }
 
@@ -295,7 +296,8 @@
     // Only for use by ProcessImpl.start()
     String toEnvironmentBlock() {
         // Sort Unicode-case-insensitively by name
-        List<Map.Entry<String,String>> list = new ArrayList<>(entrySet());
+        List<Map.Entry<String,String>> list
+            = new ArrayList<Map.Entry<String,String>>(entrySet());
         Collections.sort(list, entryComparator);
 
         StringBuilder sb = new StringBuilder(size()*30);
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/net/dns/ResolverConfigurationImpl.java openjdk-boot/jdk/src/windows/classes/sun/net/dns/ResolverConfigurationImpl.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/net/dns/ResolverConfigurationImpl.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/net/dns/ResolverConfigurationImpl.java	2018-05-20 04:52:08.219912367 +0100
@@ -63,7 +63,7 @@
     // Parse string that consists of token delimited by space or commas
     // and return LinkedHashMap
     private LinkedList<String> stringToList(String str) {
-        LinkedList<String> ll = new LinkedList<>();
+        LinkedList<String> ll = new LinkedList<String>();
 
         // comma and space are valid delimites
         StringTokenizer st = new StringTokenizer(str, ", ");
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsFileSystem.java openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsFileSystem.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsFileSystem.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsFileSystem.java	2018-05-20 04:52:08.219912367 +0100
@@ -128,7 +128,7 @@
         }
 
         // iterate over roots, ignoring those that the security manager denies
-        ArrayList<Path> result = new ArrayList<>();
+        ArrayList<Path> result = new ArrayList<Path>();
         SecurityManager sm = System.getSecurityManager();
         for (int i = 0; i <= 25; i++) {  // 0->A, 1->B, 2->C...
             if ((drives & (1 << i)) != 0) {
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsPath.java openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsPath.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsPath.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsPath.java	2018-05-20 04:52:08.219912367 +0100
@@ -575,7 +575,7 @@
     // generate offset array
     private void initOffsets() {
         if (offsets == null) {
-            ArrayList<Integer> list = new ArrayList<>();
+            ArrayList<Integer> list = new ArrayList<Integer>();
             if (isEmpty()) {
                 // empty path considered to have one name element
                 list.add(0);
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsSecurityDescriptor.java openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsSecurityDescriptor.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsSecurityDescriptor.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsSecurityDescriptor.java	2018-05-20 04:52:08.219912367 +0100
@@ -378,7 +378,7 @@
             AclInformation aclInfo = GetAclInformation(aclAddress);
             aceCount = aclInfo.aceCount();
         }
-        ArrayList<AclEntry> result = new ArrayList<>(aceCount);
+        ArrayList<AclEntry> result = new ArrayList<AclEntry>(aceCount);
 
         // decode each of the ACEs to AclEntry objects
         for (int i=0; i<aceCount; i++) {
diff -Nru openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsUserDefinedFileAttributeView.java openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsUserDefinedFileAttributeView.java
--- openjdk-boot.orig/jdk/src/windows/classes/sun/nio/fs/WindowsUserDefinedFileAttributeView.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/src/windows/classes/sun/nio/fs/WindowsUserDefinedFileAttributeView.java	2018-05-20 04:52:08.219912367 +0100
@@ -65,7 +65,7 @@
 
     // enumerates the file streams using FindFirstStream/FindNextStream APIs.
     private List<String> listUsingStreamEnumeration() throws IOException {
-        List<String> list = new ArrayList<>();
+        List<String> list = new ArrayList<String>();
         try {
             FirstStream first = FindFirstStream(file.getPathForWin32Calls());
             if (first != null) {
@@ -114,7 +114,7 @@
         NativeBuffer buffer = null;
 
         // result with names of alternative data streams
-        final List<String> list = new ArrayList<>();
+        final List<String> list = new ArrayList<String>();
 
         try {
             buffer = NativeBuffers.getNativeBuffer(BUFFER_SIZE);
@@ -216,7 +216,7 @@
         // wrap with channel
         FileChannel fc = null;
         try {
-            Set<OpenOption> opts = new HashSet<>();
+            Set<OpenOption> opts = new HashSet<OpenOption>();
             opts.add(READ);
             if (!followLinks)
                 opts.add(WindowsChannelFactory.OPEN_REPARSE_POINT);
@@ -243,7 +243,7 @@
         // wrap with channel
         FileChannel fc = null;
         try {
-            Set<OpenOption> opts = new HashSet<>();
+            Set<OpenOption> opts = new HashSet<OpenOption>();
             opts.add(READ);
             if (!followLinks)
                 opts.add(WindowsChannelFactory.OPEN_REPARSE_POINT);
@@ -298,7 +298,7 @@
             x.rethrowAsIOException(file);
         }
         try {
-            Set<OpenOption> opts = new HashSet<>();
+            Set<OpenOption> opts = new HashSet<OpenOption>();
             if (!followLinks)
                 opts.add(WindowsChannelFactory.OPEN_REPARSE_POINT);
             opts.add(CREATE);
diff -Nru openjdk-boot.orig/jdk/test/java/io/Serializable/NPEProvoker/NPEProvoker.java openjdk-boot/jdk/test/java/io/Serializable/NPEProvoker/NPEProvoker.java
--- openjdk-boot.orig/jdk/test/java/io/Serializable/NPEProvoker/NPEProvoker.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/test/java/io/Serializable/NPEProvoker/NPEProvoker.java	2018-05-20 04:52:08.219912367 +0100
@@ -56,7 +56,7 @@
     public static void main(String[] args) {
         System.err.println("\n Regression test for bug 6541870\n");
         try {
-            ArrayList<NPEProvoker> list = new ArrayList<>();
+            ArrayList<NPEProvoker> list = new ArrayList<NPEProvoker>();
             list.add(new NPEProvoker());
             ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ObjectOutputStream oos = new ObjectOutputStream(baos);
diff -Nru openjdk-boot.orig/jdk/test/java/lang/instrument/ilib/InjectBytecodes.java openjdk-boot/jdk/test/java/lang/instrument/ilib/InjectBytecodes.java
--- openjdk-boot.orig/jdk/test/java/lang/instrument/ilib/InjectBytecodes.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/test/java/lang/instrument/ilib/InjectBytecodes.java	2018-05-20 04:52:08.219912367 +0100
@@ -50,7 +50,7 @@
     private final Injector[] after  = new Injector[256];
     private final String className;
     private final String methodName;
-    private final Map<Integer,byte[]> snippets = new HashMap<>();
+    private final Map<Integer,byte[]> snippets = new HashMap<Integer,byte[]>();
 
     private int pos;
     private int newPos;
diff -Nru openjdk-boot.orig/jdk/test/java/lang/instrument/ilib/Inject.java openjdk-boot/jdk/test/java/lang/instrument/ilib/Inject.java
--- openjdk-boot.orig/jdk/test/java/lang/instrument/ilib/Inject.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/test/java/lang/instrument/ilib/Inject.java	2018-05-20 04:52:08.219912367 +0100
@@ -107,7 +107,7 @@
     class IndexedInjector implements TrackerInjector {
         int counter = 0;
         int tracker;
-        List<Info> infoList = new ArrayList<>();
+        List<Info> infoList = new ArrayList<Info>();
 
         public int stackSize(int currentSize) {
             return currentSize + 1;
diff -Nru openjdk-boot.orig/jdk/test/java/lang/reflect/Generics/TestPlainArrayNotGeneric.java openjdk-boot/jdk/test/java/lang/reflect/Generics/TestPlainArrayNotGeneric.java
--- openjdk-boot.orig/jdk/test/java/lang/reflect/Generics/TestPlainArrayNotGeneric.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/test/java/lang/reflect/Generics/TestPlainArrayNotGeneric.java	2018-05-20 04:52:08.219912367 +0100
@@ -103,7 +103,7 @@
         }
     }
 
-    private static final Set<Type> checking = new HashSet<>();
+    private static final Set<Type> checking = new HashSet<Type>();
 
     private static void check(Type t, String what) {
         if (t == null || !checking.add(t))
diff -Nru openjdk-boot.orig/jdk/test/java/util/logging/ClassLoaderLeakTest.java openjdk-boot/jdk/test/java/util/logging/ClassLoaderLeakTest.java
--- openjdk-boot.orig/jdk/test/java/util/logging/ClassLoaderLeakTest.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/test/java/util/logging/ClassLoaderLeakTest.java	2018-05-20 04:52:08.219912367 +0100
@@ -89,7 +89,7 @@
 
          MyClassLoader appClassLoader = new MyClassLoader(urls, "test0");
          WeakReference<MyClassLoader> ref =
-                 new WeakReference<>(appClassLoader);
+                 new WeakReference<MyClassLoader>(appClassLoader);
 
 
          Thread appThread = new Thread(appsThreadGroup, launcher, "AppThread-0");
diff -Nru openjdk-boot.orig/jdk/test/java/util/Random/DistinctSeeds.java openjdk-boot/jdk/test/java/util/Random/DistinctSeeds.java
--- openjdk-boot.orig/jdk/test/java/util/Random/DistinctSeeds.java	2018-05-17 02:55:38.000000000 +0100
+++ openjdk-boot/jdk/test/java/util/Random/DistinctSeeds.java	2018-05-20 04:52:08.219912367 +0100
@@ -60,7 +60,7 @@
             }
         }
         final int threadCount = 2;
-        List<RandomCollector> collectors = new ArrayList<>();
+        List<RandomCollector> collectors = new ArrayList<RandomCollector>();
         List<Thread> threads = new ArrayList<Thread>();
         for (int i = 0; i < threadCount; i++) {
             RandomCollector r = new RandomCollector();
