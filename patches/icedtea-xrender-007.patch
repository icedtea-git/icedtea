# HG changeset patch
# User ceisserer
# Date 1224775518 -7200
# Node ID d6ab5f9f96efa37a823e071a27e3555557930203
# Parent  2e58d73ce3ffd0301067d097ba443910c387c8d5
TransformedBlit rewrite

diff -r 2e58d73ce3ff -r d6ab5f9f96ef src/solaris/classes/sun/java2d/xr/XRDrawImage.java
--- openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRDrawImage.java	Tue Aug 05 04:05:41 2008 +0200
+++ openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRDrawImage.java	Thu Oct 23 17:25:18 2008 +0200
@@ -42,13 +42,10 @@
 	SurfaceData srcData = dstData.getSourceSurfaceData(img,
 		SunGraphics2D.TRANSFORM_GENERIC, sg.imageComp, bgColor);
 
-	if (srcData != null && !isBgOperation(srcData, bgColor)
+	if (srcData != null && !isBgOperation(srcData, bgColor) // TODO: Don't bail out on bg-blits
 		&& srcData instanceof XRSurfaceData) {
 	    SurfaceType srcType = srcData.getSurfaceType();
 	    SurfaceType dstType = dstData.getSurfaceType();
-
-	    ((XRSurfaceData) srcData).setPreferredInterpolation(XRUtils
-		    .ATransOpToXRQuality(interpType));
 
 	    TransformBlit blit = TransformBlit.getFromCache(srcType,
 		    sg.imageComp, dstType);
diff -r 2e58d73ce3ff -r d6ab5f9f96ef src/solaris/classes/sun/java2d/xr/XRPMBlitLoops.java
--- openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRPMBlitLoops.java	Tue Aug 05 04:05:41 2008 +0200
+++ openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRPMBlitLoops.java	Thu Oct 23 17:25:18 2008 +0200
@@ -42,35 +42,25 @@
     public static void register() {
 	GraphicsPrimitive[] primitives = {
 
-		new X11PMBlit(XRSurfaceData.IntRgbX11, XRSurfaceData.IntRgbX11),
-		new X11PMBlit(XRSurfaceData.IntRgbX11, XRSurfaceData.IntArgbX11),
-		new X11PMBlit(XRSurfaceData.IntArgbX11, XRSurfaceData.IntRgbX11),
-		new X11PMBlit(XRSurfaceData.IntArgbX11,
-			XRSurfaceData.IntArgbX11),
+	new X11PMBlit(XRSurfaceData.IntRgbX11, XRSurfaceData.IntRgbX11), new X11PMBlit(XRSurfaceData.IntRgbX11, XRSurfaceData.IntArgbX11),
+		new X11PMBlit(XRSurfaceData.IntArgbX11, XRSurfaceData.IntRgbX11), new X11PMBlit(XRSurfaceData.IntArgbX11, XRSurfaceData.IntArgbX11),
 
-		new X11PMScaledBlit(XRSurfaceData.IntRgbX11,
-			XRSurfaceData.IntRgbX11),
-		new X11PMScaledBlit(XRSurfaceData.IntRgbX11,
-			XRSurfaceData.IntArgbX11),
-		new X11PMScaledBlit(XRSurfaceData.IntArgbX11,
-			XRSurfaceData.IntRgbX11),
-		new X11PMScaledBlit(XRSurfaceData.IntArgbX11,
-			XRSurfaceData.IntArgbX11),
+		new X11PMScaledBlit(XRSurfaceData.IntRgbX11, XRSurfaceData.IntRgbX11),
+		new X11PMScaledBlit(XRSurfaceData.IntRgbX11, XRSurfaceData.IntArgbX11),
+		new X11PMScaledBlit(XRSurfaceData.IntArgbX11, XRSurfaceData.IntRgbX11),
+		new X11PMScaledBlit(XRSurfaceData.IntArgbX11, XRSurfaceData.IntArgbX11),
 
-		new X11PMTransformedBlit(XRSurfaceData.IntRgbX11,
-			XRSurfaceData.IntRgbX11),
-		new X11PMTransformedBlit(XRSurfaceData.IntRgbX11,
-			XRSurfaceData.IntArgbX11),
-		new X11PMTransformedBlit(XRSurfaceData.IntArgbX11,
-			XRSurfaceData.IntRgbX11),
-		new X11PMTransformedBlit(XRSurfaceData.IntArgbX11,
-			XRSurfaceData.IntArgbX11),
-	};
+		new X11PMTransformedBlit(XRSurfaceData.IntRgbX11, XRSurfaceData.IntRgbX11),
+		new X11PMTransformedBlit(XRSurfaceData.IntRgbX11, XRSurfaceData.IntArgbX11),
+		new X11PMTransformedBlit(XRSurfaceData.IntArgbX11, XRSurfaceData.IntRgbX11),
+		new X11PMTransformedBlit(XRSurfaceData.IntArgbX11, XRSurfaceData.IntArgbX11), };
 	GraphicsPrimitiveMgr.register(primitives);
     }
 
-    public static native void nativeRenderBlit(long srcData, long dstData,
-	    int sx, int sy, int dx, int dy, int w, int h);
+    public static native void nativeRenderBlit(long srcData, long dstData, int sx, int sy, int dx, int dy, int w, int h);
+
+    public static native void nativeTransformedRenderBlit(long srcData, long dstData, int sx, int sy, int dx, int dy, int w, int h, int m00, int m01,
+	    int m02, int m10, int m11, int m12, int maskWidth, int maskHeight, int lastMaskWidth, int lastMaskHeight);
 }
 
 class X11PMBlit extends Blit {
@@ -78,8 +68,7 @@
 	super(srcType, CompositeType.AnyAlpha, dstType);
     }
 
-    public void Blit(SurfaceData src, SurfaceData dst, Composite comp,
-	    Region clip, int sx, int sy, int dx, int dy, int w, int h) {
+    public void Blit(SurfaceData src, SurfaceData dst, Composite comp, Region clip, int sx, int sy, int dx, int dy, int w, int h) {
 	try {
 	    SunToolkit.awtLock();
 
@@ -89,8 +78,7 @@
 
 	    x11sdSrc.validateAsSource(null, XRUtils.RepeatNone, XRUtils.FAST);
 
-	    XRPMBlitLoops.nativeRenderBlit(src.getNativeOps(), dst
-		    .getNativeOps(), sx, sy, dx, dy, w, h);
+	    XRPMBlitLoops.nativeRenderBlit(src.getNativeOps(), dst.getNativeOps(), sx, sy, dx, dy, w, h);
 	} finally {
 	    SunToolkit.awtUnlock();
 	}
@@ -101,10 +89,9 @@
     public X11PMScaledBlit(SurfaceType srcType, SurfaceType dstType) {
 	super(srcType, CompositeType.AnyAlpha, dstType);
     }
-
-    public void Scale(SurfaceData src, SurfaceData dst, Composite comp,
-	    Region clip, int sx1, int sy1, int sx2, int sy2, double dx1,
-	    double dy1, double dx2, double dy2) {
+    
+    public void Scale(SurfaceData src, SurfaceData dst, Composite comp, Region clip, int sx1, int sy1, int sx2, int sy2, double dx1, double dy1,
+	    double dx2, double dy2) {
 	try {
 	    SunToolkit.awtLock();
 
@@ -120,14 +107,13 @@
 	    sy1 *= yScale;
 	    sy2 *= yScale;
 
-	    AffineTransform xForm = AffineTransform.getScaleInstance(
-		    1 / xScale, 1 / yScale);
+	    AffineTransform xForm = AffineTransform.getScaleInstance(1 / xScale, 1 / yScale);
 
 	    x11sdSrc.validateAsSource(xForm, XRUtils.RepeatNone, XRUtils.FAST);
 
-	    XRPMBlitLoops.nativeRenderBlit(src.getNativeOps(), dst
-		    .getNativeOps(), (int) sx1, (int) sy1, (int) dx1,
-		    (int) dy1, (int) (dx2 - dx1), (int) (dy2 - dy1));
+	    /*TODO: This breaks non-integer scaled images*/
+	    XRPMBlitLoops.nativeRenderBlit(src.getNativeOps(), dst.getNativeOps(), (int) sx1, (int) sy1, (int) dx1, (int) dy1, (int) (dx2 - dx1),
+		    (int) (dy2 - dy1));
 
 	} finally {
 	    SunToolkit.awtUnlock();
@@ -145,59 +131,90 @@
 	super(srcType, CompositeType.AnyAlpha, dstType);
     }
 
-    public void Transform(SurfaceData src, SurfaceData dst, Composite comp,
-	    Region clip, AffineTransform xform, int hint, int srcx, int srcy,
+    static int lastMaskWidth = 0, lastMaskHeight = 0;
+
+    /**
+     * Possible optimizations: 
+     * - Nearest interpolation -> ExtraAlpha mit 1x1 maske durchführen
+     * - Mehere Maskengroessen anlegen, und skalieren
+     * - Ueberpruefen ob aktueller Maskeninhalt mit skalierung passen wuerde, bzw. nur so viel aendern bis passt (wenn bereich < maske)
+     * - Aendering entweder mit 2 filLRects, oder nur 1 fillrect je nach groesse
+     */
+    
+    public void Transform(SurfaceData src, SurfaceData dst, Composite comp, Region clip, AffineTransform xform, int hint, int srcx, int srcy,
 	    int dstx, int dsty, int width, int height) {
 	try {
 	    SunToolkit.awtLock();
+
+	    int xrInterpolationType = XRUtils.ATransOpToXRQuality(hint);
 
 	    XRSurfaceData x11sdDst = (XRSurfaceData) dst;
 	    x11sdDst.validate(clip, comp, null, null, null, 0);
 	    XRSurfaceData x11sdSrc = (XRSurfaceData) src;
 
-	    boolean needClip = (xform.getScaleX() != 0.0f)
-		    || (xform.getShearY() != 0.0f);
+	    Rectangle2D.Float rect = new Rectangle2D.Float(dstx, dsty, width, height);
+	    Shape shp = xform.createTransformedShape(rect);
+	    Rectangle bounds = shp.getBounds();
+
+	    AffineTransform trx = AffineTransform.getTranslateInstance((-bounds.x), (-bounds.y));
+	    trx.concatenate(xform);
+	    AffineTransform maskTX = (AffineTransform) trx.clone();
+
+	    trx.translate(-srcx, -srcy);
+
 	    try {
-		/* Calculate area which will be covered by the transform-blit */
-		Rectangle2D.Float rect = new Rectangle2D.Float(dstx, dsty,
-			width, height);
-		Shape shp = xform.createTransformedShape(rect);
-		Rectangle bounds = shp.getBounds();
+		trx.invert();
+	    } catch (NoninvertibleTransformException ex) {
+		trx.setToIdentity();
+		System.err.println("Reseted to identity!");
+	    }
 
-		AffineTransform sourceTrans = (AffineTransform) xform.clone();
-		sourceTrans.translate(-srcx, -srcy);
+	    boolean omitMask = isMaskOmittable(trx, comp, xrInterpolationType);
 
-		try
-		{
-		     sourceTrans.invert();
-		}catch(NoninvertibleTransformException ex)
-		{
-		    sourceTrans.setToIdentity();
+	    if (!omitMask) {
+		int maskWidth = Math.max(width / 8, 1);
+		int maskHeight = Math.max(height / 8, 1);
+		maskTX.scale(((double) width) / maskWidth, ((double) height) / maskHeight);
+
+		try {
+		    maskTX.invert();
+		} catch (NoninvertibleTransformException ex) {
+		    maskTX.setToIdentity();
+		    System.err.println("Reseted to identity!");
 		}
 
-		x11sdSrc.validateAsSource(sourceTrans, XRUtils.RepeatNone);
+		x11sdSrc.validateAsSource(trx, XRUtils.RepeatPad, xrInterpolationType);
 
-		if (needClip) {
-		    x11sdDst.setShapeClip(shp);
-		}
+		XRPMBlitLoops.nativeTransformedRenderBlit(src.getNativeOps(), dst.getNativeOps(), 0, 0, bounds.x, bounds.y, bounds.width,
+			bounds.height, XRUtils.XDoubleToFixed(maskTX.getScaleX()), XRUtils.XDoubleToFixed(maskTX.getShearX()), XRUtils
+				.XDoubleToFixed(maskTX.getTranslateX()), XRUtils.XDoubleToFixed(maskTX.getShearY()), XRUtils.XDoubleToFixed(maskTX
+				.getScaleY()), XRUtils.XDoubleToFixed(maskTX.getTranslateY()), maskWidth, maskHeight, lastMaskWidth, lastMaskHeight);
 
-		XRPMBlitLoops.nativeRenderBlit(src.getNativeOps(), dst
-			.getNativeOps(), 0, 0, 0, 0, bounds.x + bounds.width,
-			bounds.y + bounds.height);// bounds.x, bounds.y,
-						    // bounds.width,
-						    // bounds.height);//(int)
-						    // (maxX - minX), (int)
-						    // (maxY - minY));
+		lastMaskWidth = maskWidth;
+		lastMaskHeight = maskHeight;
+	    } else {
+		int repeat = xrInterpolationType <= XRUtils.FAST ? XRUtils.RepeatNone : XRUtils.RepeatPad;
+		x11sdSrc.validateAsSource(trx, repeat, xrInterpolationType);
+		XRPMBlitLoops.nativeTransformedRenderBlit(src.getNativeOps(), dst.getNativeOps(), 0, 0, bounds.x, bounds.y, bounds.width,
+			bounds.height, 0, 0, 0, 0, 0, 0, -1, -1, 0, 0);
+	    }
 
-		if (needClip) {
-		    x11sdDst.resetShapeClip();
-		}
-
-	    } catch (Exception ex) {
-		ex.printStackTrace();
-	    }
 	} finally {
 	    SunToolkit.awtUnlock();
 	}
     }
+
+    protected static boolean isMaskOmittable(AffineTransform trx, Composite comp, int interpolation) {
+	return (interpolation <= XRUtils.FAST || trx.getTranslateX() == (int) trx.getTranslateX() /*
+												     * If
+												     * translate
+												     * is
+												     * integer only
+												     */
+		&& trx.getTranslateY() == (int) trx.getTranslateY() && (trx.getShearX() == 0 && trx.getShearY() == 0 // Only
+															// "90°"
+															// rotation
+		|| trx.getShearX() == -trx.getShearY())) && ((AlphaComposite) comp).getAlpha() == 1.0f; // No
+													// ExtraAlpha!=1
+    }
 }
\ No newline at end of file
diff -r 2e58d73ce3ff -r d6ab5f9f96ef src/solaris/classes/sun/java2d/xr/XRSurfaceData.java
--- openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRSurfaceData.java	Tue Aug 05 04:05:41 2008 +0200
+++ openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRSurfaceData.java	Thu Oct 23 17:25:18 2008 +0200
@@ -50,8 +50,7 @@
 
     private static native void initIDs(boolean gradCache);
 
-    protected native void XRInitSurface(int depth, int width, int height,
-	    long drawable, int pictFormat);
+    protected native void XRInitSurface(int depth, int width, int height, long drawable, int pictFormat);
 
     native void XRInitXRender(long xsdo, int pictForm);
 
@@ -110,12 +109,13 @@
 	TextPipe textpipe;
 	boolean validated = false;
 
-	/* The textpipe for now can't handle TexturePaint when extra-alpha is specified nore XOR mode*/
+	/*
+	 * The textpipe for now can't handle TexturePaint when extra-alpha is
+	 * specified nore XOR mode
+	 */
 	if (sg2d.compositeState < SunGraphics2D.COMP_XOR
-		&& (sg2d.paintState < SunGraphics2D.PAINT_TEXTURE
-		|| sg2d.composite == null
-		|| !(sg2d.composite instanceof AlphaComposite)
-		|| ((AlphaComposite) sg2d.composite).getAlpha() == 1.0f)) {
+		&& (sg2d.paintState < SunGraphics2D.PAINT_TEXTURE || sg2d.composite == null || !(sg2d.composite instanceof AlphaComposite) || ((AlphaComposite) sg2d.composite)
+			.getAlpha() == 1.0f)) {
 	    textpipe = xrtextpipe;
 	} else {
 	    super.validatePipe(sg2d);
@@ -167,8 +167,8 @@
     }
 
     /**
-     * Returns an accalerated MaskFill object if the current paint
-     *  is supported by the pipeline.
+     * Returns an accalerated MaskFill object if the current paint is supported
+     * by the pipeline.
      */
     protected MaskFill getMaskFill(SunGraphics2D sg2d) {
 	if (sg2d.paintState > SunGraphics2D.PAINT_ALPHACOLOR && !isPaintValid(sg2d)) {
@@ -178,8 +178,7 @@
     }
 
     public RenderLoops getRenderLoops(SunGraphics2D sg2d) {
-	if (sg2d.paintState <= SunGraphics2D.PAINT_ALPHACOLOR
-		&& sg2d.compositeState <= SunGraphics2D.COMP_ALPHA) {
+	if (sg2d.paintState <= SunGraphics2D.PAINT_ALPHACOLOR && sg2d.compositeState <= SunGraphics2D.COMP_ALPHA) {
 	    return solidloops;
 	}
 
@@ -199,28 +198,24 @@
     }
 
     /**
-     * Method for instantiating a Pixmap SurfaceData (offscreen).
-     * If the surface is opaque a 24-bit/RGB surface is chosen, 
-     * otherwise a 32-bit ARGB surface.
+     * Method for instantiating a Pixmap SurfaceData (offscreen). If the surface
+     * is opaque a 24-bit/RGB surface is chosen, otherwise a 32-bit ARGB
+     * surface.
      */
-    public static XRPixmapSurfaceData createData(XRGraphicsConfig gc,
-	    int width, int height, ColorModel cm, Image image, long drawable,
+    public static XRPixmapSurfaceData createData(XRGraphicsConfig gc, int width, int height, ColorModel cm, Image image, long drawable,
 	    int transparency) {
 	int depth = transparency > Transparency.OPAQUE ? 32 : 24;
 	if (depth == 24) {
 	    cm = new DirectColorModel(depth, 0x00FF0000, 0x0000FF00, 0x000000FF);
 	} else {
-	    cm = new DirectColorModel(depth, 0x00FF0000, 0x0000FF00,
-		    0x000000FF, 0xFF000000);
+	    cm = new DirectColorModel(depth, 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
 	}
 
-	return new XRPixmapSurfaceData(gc, width, height, image,
-		getSurfaceType(gc, transparency), cm, drawable, transparency,
-		XRUtils.getPictureFormatForTransparency(transparency), depth);
+	return new XRPixmapSurfaceData(gc, width, height, image, getSurfaceType(gc, transparency), cm, drawable, transparency, XRUtils
+		.getPictureFormatForTransparency(transparency), depth);
     }
 
-    protected XRSurfaceData(X11ComponentPeer peer, XRGraphicsConfig gc,
-	    SurfaceType sType, ColorModel cm, int depth, int transparency) {
+    protected XRSurfaceData(X11ComponentPeer peer, XRGraphicsConfig gc, SurfaceType sType, ColorModel cm, int depth, int transparency) {
 	super(sType, cm);
 	this.peer = peer;
 	this.graphicsConfig = gc;
@@ -233,6 +228,7 @@
 
     /**
      * Inits the XRender-data-structures which belong to the XRSurfaceData.
+     * 
      * @param pictureFormat
      */
     public void initXRender(int pictureFormat) {
@@ -248,8 +244,7 @@
 	if (peer != null) {
 	    return (XRGraphicsConfig) peer.getGraphicsConfiguration();
 	} else {
-	    GraphicsEnvironment env = GraphicsEnvironment
-		    .getLocalGraphicsEnvironment();
+	    GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
 	    GraphicsDevice gd = env.getDefaultScreenDevice();
 	    return (XRGraphicsConfig) gd.getDefaultConfiguration();
 	}
@@ -269,16 +264,14 @@
     public abstract boolean canSourceSendExposures(int x, int y, int w, int h);
 
     /**
-     * CopyArea is implemented using the "old" X11 GC, 
-     * therefor clip and needExposures have to be validated against that GC.
-     * Pictures and GCs don't share state.
+     * CopyArea is implemented using the "old" X11 GC, therefor clip and
+     * needExposures have to be validated against that GC. Pictures and GCs
+     * don't share state.
      */
     public void validateCopyAreaGC(Region gcClip, boolean needExposures) {
 	if (validatedGCClip != gcClip) {
 	    if (gcClip != null) {
-		XSetClip(xgc, gcClip.getLoX(), gcClip.getLoY(),
-			gcClip.getHiX(), gcClip.getHiY(), 
-			gcClip.isRectangular() ? null : gcClip);
+		XSetClip(xgc, gcClip.getLoX(), gcClip.getLoY(), gcClip.getHiX(), gcClip.getHiY(), gcClip.isRectangular() ? null : gcClip);
 	    } else {
 		XResetClip(xgc);
 	    }
@@ -291,8 +284,7 @@
 	}
     }
 
-    public boolean copyArea(SunGraphics2D sg2d, int x, int y, int w, int h,
-	    int dx, int dy) {
+    public boolean copyArea(SunGraphics2D sg2d, int x, int y, int w, int h, int dx, int dy) {
 	if (xrpipe == null) {
 	    if (!isXRDrawableValid()) {
 		return true;
@@ -301,16 +293,14 @@
 	}
 	CompositeType comptype = sg2d.imageComp;
 	if (sg2d.transformState < SunGraphics2D.TRANSFORM_TRANSLATESCALE
-		&& (CompositeType.SrcOverNoEa.equals(comptype) || CompositeType.SrcNoEa
-			.equals(comptype))) {
+		&& (CompositeType.SrcOverNoEa.equals(comptype) || CompositeType.SrcNoEa.equals(comptype))) {
 	    x += sg2d.transX;
 	    y += sg2d.transY;
 	    try {
 		SunToolkit.awtLock();
 		boolean needExposures = canSourceSendExposures(x, y, w, h);
 		validateCopyAreaGC(sg2d.getCompClip(), needExposures);
-		xrpipe.devCopyArea(getNativeOps(), xgc, x, y, x + dx, y + dy,
-			w, h);
+		xrpipe.devCopyArea(getNativeOps(), xgc, x, y, x + dx, y + dy, w, h);
 	    } finally {
 		SunToolkit.awtUnlock();
 	    }
@@ -320,11 +310,10 @@
     }
 
     /**
-     * Returns the XRender SurfaceType which is able to fullfill the
-     * specified transparency requirement.
+     * Returns the XRender SurfaceType which is able to fullfill the specified
+     * transparency requirement.
      */
-    public static SurfaceType getSurfaceType(XRGraphicsConfig gc,
-	    int transparency) {
+    public static SurfaceType getSurfaceType(XRGraphicsConfig gc, int transparency) {
 	SurfaceType sType = null;
 
 	switch (transparency) {
@@ -355,45 +344,35 @@
 
     private static native void XRSetComposite(int compRule, float eAlpha);
 
-    private static native void XRSetClip(long xsdo, int lox, int loy, int hix,
-	    int hiy, Region complexclip);
+    private static native void XRSetClip(long xsdo, int lox, int loy, int hix, int hiy, Region complexclip);
 
     private static native void XRResetClip(long xsdo);
 
-    private static native void XRSetTransformNative(long xsdo, int m00,
-	    int m01, int m02, int m10, int m11, int m12);
+    private static native void XRSetTransformNative(long xsdo, int m00, int m01, int m02, int m10, int m11, int m12);
 
     private static native void XRSetTexturePaint(long xsdo);
 
     private static native void XRResetPaint();
 
     private static native void XRSetRepeat(long xsdo, int repeat);
-    
+
     private static native void XRSetFilter(long xsdo, int value);
-    
-    private static native void XRSetLinearGradientPaint(float[] fractions,
-	    int[] pixels, int x1, int y1, int x2, int y2, int numStops,
-	    int cycleMethod, boolean useMask, boolean linear, int m00, int m01,
-	    int m02, int m10, int m11, int m12);
-    
-    private native static void XRSetRadialGradientPaint(float[] fractions,
-	    int[] pixels, int fx, int numStops, int cycleMethod,
-	    boolean useMask, boolean linear, int innerRadius, int outerRadius,
-	    int m00, int m01, int m02, int m10, int m11, int m12);
+
+    private static native void XRSetLinearGradientPaint(float[] fractions, int[] pixels, int x1, int y1, int x2, int y2, int numStops,
+	    int cycleMethod, boolean useMask, boolean linear, int m00, int m01, int m02, int m10, int m11, int m12);
+
+    private native static void XRSetRadialGradientPaint(float[] fractions, int[] pixels, int fx, int numStops, int cycleMethod, boolean useMask,
+	    boolean linear, int innerRadius, int outerRadius, int m00, int m01, int m02, int m10, int m11, int m12);
 
     private void XRSetTransform(AffineTransform transform) {
 	double[] transformData = new double[6];
 	transform.getMatrix(transformData);
 
-	XRSetTransformNative(getNativeOps(), XDoubleToFixed(transformData[0]),
-		XDoubleToFixed(transformData[2]),
-		XDoubleToFixed(transformData[4]),
-		XDoubleToFixed(transformData[1]),
-		XDoubleToFixed(transformData[3]),
-		XDoubleToFixed(transformData[5]));
+	XRSetTransformNative(getNativeOps(), XDoubleToFixed(transformData[0]), XDoubleToFixed(transformData[2]), XDoubleToFixed(transformData[4]),
+		XDoubleToFixed(transformData[1]), XDoubleToFixed(transformData[3]), XDoubleToFixed(transformData[5]));
     }
 
-    private long xgc; //GC is still used for copyArea
+    private long xgc; // GC is still used for copyArea
 
     public static int validatedPixel = -1;
     public static int validatedPaintState = -1;
@@ -410,35 +389,37 @@
     private AffineTransform validatedSourceTransform = new AffineTransform();
     private int validatedRepeat = XRUtils.RepeatNone;
     private int validatedInterpolation = -1;
-    /*Used if API does not allow to pass interpolation value at the level needed*/
+    /*
+     * Used if API does not allow to pass interpolation value at the level
+     * needed
+     */
     private int preferredInterpolation = -1;
 
     public void setPreferredInterpolation(int interpolation) {
 	this.preferredInterpolation = interpolation;
     }
-    
-    
+
     /*
-     * For now those shape-clips are used for transformed images,
-     * because transformed image for now would invalidate a much larger area that they are intended to do.
-     * However as soon as the transformed-mask approach I am working on turns out
-     * to work well, those will be dropped.
+     * For now those shape-clips are used for transformed images, because
+     * transformed image for now would invalidate a much larger area that they
+     * are intended to do. However as soon as the transformed-mask approach I am
+     * working on turns out to work well, those will be dropped.
      */
     public void setShapeClip(Shape shape) {
 	Region shapeClip = Region.getInstance(validatedClip, shape, null);
-	XRSetClip(getNativeOps(), shapeClip.getLoX(), shapeClip.getLoY(),
-		shapeClip.getHiX(), shapeClip.getHiY(), shapeClip
-			.isRectangular() ? null : shapeClip);
+	XRSetClip(getNativeOps(), shapeClip.getLoX(), shapeClip.getLoY(), shapeClip.getHiX(), shapeClip.getHiY(), shapeClip.isRectangular() ? null
+		: shapeClip);
     }
 
     public void resetShapeClip() {
-	XRSetClip(getNativeOps(), validatedClip.getLoX(), validatedClip
-		.getLoY(), validatedClip.getHiX(), validatedClip.getHiY(),
-		validatedClip.isRectangular() ? null : validatedClip);
+	XRSetClip(getNativeOps(), validatedClip.getLoX(), validatedClip.getLoY(), validatedClip.getHiX(), validatedClip.getHiY(), validatedClip
+		.isRectangular() ? null : validatedClip);
     }
 
     /**
-     * Validate the source with the preferred interpolation set sometimes earlier.
+     * Validate the source with the preferred interpolation set sometimes
+     * earlier.
+     * 
      * @param sxForm
      * @param repeat
      */
@@ -447,35 +428,40 @@
     }
 
     /**
-     * Validates an XRSurfaceData when used as source.
-     * Note that the clip is applied when used as source as well as destination.
+     * Validates an XRSurfaceData when used as source. Note that the clip is
+     * applied when used as source as well as destination.
      */
     void validateAsSource(AffineTransform sxForm, int repeat, int interpolation) {
+	// System.out.println("Source:
+	// "+getBounds().width+"/"+getBounds().height);
+
 	if (validatedClip != null) {
 	    validatedClip = null;
 	    XRResetClip(getNativeOps());
+	    // System.out.println("Clip ge-reseted");
 	}
 
 	if (validatedRepeat != repeat) {
 	    validatedRepeat = repeat;
 	    XRSetRepeat(getNativeOps(), repeat);
+	    // System.out.println("Repeat ge-reseted");
 	}
 
 	if (sxForm == null) {
 	    if (transformInUse) {
 		validatedSourceTransform.setToIdentity();
+		// System.out.println("Transform ge-reseted");
 		XRSetTransform(validatedSourceTransform);
 		transformInUse = false;
 	    }
 	} else {
-	    if (!transformInUse
-		 || (transformInUse && !sxForm.equals(validatedSourceTransform))) {
-		
-		validatedSourceTransform.setTransform(sxForm.getScaleX(),
-			sxForm.getShearY(), sxForm.getShearX(), sxForm
-				.getScaleY(), sxForm.getTranslateX(), sxForm
-				.getTranslateY());
-		
+	    if (!transformInUse || (transformInUse && !sxForm.equals(validatedSourceTransform))) {
+
+		// System.out.println("Setze transform: "+sxForm);
+
+		validatedSourceTransform.setTransform(sxForm.getScaleX(), sxForm.getShearY(), sxForm.getShearX(), sxForm.getScaleY(), sxForm
+			.getTranslateX(), sxForm.getTranslateY());
+
 		XRSetTransform(validatedSourceTransform);
 		transformInUse = true;
 	    }
@@ -488,8 +474,9 @@
     }
 
     /**
-     * Utility method for setting the Composite,
-     * passing down the arguments to the native method.
+     * Utility method for setting the Composite, passing down the arguments to
+     * the native method.
+     * 
      * @param comp
      */
     private void setComposite(Composite comp) {
@@ -497,12 +484,9 @@
 	    AlphaComposite aComp = (AlphaComposite) comp;
 	    validatedExtraAlpha = aComp.getAlpha();
 
-	    XRSetComposite(XRUtils.j2dAlphaCompToXR(aComp.getRule()),
-		    validatedExtraAlpha);
+	    XRSetComposite(XRUtils.j2dAlphaCompToXR(aComp.getRule()), validatedExtraAlpha);
 	} else {
-	    throw new InternalError(
-		    "Composite accaleration not implemented for: "
-			    + comp.getClass().getName());
+	    throw new InternalError("Composite accaleration not implemented for: " + comp.getClass().getName());
 	}
     }
 
@@ -537,10 +521,10 @@
 
 	return ((a << 24) | (r << 16) | (g << 8) | (b));
     }
-    
+
     /**
-     * The currently only known paint XRender can't support are
-     * radial gradients where focus and center paint differ.
+     * The currently only known paint XRender can't support are radial gradients
+     * where focus and center paint differ.
      */
     public static boolean isPaintValid(SunGraphics2D sg2d) {
 	if (sg2d.paintState == SunGraphics2D.PAINT_RAD_GRADIENT) {
@@ -551,14 +535,11 @@
     }
 
     /**
-     * Sets a 2-stop gradient.
-     * Utility method generating the by the native method expected
-     * parameters and calling it.
+     * Sets a 2-stop gradient. Utility method generating the by the native
+     * method expected parameters and calling it.
      */
-    private void setGradientPaint(SunGraphics2D sg2d, GradientPaint paint,
-	    boolean useMask) {
-	int[] pixels = convertToIntArgbPixels(new Color[] { paint.getColor1(),
-		paint.getColor2() }, false);
+    private void setGradientPaint(SunGraphics2D sg2d, GradientPaint paint, boolean useMask) {
+	int[] pixels = convertToIntArgbPixels(new Color[] { paint.getColor1(), paint.getColor2() }, false);
 
 	float fractions[] = new float[2];
 	fractions[0] = 0;
@@ -577,27 +558,19 @@
 	double[] transformData = new double[6];
 	at.getMatrix(transformData);
 
-	int repeat = paint.isCyclic() ? XRUtils.RepeatReflect
-		: XRUtils.RepeatPad;
+	int repeat = paint.isCyclic() ? XRUtils.RepeatReflect : XRUtils.RepeatPad;
 
-	XRSetLinearGradientPaint(fractions, pixels, XDoubleToFixed(pt1.getX()),
-		XDoubleToFixed(pt1.getY()), XDoubleToFixed(pt2.getX()),
-		XDoubleToFixed(pt2.getY()), 2, repeat, useMask, false,
-		XDoubleToFixed(transformData[0]),
-		XDoubleToFixed(transformData[2]),
-		XDoubleToFixed(transformData[4]),
-		XDoubleToFixed(transformData[1]),
-		XDoubleToFixed(transformData[3]),
+	XRSetLinearGradientPaint(fractions, pixels, XDoubleToFixed(pt1.getX()), XDoubleToFixed(pt1.getY()), XDoubleToFixed(pt2.getX()),
+		XDoubleToFixed(pt2.getY()), 2, repeat, useMask, false, XDoubleToFixed(transformData[0]), XDoubleToFixed(transformData[2]),
+		XDoubleToFixed(transformData[4]), XDoubleToFixed(transformData[1]), XDoubleToFixed(transformData[3]),
 		XDoubleToFixed(transformData[5]));
     }
-    
+
     /**
-     * Sets a n-stop linear gradient.
-     * Utility method generating the by the native method expected
-     * parameters and calling it.
+     * Sets a n-stop linear gradient. Utility method generating the by the
+     * native method expected parameters and calling it.
      */
-    public void setLinearGradientPaint(SunGraphics2D sg2d,
-	    LinearGradientPaint paint, boolean useMask) {
+    public void setLinearGradientPaint(SunGraphics2D sg2d, LinearGradientPaint paint, boolean useMask) {
 	boolean linear = (paint.getColorSpace() == ColorSpaceType.LINEAR_RGB);
 	Color[] colors = paint.getColors();
 	int numStops = colors.length;
@@ -607,8 +580,7 @@
 	AffineTransform at = paint.getTransform();
 	at.preConcatenate(sg2d.transform);
 
-	int cycleMethod = XRUtils.getRepeatForCycleMethod(paint
-		.getCycleMethod());
+	int cycleMethod = XRUtils.getRepeatForCycleMethod(paint.getCycleMethod());
 	float[] fractions = paint.getFractions();
 	int[] pixels = convertToIntArgbPixels(colors, linear);
 
@@ -621,32 +593,24 @@
 	double[] transformData = new double[6];
 	at.getMatrix(transformData);
 
-	XRSetLinearGradientPaint(fractions, pixels, XDoubleToFixed(pt1.getX()),
-		XDoubleToFixed(pt1.getY()), XDoubleToFixed(pt2.getX()),
-		XDoubleToFixed(pt2.getY()), numStops, cycleMethod, useMask,
-		linear, XDoubleToFixed(transformData[0]),
-		XDoubleToFixed(transformData[2]),
-		XDoubleToFixed(transformData[4]),
-		XDoubleToFixed(transformData[1]),
-		XDoubleToFixed(transformData[3]),
-		XDoubleToFixed(transformData[5]));
+	XRSetLinearGradientPaint(fractions, pixels, XDoubleToFixed(pt1.getX()), XDoubleToFixed(pt1.getY()), XDoubleToFixed(pt2.getX()),
+		XDoubleToFixed(pt2.getY()), numStops, cycleMethod, useMask, linear, XDoubleToFixed(transformData[0]),
+		XDoubleToFixed(transformData[2]), XDoubleToFixed(transformData[4]), XDoubleToFixed(transformData[1]),
+		XDoubleToFixed(transformData[3]), XDoubleToFixed(transformData[5]));
     }
 
     /**
-     * Sets a Radial Gradient where focus and center point match.
-     * Utility method generating the by the native method expected
-     * parameters and calling it.
+     * Sets a Radial Gradient where focus and center point match. Utility method
+     * generating the by the native method expected parameters and calling it.
      */
-    public void setRadialGradientPaint(SunGraphics2D sg2d,
-	    RadialGradientPaint paint) {
+    public void setRadialGradientPaint(SunGraphics2D sg2d, RadialGradientPaint paint) {
 	boolean linear = (paint.getColorSpace() == ColorSpaceType.LINEAR_RGB);
 	Color[] colors = paint.getColors();
 	int numStops = colors.length;
 	Point2D center = paint.getCenterPoint();
 	Point2D focus = paint.getFocusPoint();
 
-	int cycleMethod = XRUtils.getRepeatForCycleMethod(paint
-		.getCycleMethod());
+	int cycleMethod = XRUtils.getRepeatForCycleMethod(paint.getCycleMethod());
 	float[] fractions = paint.getFractions();
 	int[] pixels = convertToIntArgbPixels(colors, linear);
 	float radius = paint.getRadius();
@@ -683,28 +647,19 @@
 	double[] transformData = new double[6];
 	at.getMatrix(transformData);
 
-	XRSetRadialGradientPaint(fractions, pixels, XDoubleToFixed(fx),
-		numStops, cycleMethod, false, linear, XDoubleToFixed(0),
-		XDoubleToFixed(radius), XDoubleToFixed(transformData[0]),
-		XDoubleToFixed(transformData[2]),
-		XDoubleToFixed(transformData[4]),
-		XDoubleToFixed(transformData[1]),
-		XDoubleToFixed(transformData[3]),
-		XDoubleToFixed(transformData[5]));
+	XRSetRadialGradientPaint(fractions, pixels, XDoubleToFixed(fx), numStops, cycleMethod, false, linear, XDoubleToFixed(0),
+		XDoubleToFixed(radius), XDoubleToFixed(transformData[0]), XDoubleToFixed(transformData[2]), XDoubleToFixed(transformData[4]),
+		XDoubleToFixed(transformData[1]), XDoubleToFixed(transformData[3]), XDoubleToFixed(transformData[5]));
     }
 
-    private TexturePaint setTexturePaint(SunGraphics2D sg2d,
-	    TexturePaint paint, boolean useMask) {
+    private TexturePaint setTexturePaint(SunGraphics2D sg2d, TexturePaint paint, boolean useMask) {
 	BufferedImage bi = paint.getImage();
 	SurfaceData dstData = sg2d.surfaceData;
-	SurfaceData srcData = dstData.getSourceSurfaceData(bi,
-		SunGraphics2D.TRANSFORM_ISIDENT, CompositeType.SrcOver, null);
+	SurfaceData srcData = dstData.getSourceSurfaceData(bi, SunGraphics2D.TRANSFORM_ISIDENT, CompositeType.SrcOver, null);
 
 	// REMIND: this hack tries to ensure that we have a cached texture
 	if (!(srcData instanceof XRSurfaceData)) {
-	    srcData = dstData.getSourceSurfaceData(paint.getImage(),
-		    SunGraphics2D.TRANSFORM_ISIDENT, CompositeType.SrcOver,
-		    null);
+	    srcData = dstData.getSourceSurfaceData(paint.getImage(), SunGraphics2D.TRANSFORM_ISIDENT, CompositeType.SrcOver, null);
 	    if (!(srcData instanceof XRSurfaceData)) {
 		return null;
 	    }
@@ -715,17 +670,15 @@
 	AffineTransform at = (AffineTransform) sg2d.transform.clone();
 	Rectangle2D anchor = paint.getAnchorRect();
 	at.translate(anchor.getX(), anchor.getY());
-	at.scale(anchor.getWidth() / ((double) bi.getWidth()), 
-		anchor.getHeight() / ((double) bi.getHeight()));
-	
+	at.scale(anchor.getWidth() / ((double) bi.getWidth()), anchor.getHeight() / ((double) bi.getHeight()));
+
 	try {
 	    at.invert();
 	} catch (NoninvertibleTransformException ex) {
 	    at.setToIdentity(); /* TODO: Right thing to do in this case? */
 	}
 
-	x11SrcData.validateAsSource(at, XRUtils.RepeatNormal, 
-		XRUtils.ATransOpToXRQuality(sg2d.interpolationType));
+	x11SrcData.validateAsSource(at, XRUtils.RepeatNormal, XRUtils.ATransOpToXRQuality(sg2d.interpolationType));
 
 	XRSetTexturePaint(srcData.getNativeOps());
 
@@ -733,8 +686,9 @@
     }
 
     /**
-     * Sets the paint as source.
-     * Checks the type of paint and calls the appropriate set*Paint method.
+     * Sets the paint as source. Checks the type of paint and calls the
+     * appropriate set*Paint method.
+     * 
      * @param sg2d
      * @param paint
      */
@@ -750,8 +704,7 @@
 		    break;
 
 		case SunGraphics2D.PAINT_LIN_GRADIENT:
-		    setLinearGradientPaint(sg2d, (LinearGradientPaint) paint,
-			    false);
+		    setLinearGradientPaint(sg2d, (LinearGradientPaint) paint, false);
 		    validatedPaint = paint;
 		    break;
 
@@ -761,8 +714,7 @@
 		    break;
 
 		case SunGraphics2D.PAINT_TEXTURE:
-		    validatedPaint = setTexturePaint(sg2d,
-			    (TexturePaint) paint, false);
+		    validatedPaint = setTexturePaint(sg2d, (TexturePaint) paint, false);
 		    break;
 
 		default:
@@ -773,12 +725,10 @@
     }
 
     /**
-     * Validates the Surface when used as destination, 
-     * takes care that the native surface has the same state as expected, 
-     * changing it it not.
+     * Validates the Surface when used as destination, takes care that the
+     * native surface has the same state as expected, changing it it not.
      */
-    public void validate(Region clip, Composite comp, AffineTransform xform,
-	    Paint paint, SunGraphics2D sg2d, int flags) {
+    public void validate(Region clip, Composite comp, AffineTransform xform, Paint paint, SunGraphics2D sg2d, int flags) {
 	boolean updateClip = (clip != validatedClip);
 	boolean updatePaint = (paint != validatedPaint) || paint == null;
 
@@ -789,8 +739,7 @@
 	// validate clip
 	if (updateClip) {
 	    if (clip != null) {
-		XRSetClip(getNativeOps(), clip.getLoX(), clip.getLoY(), clip
-			.getHiX(), clip.getHiY(), clip.isRectangular() ? null : clip);
+		XRSetClip(getNativeOps(), clip.getLoX(), clip.getLoY(), clip.getHiX(), clip.getHiY(), clip.isRectangular() ? null : clip);
 	    } else {
 		XRResetClip(getNativeOps());
 	    }
@@ -830,7 +779,10 @@
 	}
     }
 
-    public void makePipes() { /*TODO: Why was this synchronized, but access not?*/
+    public void makePipes() { /*
+				 * TODO: Why was this synchronized, but access
+				 * not?
+				 */
 	if (xrpipe == null) {
 	    try {
 		SunToolkit.awtLock();
@@ -847,14 +799,11 @@
     }
 
     public static class XRWindowSurfaceData extends XRSurfaceData {
-	public XRWindowSurfaceData(X11ComponentPeer peer, XRGraphicsConfig gc,
-		SurfaceType sType) {
-	    super(peer, gc, sType, peer.getColorModel(), peer.getColorModel()
-		    .getPixelSize(), Transparency.OPAQUE);
+	public XRWindowSurfaceData(X11ComponentPeer peer, XRGraphicsConfig gc, SurfaceType sType) {
+	    super(peer, gc, sType, peer.getColorModel(), peer.getColorModel().getPixelSize(), Transparency.OPAQUE);
 
 	    if (isXRDrawableValid()) {
-		initXRender(XRUtils
-			.getPictureFormatForTransparency(Transparency.OPAQUE));
+		initXRender(XRUtils.getPictureFormatForTransparency(Transparency.OPAQUE));
 		makePipes();
 	    }
 	}
@@ -888,8 +837,7 @@
 	int height;
 	int transparency;
 
-	public XRPixmapSurfaceData(XRGraphicsConfig gc, int width, int height,
-		Image image, SurfaceType sType, ColorModel cm, long drawable,
+	public XRPixmapSurfaceData(XRGraphicsConfig gc, int width, int height, Image image, SurfaceType sType, ColorModel cm, long drawable,
 		int transparency, int pictFormat, int depth) {
 	    super(null, gc, sType, cm, depth, transparency);
 	    this.width = width;
@@ -900,8 +848,7 @@
 	    makePipes();
 	}
 
-	public void initSurface(int depth, int width, int height,
-		long drawable, int pictFormat) {
+	public void initSurface(int depth, int width, int height, long drawable, int pictFormat) {
 	    try {
 		SunToolkit.awtLock();
 		XRInitSurface(depth, width, height, drawable, pictFormat);
@@ -936,10 +883,11 @@
 	public void flush() {
 	    /*
 	     * We need to invalidate the surface before disposing the native
-	     * Drawable and Picture. This way if an application tries to render to an
-	     * already flushed XRSurfaceData, we will notice in the validate()
-	     * method above that it has been invalidated, and we will avoid
-	     * using those native resources that have already been disposed.
+	     * Drawable and Picture. This way if an application tries to render
+	     * to an already flushed XRSurfaceData, we will notice in the
+	     * validate() method above that it has been invalidated, and we will
+	     * avoid using those native resources that have already been
+	     * disposed.
 	     */
 	    invalidate();
 	    flushNativeSurface();
diff -r 2e58d73ce3ff -r d6ab5f9f96ef src/solaris/native/sun/java2d/x11/MaskBuffer.c
--- openjdk/jdk/src/solaris/native/sun/java2d/x11/MaskBuffer.c	Tue Aug 05 04:05:41 2008 +0200
+++ openjdk/jdk/src/solaris/native/sun/java2d/x11/MaskBuffer.c	Thu Oct 23 17:25:18 2008 +0200
@@ -44,13 +44,36 @@
 
   buffer->maskPixmap = XCreatePixmap(awt_display, window, MASK_TILE_SIZE, MASK_TILE_SIZE, 8);
   buffer->lineMaskPixmap = XCreatePixmap(awt_display, window, MASK_TILE_SIZE, MASK_TILE_SIZE, 8);
- 
+
   XRenderPictureAttributes pict_attr;
   buffer->maskPicture = XRenderCreatePicture(awt_display, buffer->maskPixmap, fmt, 0, &pict_attr);
   buffer->lineMaskPicture = XRenderCreatePicture(awt_display, buffer->lineMaskPixmap, fmt, 0, &pict_attr);
 
   XRenderFillRectangle (awt_display, PictOpClear, buffer->maskPicture, &color_black, 0, 0, MASK_TILE_SIZE, MASK_TILE_SIZE);
   XRenderFillRectangle (awt_display, PictOpClear, buffer->lineMaskPicture, &color_black, 0, 0, MASK_TILE_SIZE, MASK_TILE_SIZE);
+
+/*
+  //1x1 image mask pixmap
+  Pixmap m1p =  XCreatePixmap(awt_display, window, 1, 1, 8);
+  buffer->img1Mask = XRenderCreatePicture(awt_display, m1p, fmt, 0, &pict_attr);
+  XRenderFillRectangle (awt_display, PictOpSrc, buffer->img1Mask, &color_black, 0, 0, 1, 1);
+
+  //8x8 image mask pixmap
+  Pixmap m8p =  XCreatePixmap(awt_display, window, 8, 8, 8);
+  buffer->img8Mask = XRenderCreatePicture(awt_display, m8p, fmt, 0, &pict_attr);
+  XRenderFillRectangle (awt_display, PictOpSrc, buffer->img8Mask, &color_black, 0, 0, 8, 8);
+
+  //64x64 image mask pixmap
+  Pixmap m64p =  XCreatePixmap(awt_display, window, 64, 64, 8);
+  buffer->img64Mask = XRenderCreatePicture(awt_display, m64p, fmt, 0, &pict_attr);
+  XRenderFillRectangle (awt_display, PictOpSrc, buffer->img64Mask, &color_black, 0, 0, 64, 64);
+*/
+
+  Pixmap mp =  XCreatePixmap(awt_display, window, 64, 64, 8);
+  buffer->maxMask = XRenderCreatePicture(awt_display, mp, fmt, 0, &pict_attr);
+  XRenderFillRectangle (awt_display, PictOpClear, buffer->maxMask, &color_black, 0, 0, 64, 64);
+  buffer->maxWidth = 64;
+  buffer->maxHeight = 64;
 
   buffer->validatedGCAlpha = 1.0f;
   XGCValues values;
@@ -347,12 +370,12 @@
 	  if(maskRequired || lineList->used  > 0) {
             Picture mask = None;
 
-            if(lineList->used != 0) {
+            if(lineList->used > 0) {
               XDrawSegments(awt_display, buf->lineMaskPixmap, buf->drawLineGC, (XSegment *) lineList->elements, lineList->used);
               mask = buf->lineMaskPicture;
             }
 
-            if(rectList->used != 0) {
+            if(rectList->used > 0) {
                XRenderComposite (awt_display, PictOpSrc, buf->lineMaskPicture, None, buf->maskPicture, tile->dirtyLineArea.x, tile->dirtyLineArea.y, 0, 0, tile->dirtyLineArea.x, tile->dirtyLineArea.y, (tile->dirtyLineArea.x2 - tile->dirtyLineArea.x), (tile->dirtyLineArea.y2 - tile->dirtyLineArea.y)); 
                XRenderFillRectangles (awt_display, PictOpSrc, buf->maskPicture, &maskColor, (XRectangle*) rectList->elements, rectList->used);
                mask = buf->maskPicture;
@@ -371,7 +394,7 @@
                clearXRList(lineList);
 	     }
           }else
-          if(rectList->used != 0) {
+          if(rectList->used > 0) {
              translateRects(rectList, (tileStartX + buf->region.x), (tileStartY + buf->region.y));
              XRenderFillRectangles (awt_display, xrSrcData.compRule, dest, &xrSrcData.solidColor, (XRectangle*) rectList->elements, rectList->used);
              clearXRList(rectList);
diff -r 2e58d73ce3ff -r d6ab5f9f96ef src/solaris/native/sun/java2d/x11/MaskBuffer.h
--- openjdk/jdk/src/solaris/native/sun/java2d/x11/MaskBuffer.h	Tue Aug 05 04:05:41 2008 +0200
+++ openjdk/jdk/src/solaris/native/sun/java2d/x11/MaskBuffer.h	Thu Oct 23 17:25:18 2008 +0200
@@ -50,6 +50,13 @@
   Picture maskPicture;
   GC maskGC;
   jfloat validatedGCAlpha;
+
+  /*Picture img1Mask;
+  Picture img8Mask;
+  Picture img64Mask;*/
+  Picture maxMask;
+  jint maxWidth;
+  jint maxHeight;
 
   XrArrayList rects;
   XrArrayList lines;
diff -r 2e58d73ce3ff -r d6ab5f9f96ef src/solaris/native/sun/java2d/x11/XRPMBlitLoops.c
--- openjdk/jdk/src/solaris/native/sun/java2d/x11/XRPMBlitLoops.c	Tue Aug 05 04:05:41 2008 +0200
+++ openjdk/jdk/src/solaris/native/sun/java2d/x11/XRPMBlitLoops.c	Thu Oct 23 17:25:18 2008 +0200
@@ -65,6 +65,92 @@
 #endif /* !HEADLESS */
 }
 
+
+JNIEXPORT void JNICALL
+Java_sun_java2d_xr_XRPMBlitLoops_nativeTransformedRenderBlit
+    (JNIEnv *env, jclass xsd,
+     jlong srcData, jlong dstData,
+     jint srcx, jint srcy,
+     jint dstx, jint dsty,
+     jint width, jint height,
+     jint m00, jint m01, jint m02, jint m10, jint m11, jint m12, jint maskWidth, jint maskHeight, jint lastWidth, jint lastHeight)
+{
+#ifndef HEADLESS
+    J2dTraceLn(J2D_TRACE_INFO, "in XRPBMBlitLoops_nativeTranformedRenderBlit");
+
+    X11SDOps *srcXsdo, *dstXsdo;
+    SurfaceDataBounds span, srcBounds;
+
+    if (width <= 0 || height <= 0) {
+        return;
+    }
+
+    srcXsdo = (X11SDOps *)jlong_to_ptr(srcData);
+    if (srcXsdo == NULL) {
+        return;
+    }
+    dstXsdo = (X11SDOps *)jlong_to_ptr(dstData);
+    if (dstXsdo == NULL) {
+        return;
+    }
+
+
+    Picture mask = None;
+    if(maskWidth > -1)
+    {
+      XRenderColor maskColor;
+      maskColor.alpha = XDoubleToUShort(xrSrcData.extraAlpha);
+
+    /*Picture mask;
+    switch(maskSize)
+    {
+      case 1: 
+        mask = maskBuffer->img1Mask;
+        break;
+
+      case 8:
+        mask = maskBuffer->img8Mask;
+        break;
+
+      case 64:
+        mask = maskBuffer->img64Mask;
+        break;
+    }*/
+
+   if(maskBuffer->maxWidth < maskWidth || maskBuffer->maxHeight < maskHeight) {
+     XRenderPictFormat *fmt = XRenderFindStandardFormat(awt_display, PictStandardA8);
+     XRenderPictureAttributes pict_attr;
+     Pixmap mp =  XCreatePixmap(awt_display, RootWindow(awt_display, dstXsdo->configData->awt_visInfo.screen), maskWidth, maskHeight, 8);
+
+     //TODO: Alte maske free'n
+     maskBuffer->maxMask = XRenderCreatePicture(awt_display, mp, fmt, 0, &pict_attr);
+     XRenderFillRectangle (awt_display, PictOpClear, maskBuffer->maxMask, &maskColor, 0, 0, maskWidth, maskHeight);
+     maskBuffer->maxWidth = maskWidth;
+     maskBuffer->maxHeight = maskHeight;
+
+  //   printf("Reinitialized it!\n"); fflush(stdout);
+   }else
+   {
+    XRenderFillRectangle (awt_display, PictOpClear, maskBuffer->maxMask, &maskColor, 0, 0, lastWidth, lastHeight);
+   }
+
+    //printf("Blit: %d, %d, %d, %d\n", maskWidth, maskHeight, lastWidth, lastHeight); fflush(stdout);
+
+    XRenderFillRectangle (awt_display, PictOpSrc, maskBuffer->maxMask, &maskColor, 0, 0, maskWidth, maskHeight);
+    
+    XTransform tr;
+    BUILD_TRANSFORM_MATRIX(tr, m00, m01, m02, m10, m11, m12);
+    XRenderSetPictureTransform (awt_display, maskBuffer->maxMask, &tr);
+
+    mask = maskBuffer->maxMask;
+}
+
+    XRenderComposite (awt_display, xrSrcData.compRule, srcXsdo->xrPic, mask, dstXsdo->xrPic, srcx, srcy, 0, 0, dstx, dsty, width, height); 
+    
+
+    X11SD_DirectRenderNotify(env, dstXsdo);
+#endif /* !HEADLESS */
+}
 
 #ifndef HEADLESS
 /**
diff -r 2e58d73ce3ff -r d6ab5f9f96ef src/solaris/native/sun/java2d/x11/XRSurfaceData.c
--- openjdk/jdk/src/solaris/native/sun/java2d/x11/XRSurfaceData.c	Tue Aug 05 04:05:41 2008 +0200
+++ openjdk/jdk/src/solaris/native/sun/java2d/x11/XRSurfaceData.c	Thu Oct 23 17:25:18 2008 +0200
@@ -33,19 +33,6 @@
 MaskBuffer *maskBuffer;
 XRenderColor color_black;
 #endif /* !HEADLESS */
-
-#define BUILD_TRANSFORM_MATRIX(TRANSFORM, M00, M01, M02, M10, M11, M12)                        \
-    {                                                                                          \
-      TRANSFORM.matrix[0][0] = M00;                                                            \
-      TRANSFORM.matrix[0][1] = M01;                                                            \
-      TRANSFORM.matrix[0][2] = M02;                                                            \
-      TRANSFORM.matrix[1][0] = M10;                                                            \
-      TRANSFORM.matrix[1][1] = M11;                                                            \
-      TRANSFORM.matrix[1][2] = M12;                                                            \
-      TRANSFORM.matrix[2][0] = 0;                                                              \
-      TRANSFORM.matrix[2][1] = 0;                                                              \
-      TRANSFORM.matrix[2][2] = 1<<16;                                                          \
-    }
 
 JNIEXPORT void JNICALL
    Java_sun_java2d_xr_XRSurfaceData_XRInitXRender(JNIEnv *env, jobject xsd, jlong pXSData, jint pictFormat)
diff -r 2e58d73ce3ff -r d6ab5f9f96ef src/solaris/native/sun/java2d/x11/XRSurfaceData.h
--- openjdk/jdk/src/solaris/native/sun/java2d/x11/XRSurfaceData.h	Tue Aug 05 04:05:41 2008 +0200
+++ openjdk/jdk/src/solaris/native/sun/java2d/x11/XRSurfaceData.h	Thu Oct 23 17:25:18 2008 +0200
@@ -27,6 +27,19 @@
 #define XRSurfaceData_h_Included
 
 #define XDoubleToUShort(f)    ((unsigned short) ((f) * 65535))
+
+#define BUILD_TRANSFORM_MATRIX(TRANSFORM, M00, M01, M02, M10, M11, M12)                        \
+    {                                                                                          \
+      TRANSFORM.matrix[0][0] = M00;                                                            \
+      TRANSFORM.matrix[0][1] = M01;                                                            \
+      TRANSFORM.matrix[0][2] = M02;                                                            \
+      TRANSFORM.matrix[1][0] = M10;                                                            \
+      TRANSFORM.matrix[1][1] = M11;                                                            \
+      TRANSFORM.matrix[1][2] = M12;                                                            \
+      TRANSFORM.matrix[2][0] = 0;                                                              \
+      TRANSFORM.matrix[2][1] = 0;                                                              \
+      TRANSFORM.matrix[2][2] = 1<<16;                                                          \
+    }
 
 /* Holds source-parameters*/
 typedef struct {
